"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai = __importStar(require("chai"));
var mockery = __importStar(require("mockery"));
var os_1 = require("os");
var sinon = __importStar(require("sinon"));
var sinon_chai_1 = __importDefault(require("sinon-chai"));
var constants_1 = require("../constants");
var config_parser_1 = require("./config-parser");
var license_formatter_1 = require("./license-formatter");
var license_manager_1 = require("./license-manager");
var expect = chai.expect;
chai.use(sinon_chai_1.default);
// tslint:disable: no-unused-expression
describe('#LicenseManager', function () {
    var sandbox;
    var MockeryLicenseManager;
    var LicenseFormatterStub;
    var mockLicenseFormatter;
    var mockFormats = {
        css: {
            eachLine: {
                append: ' */',
                prepend: '/*',
            },
            prepend: ' * ',
        },
        js: {
            eachLine: {
                append: ' */',
                prepend: '/*',
            },
            prepend: ' * ',
        },
        sh: {
            eachLine: {
                prepend: '# ',
            },
        },
    };
    before(function () {
        mockery.enable({
            warnOnReplace: false,
            warnOnUnregistered: false,
        });
    });
    beforeEach(function () {
        sandbox = sinon.createSandbox();
        mockLicenseFormatter = sinon.createStubInstance(license_formatter_1.LicenseFormatter);
        LicenseFormatterStub = sandbox.stub().returns(mockLicenseFormatter);
        mockery.registerMock('./license-formatter', { LicenseFormatter: LicenseFormatterStub });
        delete require.cache[require.resolve('./license-manager')];
        MockeryLicenseManager = require('./license-manager').LicenseManager;
    });
    afterEach(function () {
        sandbox.restore();
        mockery.deregisterAll();
    });
    after(function () {
        mockery.disable();
    });
    describe('constructor', function () {
        it('should configure with a license formatter that lacks declared formats', function () {
            var lm = new MockeryLicenseManager(['some', 'paths'], 'some license text', null, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.TRIM, license_manager_1.ManagementMode.CHECK, 'some output path');
            expect(lm.paths).to.deep.equal(['some', 'paths']);
            expect(LicenseFormatterStub).to.have.been.calledOnceWithExactly(constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.TRIM);
            expect(lm.licenseFormatter).to.deep.equal(mockLicenseFormatter);
            expect(lm.mode).to.deep.equal(license_manager_1.ManagementMode.CHECK);
            expect(lm.outputPath).to.deep.equal('some output path');
        });
        it('should configure with a license formatter that has declared formats', function () {
            var lm = new MockeryLicenseManager(['some', 'paths'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.INSERT, 'some output path');
            expect(lm.paths).to.deep.equal(['some', 'paths']);
            expect(LicenseFormatterStub).to.have.been.calledOnceWithExactly(constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, mockFormats);
            expect(lm.licenseFormatter).to.deep.equal(mockLicenseFormatter);
            expect(lm.mode).to.deep.equal(license_manager_1.ManagementMode.INSERT);
            expect(lm.outputPath).to.deep.equal('some output path');
        });
    });
    describe('manage', function () {
        var fsReadFileStub;
        var fsWriteFileStub;
        var consoleLogStub;
        var consoleErrorStub;
        var lm;
        beforeEach(function () {
            mockLicenseFormatter.formatLicenseForFile.returns('some license');
            fsReadFileStub = sandbox.stub().onFirstCall().returns('file without license')
                .onSecondCall().returns('some license\nin the file');
            fsWriteFileStub = sandbox.stub();
            consoleLogStub = sandbox.stub(console, 'log');
            consoleErrorStub = sandbox.stub(console, 'error');
            mockery.registerMock('fs-extra', { readFileSync: fsReadFileStub, writeFileSync: fsWriteFileStub });
            delete require.cache[require.resolve('./license-manager')];
            MockeryLicenseManager = require('./license-manager').LicenseManager;
            lm = new MockeryLicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK);
        });
        function expect_to_read_files() {
            expect(fsReadFileStub.callCount).to.deep.equal(2);
            expect(fsReadFileStub).to.have.been.calledWithExactly('some.txt');
            expect(fsReadFileStub).to.have.been.calledWithExactly('.dotfile');
        }
        function expect_to_format_license() {
            expect(mockLicenseFormatter.formatLicenseForFile.callCount).to.deep.equal(2);
            expect(mockLicenseFormatter.formatLicenseForFile).to.have.been.calledWithExactly('.txt', 'some license text');
            expect(mockLicenseFormatter.formatLicenseForFile).to.have.been.calledWithExactly('.dotfile', 'some license text');
        }
        it('should throw an error when missing licenses in check mode', function () {
            lm.mode = license_manager_1.ManagementMode.CHECK;
            expect(function () {
                lm.manage();
            }).to.throw(/License check failed. 1 file/);
            expect_to_read_files();
            expect_to_format_license();
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleLogStub).to.not.have.been.called;
            expect(consoleErrorStub).to.have.been.calledOnceWithExactly(sinon.match(/License not found in/), 'some.txt');
        });
        it('should not throw an error when all files have license in check mode', function () {
            fsReadFileStub.onFirstCall().returns('some license');
            lm.mode = license_manager_1.ManagementMode.CHECK;
            lm.manage();
            expect_to_read_files();
            expect_to_format_license();
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/All files have licenses/));
        });
        it('should insert licenses to those missing', function () {
            lm.mode = license_manager_1.ManagementMode.INSERT;
            var insertStub = sandbox.stub(lm, 'insertLicense');
            lm.manage();
            expect_to_read_files();
            expect_to_format_license();
            expect(insertStub).to.have.been
                .calledOnceWithExactly('file without license', 'some license', 'some.txt');
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/Inserted license into 1 file\(s\)/));
        });
        it('should remove license from those with it', function () {
            lm.mode = license_manager_1.ManagementMode.REMOVE;
            var removeStub = sandbox.stub(lm, 'removeLicense');
            lm.manage();
            expect_to_read_files();
            expect_to_format_license();
            expect(removeStub).to.have.been
                .calledOnceWithExactly('some license\nin the file', 'some license', '.dotfile');
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/Removed license from 1 file\(s\)/));
        });
        it('should write to output path when requested in check mode', function () {
            lm.mode = license_manager_1.ManagementMode.CHECK;
            lm.outputPath = 'some output';
            expect(function () {
                lm.manage();
            }).to.throw(/License check failed. 1 file/);
            expect(fsWriteFileStub).to.have.been.calledOnceWithExactly('some output', ['some.txt'].join(os_1.EOL));
        });
        it('should write to output path when requested in insert mode', function () {
            lm.mode = license_manager_1.ManagementMode.INSERT;
            lm.outputPath = 'some output';
            sandbox.stub(lm, 'insertLicense');
            lm.manage();
            expect(fsWriteFileStub).to.have.been.calledOnceWithExactly('some output', ['some.txt'].join(os_1.EOL));
        });
        it('should write to output path when requested in remove mode', function () {
            lm.mode = license_manager_1.ManagementMode.REMOVE;
            lm.outputPath = 'some output';
            sandbox.stub(lm, 'removeLicense');
            lm.manage();
            expect(fsWriteFileStub).to.have.been.calledOnceWithExactly('some output', ['.dotfile'].join(os_1.EOL));
        });
    });
    describe('insertLicense', function () {
        var fsWriteFileStub;
        var lm;
        beforeEach(function () {
            mockLicenseFormatter.formatLicenseForFile.returns('some license');
            fsWriteFileStub = sandbox.stub();
            mockery.registerMock('fs-extra', { writeFileSync: fsWriteFileStub });
            delete require.cache[require.resolve('./license-manager')];
            MockeryLicenseManager = require('./license-manager').LicenseManager;
            lm = new MockeryLicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK);
        });
        it('should write license to start of file when no shebang', function () {
            lm.insertLicense('some file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some license' + os_1.EOL + 'some file contents');
        });
        it('should write license after shebang in file when shebang', function () {
            lm.insertLicense('#!ooh shebang\nsome file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', '#!ooh shebang' + os_1.EOL + 'some license' + os_1.EOL + 'some file contents');
        });
    });
    describe('removeLicense', function () {
        var fsWriteFileStub;
        var lm;
        beforeEach(function () {
            mockLicenseFormatter.formatLicenseForFile.returns('some license');
            fsWriteFileStub = sandbox.stub();
            mockery.registerMock('fs-extra', { writeFileSync: fsWriteFileStub });
            delete require.cache[require.resolve('./license-manager')];
            MockeryLicenseManager = require('./license-manager').LicenseManager;
            lm = new MockeryLicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK);
        });
        it('should do nothing when no license', function () {
            lm.removeLicense('some file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.not.have.been.called;
        });
        it('should remove single line license when present', function () {
            lm.removeLicense('some license\nsome file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some file contents');
        });
        it('should remove multi line license when present', function () {
            var multiLineLicense = 'some\nmulti line\nlicense';
            lm.removeLicense(multiLineLicense + '\nsome file contents', multiLineLicense, 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some file contents');
        });
        it('should handle when partial match of license is present', function () {
            var multiLineLicense = 'some\nmulti line\nlicense';
            lm.removeLicense('some\nmulti line\nlike license\n' + multiLineLicense + '\nsome file contents', multiLineLicense, 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some\nmulti line\nlike license\nsome file contents');
        });
    });
    describe('formatForCheck', function () {
        var lm;
        beforeEach(function () {
            lm = new MockeryLicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK);
        });
        it('should normalise line endings and trim whitespace', function () {
            var multiLineLicense = 'some\r\nmulti line   \r\nlicense ';
            var formatted = lm.formatForCheck(multiLineLicense);
            expect(formatted).to.deep.equal('some\nmulti line\nlicense');
        });
        it('should normalise line endings and leave whitespace', function () {
            lm.trailingWhitespace = config_parser_1.TrailingWhitespaceMode.TRIM;
            var multiLineLicense = 'some\r\nmulti line   \r\nlicense ';
            var formatted = lm.formatForCheck(multiLineLicense);
            expect(formatted).to.deep.equal('some\nmulti line   \nlicense ');
        });
    });
});
//# sourceMappingURL=license-manager.spec.js.map