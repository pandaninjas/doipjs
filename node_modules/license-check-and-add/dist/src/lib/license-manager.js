"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = __importStar(require("fs-extra"));
var os_1 = require("os");
var path = __importStar(require("path"));
var config_parser_1 = require("./config-parser");
var license_formatter_1 = require("./license-formatter");
var ManagementMode;
(function (ManagementMode) {
    ManagementMode[ManagementMode["CHECK"] = 1] = "CHECK";
    ManagementMode[ManagementMode["INSERT"] = 2] = "INSERT";
    ManagementMode[ManagementMode["REMOVE"] = 3] = "REMOVE";
})(ManagementMode = exports.ManagementMode || (exports.ManagementMode = {}));
var LicenseManager = /** @class */ (function () {
    function LicenseManager(paths, licenseText, declaredFormats, defaultFormat, trailingWhitespace, mode, outputPath) {
        this.paths = paths;
        this.licenseFormatter = declaredFormats ?
            new license_formatter_1.LicenseFormatter(defaultFormat, trailingWhitespace, declaredFormats) :
            new license_formatter_1.LicenseFormatter(defaultFormat, trailingWhitespace);
        this.licenseText = licenseText;
        this.mode = mode;
        this.outputPath = outputPath;
        this.trailingWhitespace = trailingWhitespace;
    }
    LicenseManager.prototype.manage = function () {
        var _this = this;
        var missingLicenses = [];
        var insertedLicenses = [];
        var removedLicenses = [];
        this.paths.forEach(function (filePath) {
            var fileContents = fs.readFileSync(filePath).toString();
            var normalisedFileContents = _this.formatForCheck(fileContents);
            var extension = path.extname(filePath) ? path.extname(filePath) : path.basename(filePath);
            var formattedLicense = _this.licenseFormatter.formatLicenseForFile(extension, _this.licenseText);
            var normalisedLicense = _this.formatForCheck(formattedLicense);
            if (!normalisedFileContents.includes(normalisedLicense)) {
                if (_this.mode === ManagementMode.INSERT) {
                    _this.insertLicense(fileContents, formattedLicense, filePath);
                    insertedLicenses.push(filePath);
                }
                else if (_this.mode === ManagementMode.CHECK) {
                    console.error('\x1b[31m\u2717\x1b[0m License not found in', filePath);
                    missingLicenses.push(filePath);
                }
            }
            else if (_this.mode === ManagementMode.REMOVE) {
                _this.removeLicense(fileContents, formattedLicense, filePath);
                removedLicenses.push(filePath);
            }
        });
        if (this.outputPath) {
            switch (this.mode) {
                case ManagementMode.INSERT:
                    fs.writeFileSync(this.outputPath, insertedLicenses.join(os_1.EOL));
                    break;
                case ManagementMode.CHECK:
                    fs.writeFileSync(this.outputPath, missingLicenses.join(os_1.EOL));
                    break;
                case ManagementMode.REMOVE:
                    fs.writeFileSync(this.outputPath, removedLicenses.join(os_1.EOL));
                    break;
            }
        }
        if (this.mode !== ManagementMode.REMOVE) {
            /* istanbul ignore else  */
            if (this.mode === ManagementMode.INSERT) {
                console.log("\u001B[33m!\u001B[0m Inserted license into " + insertedLicenses.length + " file(s)");
            }
            else if (this.mode === ManagementMode.CHECK) {
                if (missingLicenses.length > 0) {
                    throw new Error("License check failed. " + missingLicenses.length + " file(s) did not have the license.");
                }
                console.log('\x1b[32m\u2714\x1b[0m All files have licenses.');
            }
        }
        else {
            console.log("\u001B[32m\u2714\u001B[0m Removed license from " + removedLicenses.length + " file(s).");
        }
    };
    LicenseManager.prototype.insertLicense = function (fileContents, formattedLicense, filePath) {
        var newText = '';
        if (fileContents.startsWith('#!')) {
            var lines = fileContents.split(/\r?\n/);
            newText = lines[0] + os_1.EOL + formattedLicense;
            lines.shift();
            newText += os_1.EOL + lines.join(os_1.EOL);
        }
        else {
            newText = formattedLicense + os_1.EOL + fileContents;
        }
        fs.writeFileSync(filePath, newText);
    };
    LicenseManager.prototype.removeLicense = function (fileContents, formattedLicense, filePath) {
        var fileLines = fileContents.split(/\r?\n/);
        var licenseLines = formattedLicense.split(/\r?\n/);
        fileLines.some(function (fileLine, idx) {
            if (fileLine === licenseLines[0]) {
                var match = fileLines.slice(idx + 1, idx + licenseLines.length).every(function (nextLine, subsetIdx) {
                    return nextLine === licenseLines[subsetIdx + 1];
                });
                if (match) {
                    fileLines.splice(idx, licenseLines.length);
                    fs.writeFileSync(filePath, fileLines.join(os_1.EOL));
                    return true; // break out assume one license per file
                }
            }
            return false;
        });
    };
    LicenseManager.prototype.formatForCheck = function (textBlock) {
        var _this = this;
        return textBlock.split(/\r?\n/).map(function (line) {
            return _this.trailingWhitespace === config_parser_1.TrailingWhitespaceMode.DEFAULT ? line.replace(/\s+$/, '') : line;
        }).join('\n');
    };
    return LicenseManager;
}());
exports.LicenseManager = LicenseManager;
//# sourceMappingURL=license-manager.js.map