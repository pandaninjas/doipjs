"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai = __importStar(require("chai"));
var fs = __importStar(require("fs-extra"));
var mockery = __importStar(require("mockery"));
var os_1 = require("os");
var path = __importStar(require("path"));
var sinon = __importStar(require("sinon"));
var sinon_chai_1 = __importDefault(require("sinon-chai"));
var constants_1 = require("../constants");
var config_parser_1 = require("./config-parser");
var license_formatter_1 = require("./license-formatter");
var expect = chai.expect;
chai.use(sinon_chai_1.default);
describe('#LicenseFormatter', function () {
    var mockDefaultFormat = {
        append: 'DEFAULT ',
        prepend: 'DEFAULT ',
    };
    var mockFormats = {
        css: {
            eachLine: {
                append: ' */',
                prepend: '/*',
            },
            prepend: ' * ',
        },
        js: {
            eachLine: {
                append: ' */',
                prepend: '/*',
            },
            prepend: ' * ',
        },
        sh: {
            eachLine: {
                prepend: '# ',
            },
        },
    };
    var sandbox;
    var separateStub;
    beforeEach(function () {
        sandbox = sinon.createSandbox();
    });
    afterEach(function () {
        sandbox.restore();
    });
    describe('constructor', function () {
        beforeEach(function () {
            separateStub = sandbox.stub(license_formatter_1.LicenseFormatter.prototype, 'separateFileTypesInFormat').onFirstCall().returns(mockFormats);
        });
        it('should configure all values and set default formats as the license formats', function () {
            var lf = new license_formatter_1.LicenseFormatter(mockDefaultFormat, config_parser_1.TrailingWhitespaceMode.TRIM);
            expect(separateStub.callCount).to.equal(1);
            expect(separateStub).to.have.been.calledOnceWithExactly(constants_1.DEFAULT_FORMATS);
            expect(lf.defaultFormat).to.deep.equal(mockDefaultFormat);
            expect(lf.stripTrailingWhitespace).to.equal(true);
            expect(lf.licenseFormats).to.deep.equal(mockFormats);
        });
        it('should configure all values and set default formats as the license formats combined with passed formats', function () {
            var declaredFormats = {
                html: {
                    append: '-->',
                    prepend: '<!--',
                },
                js: {
                    eachLine: {
                        prepend: '// ',
                    },
                },
            };
            separateStub.onSecondCall().returns(declaredFormats);
            var lf = new license_formatter_1.LicenseFormatter(mockDefaultFormat, config_parser_1.TrailingWhitespaceMode.TRIM, declaredFormats);
            expect(separateStub.callCount).to.equal(2);
            expect(separateStub.getCall(0).args).to.deep.equal([constants_1.DEFAULT_FORMATS]);
            expect(separateStub.getCall(1).args).to.deep.equal([declaredFormats]);
            expect(lf.defaultFormat).to.deep.equal(mockDefaultFormat);
            expect(lf.stripTrailingWhitespace).to.equal(true);
            expect(lf.licenseFormats).to.deep.equal(Object.assign(mockFormats, declaredFormats));
            expect(lf.licenseFormats.js).to.deep.equal(declaredFormats.js);
        });
    });
    describe('formatLicenseForFile', function () {
        beforeEach(function () {
            separateStub = sandbox.stub(license_formatter_1.LicenseFormatter.prototype, 'separateFileTypesInFormat').onFirstCall().returns(mockFormats);
        });
        var mockLicenseText = fs.readFileSync(path.resolve(__dirname, '../../test/original-files/LICENSE'), 'utf-8');
        it('should use an already formatted license file when one specified', function () {
            mockery.enable({
                warnOnReplace: false,
                warnOnUnregistered: false,
            });
            var fsReadFileStub = sandbox.stub().returns('some license');
            mockery.registerMock('fs-extra', { readFileSync: fsReadFileStub });
            delete require.cache[require.resolve('./license-formatter')];
            var mockeriedLicenseFormatter = require('./license-formatter').LicenseFormatter;
            separateStub = sandbox.stub(mockeriedLicenseFormatter.prototype, 'separateFileTypesInFormat').onFirstCall()
                .returns(mockFormats);
            var lf = new mockeriedLicenseFormatter(mockDefaultFormat, config_parser_1.TrailingWhitespaceMode.TRIM);
            lf.defaultFormat = {
                file: 'some file',
            };
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal('some license');
            mockery.disable();
            delete require.cache[require.resolve('./license-formatter')];
        });
        it('should prepend a license', function () {
            var testDefaultFormat = {
                prepend: '###',
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal("###\n" + mockLicenseText);
        });
        it('should append a license', function () {
            var testDefaultFormat = {
                append: '~~~',
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal(mockLicenseText + "\n~~~");
        });
        it('should prepend and append a license', function () {
            var testDefaultFormat = {
                append: '~~~',
                prepend: '###',
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal("###\n" + mockLicenseText + "\n~~~");
        });
        it('should prepend each line', function () {
            var testDefaultFormat = {
                eachLine: {
                    prepend: '### ',
                },
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal(mockLicenseText.split(/\r\n|\n/).map(function (line) { return '### ' + line; }).join(os_1.EOL));
        });
        it('should append each line', function () {
            var testDefaultFormat = {
                eachLine: {
                    append: '~~~',
                },
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal(mockLicenseText.split(/\r\n|\n/).map(function (line) { return line + '~~~'; }).join(os_1.EOL));
        });
        it('should prepend and append each line of a license', function () {
            var testDefaultFormat = {
                eachLine: {
                    append: '~~~',
                    prepend: '### ',
                },
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            var formatted = lf.formatLicenseForFile('ext', mockLicenseText);
            expect(formatted).to.deep.equal(mockLicenseText.split(/\r\n|\n/).map(function (line) { return '### ' + line + '~~~'; }).join(os_1.EOL));
        });
        it('should remove trailing whitespace on lines', function () {
            var testDefaultFormat = {
                eachLine: {
                    prepend: '# ',
                },
            };
            var lf = new license_formatter_1.LicenseFormatter(testDefaultFormat, config_parser_1.TrailingWhitespaceMode.TRIM);
            var formatted = lf.formatLicenseForFile('ext', "license\nwith\n\nblank\nlines");
            expect(formatted).to.deep.equal("# license\n# with\n#\n# blank\n# lines");
        });
        it('should select matching formatting from specified formats', function () {
            var lf = new license_formatter_1.LicenseFormatter(mockDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
            lf.licenseFormats = mockFormats;
            var formatted = lf.formatLicenseForFile('sh', mockLicenseText);
            expect(formatted).to.deep.equal(mockLicenseText.split(/\r\n|\n/).map(function (line) { return '# ' + line; }).join(os_1.EOL));
        });
    });
    describe('separateFileTypesInFormat', function () {
        var lf = new license_formatter_1.LicenseFormatter(mockDefaultFormat, config_parser_1.TrailingWhitespaceMode.DEFAULT);
        it('should split keys on pipe synbole', function () {
            var prependVal = {
                prepend: 'this',
            };
            var appendVal = {
                prepend: 'this',
            };
            var obj = {
                'some|delimitted': prependVal,
                'useful|keys': appendVal,
            };
            var splitObj = lf.separateFileTypesInFormat(obj);
            expect(splitObj).to.deep.equal({
                '.delimitted': prependVal,
                '.keys': appendVal,
                '.some': prependVal,
                '.useful': appendVal,
            });
        });
    });
});
//# sourceMappingURL=license-formatter.spec.js.map