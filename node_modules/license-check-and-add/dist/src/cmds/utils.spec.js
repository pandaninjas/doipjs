"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai = __importStar(require("chai"));
var mockery = __importStar(require("mockery"));
var path = __importStar(require("path"));
var sinon = __importStar(require("sinon"));
var sinon_chai_1 = __importDefault(require("sinon-chai"));
var constants_1 = require("../constants");
var license_manager_1 = require("../lib/license-manager");
var expect = chai.expect;
chai.use(sinon_chai_1.default);
describe('#CommandUtils', function () {
    var sandbox;
    var getPathsStub;
    var configParserStub;
    var LicenseManagerStub;
    var mockLicenseManager;
    var MockUtils;
    var mockConfig = {
        defaultFormat: 'some format',
        ignore: ['some', 'stuff', 'to', 'ignore'],
        ignoreDefaultIgnores: 'ignore default',
        license: 'some license',
        licenseFormats: 'some formats',
        output: 'some outpu',
        trailingWhitespace: 'trail the whitespace',
    };
    before(function () {
        mockery.enable({
            warnOnReplace: false,
            warnOnUnregistered: false,
        });
    });
    beforeEach(function () {
        sandbox = sinon.createSandbox();
        getPathsStub = sandbox.stub().returns('some paths');
        configParserStub = sandbox.stub().returns(mockConfig);
        mockLicenseManager = sandbox.createStubInstance(license_manager_1.LicenseManager);
        LicenseManagerStub = sandbox.stub().returns(mockLicenseManager);
        mockery.registerMock('../lib/file-finder', { getPaths: getPathsStub });
        mockery.registerMock('../lib/config-parser', { configParser: configParserStub });
        mockery.registerMock('../lib/license-manager', { LicenseManager: LicenseManagerStub });
        delete require.cache[require.resolve('./utils.ts')];
        MockUtils = require('./utils.ts');
    });
    afterEach(function () {
        sandbox.restore();
        mockery.deregisterAll();
    });
    after(function () {
        mockery.disable();
    });
    describe('addExports', function () {
        it('should add to exports', function () {
            var mockExports = {};
            var mockCommandModule = {
                aliases: 'some alias',
                builder: 'some builder',
                command: 'some command',
                describe: 'some description',
                helper: 'some helper',
            };
            MockUtils.addExports(mockExports, mockCommandModule);
            expect(mockExports).to.deep.equal(mockCommandModule);
        });
    });
    describe('manageLicense', function () {
        it('should setup license manager and manage', function () {
            var mockArgs = {};
            mockArgs[constants_1.CONFIG_OPTION] = 'some config file';
            MockUtils.manageLicense(mockArgs, license_manager_1.ManagementMode.CHECK);
            expect(configParserStub).to.have.been.calledOnceWithExactly(path.resolve(process.cwd(), 'some config file'));
            expect(getPathsStub).to.have.been.calledOnceWithExactly(mockConfig.ignore, mockConfig.ignoreDefaultIgnores);
            expect(LicenseManagerStub).to.have.been.calledOnceWithExactly('some paths', mockConfig.license, mockConfig.licenseFormats, mockConfig.defaultFormat, mockConfig.trailingWhitespace, license_manager_1.ManagementMode.CHECK, mockConfig.output);
            expect(mockLicenseManager.manage).to.have.been.calledOnceWithExactly();
        });
    });
});
//# sourceMappingURL=utils.spec.js.map