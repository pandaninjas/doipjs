var doipFetchers = (function (exports) {
  'use strict';

  var fetcher = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get activitypub () { return activitypub$1; },
    get aspe () { return aspe; },
    get dns () { return dns$1; },
    get graphql () { return graphql; },
    get http () { return http$2; },
    get irc () { return irc; },
    get matrix () { return matrix; },
    get openpgp () { return openpgp; },
    get telegram () { return telegram; },
    get xmpp () { return xmpp$1; }
  });

  var global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  function bind$1(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // utils is a library of generic helper functions non-specific to axios

  const {toString: toString$1} = Object.prototype;
  const {getPrototypeOf} = Object;

  const kindOf = (cache => thing => {
      const str = toString$1.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(Object.create(null));

  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type
  };

  const typeOfTest = type => thing => typeof thing === type;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   *
   * @returns {boolean} True if value is an Array, otherwise false
   */
  const {isArray: isArray$2} = Array;

  /**
   * Determine if a value is undefined
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  const isUndefined$1 = typeOfTest('undefined');

  /**
   * Determine if a value is a Buffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
  function isBuffer$2(val) {
    return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor)
      && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  const isArrayBuffer = kindOfTest('ArrayBuffer');


  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    let result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a String, otherwise false
   */
  const isString$1 = typeOfTest('string');

  /**
   * Determine if a value is a Function
   *
   * @param {*} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  const isFunction$1 = typeOfTest('function');

  /**
   * Determine if a value is a Number
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Number, otherwise false
   */
  const isNumber$2 = typeOfTest('number');

  /**
   * Determine if a value is an Object
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an Object, otherwise false
   */
  const isObject$2 = (thing) => thing !== null && typeof thing === 'object';

  /**
   * Determine if a value is a Boolean
   *
   * @param {*} thing The value to test
   * @returns {boolean} True if value is a Boolean, otherwise false
   */
  const isBoolean$1 = thing => thing === true || thing === false;

  /**
   * Determine if a value is a plain Object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a plain Object, otherwise false
   */
  const isPlainObject = (val) => {
    if (kindOf(val) !== 'object') {
      return false;
    }

    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };

  /**
   * Determine if a value is a Date
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Date, otherwise false
   */
  const isDate$1 = kindOfTest('Date');

  /**
   * Determine if a value is a File
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  const isFile = kindOfTest('File');

  /**
   * Determine if a value is a Blob
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  const isBlob = kindOfTest('Blob');

  /**
   * Determine if a value is a FileList
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  const isFileList = kindOfTest('FileList');

  /**
   * Determine if a value is a Stream
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  const isStream = (val) => isObject$2(val) && isFunction$1(val.pipe);

  /**
   * Determine if a value is a FormData
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  const isFormData = (thing) => {
    let kind;
    return thing && (
      (typeof FormData === 'function' && thing instanceof FormData) || (
        isFunction$1(thing.append) && (
          (kind = kindOf(thing)) === 'formdata' ||
          // detect form-data instance
          (kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]')
        )
      )
    )
  };

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  const isURLSearchParams = kindOfTest('URLSearchParams');

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   *
   * @returns {String} The String freed of excess whitespace
   */
  const trim = (str) => str.trim ?
    str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   *
   * @param {Boolean} [allOwnKeys = false]
   * @returns {any}
   */
  function forEach$1(obj, fn, {allOwnKeys = false} = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    let i;
    let l;

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray$2(obj)) {
      // Iterate over array values
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;

      for (i = 0; i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }

  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }

  const _global = (() => {
    /*eslint no-undef:0*/
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global$1)
  })();

  const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   *
   * @returns {Object} Result of all merge properties
   */
  function merge$2(/* obj1, obj2, obj3, ... */) {
    const {caseless} = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge$2(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge$2({}, val);
      } else if (isArray$2(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };

    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach$1(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   *
   * @param {Boolean} [allOwnKeys]
   * @returns {Object} The resulting value of object a
   */
  const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
    forEach$1(b, (val, key) => {
      if (thisArg && isFunction$1(val)) {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    }, {allOwnKeys});
    return a;
  };

  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   *
   * @returns {string} content value without BOM
   */
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }
    return content;
  };

  /**
   * Inherit the prototype methods from one constructor into another
   * @param {function} constructor
   * @param {function} superConstructor
   * @param {object} [props]
   * @param {object} [descriptors]
   *
   * @returns {void}
   */
  const inherits$2 = (constructor, superConstructor, props, descriptors) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, 'super', {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };

  /**
   * Resolve object with deep prototype chain to a flat object
   * @param {Object} sourceObj source object
   * @param {Object} [destObj]
   * @param {Function|Boolean} [filter]
   * @param {Function} [propFilter]
   *
   * @returns {Object}
   */
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};

    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;

    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

    return destObj;
  };

  /**
   * Determines whether a string ends with the characters of a specified string
   *
   * @param {String} str
   * @param {String} searchString
   * @param {Number} [position= 0]
   *
   * @returns {boolean}
   */
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === undefined || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };


  /**
   * Returns new array from array like object or null if failed
   *
   * @param {*} [thing]
   *
   * @returns {?Array}
   */
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray$2(thing)) return thing;
    let i = thing.length;
    if (!isNumber$2(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };

  /**
   * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
   * thing passed in is an instance of Uint8Array
   *
   * @param {TypedArray}
   *
   * @returns {Array}
   */
  // eslint-disable-next-line func-names
  const isTypedArray = (TypedArray => {
    // eslint-disable-next-line func-names
    return thing => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

  /**
   * For each entry in the object, call the function with the key and value.
   *
   * @param {Object<any, any>} obj - The object to iterate over.
   * @param {Function} fn - The function to call for each entry.
   *
   * @returns {void}
   */
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];

    const iterator = generator.call(obj);

    let result;

    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };

  /**
   * It takes a regular expression and a string, and returns an array of all the matches
   *
   * @param {string} regExp - The regular expression to match against.
   * @param {string} str - The string to search.
   *
   * @returns {Array<boolean>}
   */
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];

    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }

    return arr;
  };

  /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
  const isHTMLForm = kindOfTest('HTMLFormElement');

  const toCamelCase = str => {
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };

  /* Creating a function that will check if an object has a property. */
  const hasOwnProperty$2 = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

  /**
   * Determine if a value is a RegExp object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a RegExp object, otherwise false
   */
  const isRegExp$1 = kindOfTest('RegExp');

  const reduceDescriptors = (obj, reducer) => {
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};

    forEach$1(descriptors, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });

    Object.defineProperties(obj, reducedDescriptors);
  };

  /**
   * Makes all methods read-only
   * @param {Object} obj
   */

  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      // skip restricted props in strict mode
      if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
        return false;
      }

      const value = obj[name];

      if (!isFunction$1(value)) return;

      descriptor.enumerable = false;

      if ('writable' in descriptor) {
        descriptor.writable = false;
        return;
      }

      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error('Can not rewrite read-only method \'' + name + '\'');
        };
      }
    });
  };

  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};

    const define = (arr) => {
      arr.forEach(value => {
        obj[value] = true;
      });
    };

    isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

    return obj;
  };

  const noop$1 = () => {};

  const toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };

  const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

  const DIGIT = '0123456789';

  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };

  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = '';
    const {length} = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length|0];
    }

    return str;
  };

  /**
   * If the thing is a FormData object, return true, otherwise return false.
   *
   * @param {unknown} thing - The thing to check.
   *
   * @returns {boolean}
   */
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
  }

  const toJSONObject = (obj) => {
    const stack = new Array(10);

    const visit = (source, i) => {

      if (isObject$2(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }

        if(!('toJSON' in source)) {
          stack[i] = source;
          const target = isArray$2(source) ? [] : {};

          forEach$1(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined$1(reducedValue) && (target[key] = reducedValue);
          });

          stack[i] = undefined;

          return target;
        }
      }

      return source;
    };

    return visit(obj, 0);
  };

  const isAsyncFn = kindOfTest('AsyncFunction');

  const isThenable = (thing) =>
    thing && (isObject$2(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);

  var utils$2 = {
    isArray: isArray$2,
    isArrayBuffer,
    isBuffer: isBuffer$2,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$2,
    isBoolean: isBoolean$1,
    isObject: isObject$2,
    isPlainObject,
    isUndefined: isUndefined$1,
    isDate: isDate$1,
    isFile,
    isBlob,
    isRegExp: isRegExp$1,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach: forEach$1,
    merge: merge$2,
    extend,
    trim,
    stripBOM,
    inherits: inherits$2,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty$2,
    hasOwnProp: hasOwnProperty$2, // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$1,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray$1 = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  /*
   * Export kMaxLength after typed array support is determined.
   */
  var _kMaxLength = kMaxLength();

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
    if (typeof Symbol !== 'undefined' && Symbol.species &&
        Buffer[Symbol.species] === Buffer) ;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$1(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length)
  }
  Buffer.isBuffer = isBuffer$1;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray$1(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$1(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var _polyfillNode_buffer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Buffer: Buffer,
    INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
    SlowBuffer: SlowBuffer,
    isBuffer: isBuffer$1,
    kMaxLength: _kMaxLength
  });

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  function AxiosError(message, code, config, request, response) {
    Error.call(this);

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error()).stack;
    }

    this.message = message;
    this.name = 'AxiosError';
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }

  utils$2.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$2.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });

  const prototype$1 = AxiosError.prototype;
  const descriptors = {};

  [
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL'
  // eslint-disable-next-line func-names
  ].forEach(code => {
    descriptors[code] = {value: code};
  });

  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

  // eslint-disable-next-line func-names
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);

    utils$2.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, prop => {
      return prop !== 'isAxiosError';
    });

    AxiosError.call(axiosError, error.message, code, config, request, response);

    axiosError.cause = error;

    axiosError.name = error.name;

    customProps && Object.assign(axiosError, customProps);

    return axiosError;
  };

  // eslint-disable-next-line strict
  var httpAdapter = null;

  /**
   * Determines if the given thing is a array or js object.
   *
   * @param {string} thing - The object or array to be visited.
   *
   * @returns {boolean}
   */
  function isVisitable(thing) {
    return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
  }

  /**
   * It removes the brackets from the end of a string
   *
   * @param {string} key - The key of the parameter.
   *
   * @returns {string} the key without the brackets.
   */
  function removeBrackets(key) {
    return utils$2.endsWith(key, '[]') ? key.slice(0, -2) : key;
  }

  /**
   * It takes a path, a key, and a boolean, and returns a string
   *
   * @param {string} path - The path to the current key.
   * @param {string} key - The key of the current object being iterated over.
   * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
   *
   * @returns {string} The path to the current key.
   */
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      // eslint-disable-next-line no-param-reassign
      token = removeBrackets(token);
      return !dots && i ? '[' + token + ']' : token;
    }).join(dots ? '.' : '');
  }

  /**
   * If the array is an array and none of its elements are visitable, then it's a flat array.
   *
   * @param {Array<any>} arr - The array to check
   *
   * @returns {boolean}
   */
  function isFlatArray(arr) {
    return utils$2.isArray(arr) && !arr.some(isVisitable);
  }

  const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });

  /**
   * Convert a data object to FormData
   *
   * @param {Object} obj
   * @param {?Object} [formData]
   * @param {?Object} [options]
   * @param {Function} [options.visitor]
   * @param {Boolean} [options.metaTokens = true]
   * @param {Boolean} [options.dots = false]
   * @param {?Boolean} [options.indexes = false]
   *
   * @returns {Object}
   **/

  /**
   * It converts an object into a FormData object
   *
   * @param {Object<any, any>} obj - The object to convert to form data.
   * @param {string} formData - The FormData object to append to.
   * @param {Object<string, any>} options
   *
   * @returns
   */
  function toFormData(obj, formData, options) {
    if (!utils$2.isObject(obj)) {
      throw new TypeError('target must be an object');
    }

    // eslint-disable-next-line no-param-reassign
    formData = formData || new (FormData)();

    // eslint-disable-next-line no-param-reassign
    options = utils$2.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      // eslint-disable-next-line no-eq-null,eqeqeq
      return !utils$2.isUndefined(source[option]);
    });

    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
    const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);

    if (!utils$2.isFunction(visitor)) {
      throw new TypeError('visitor must be a function');
    }

    function convertValue(value) {
      if (value === null) return '';

      if (utils$2.isDate(value)) {
        return value.toISOString();
      }

      if (!useBlob && utils$2.isBlob(value)) {
        throw new AxiosError('Blob is not supported. Use a Buffer instead.');
      }

      if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
        return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
      }

      return value;
    }

    /**
     * Default visitor.
     *
     * @param {*} value
     * @param {String|Number} key
     * @param {Array<String|Number>} path
     * @this {FormData}
     *
     * @returns {boolean} return true to visit the each prop of the value recursively
     */
    function defaultVisitor(value, key, path) {
      let arr = value;

      if (value && !path && typeof value === 'object') {
        if (utils$2.endsWith(key, '{}')) {
          // eslint-disable-next-line no-param-reassign
          key = metaTokens ? key : key.slice(0, -2);
          // eslint-disable-next-line no-param-reassign
          value = JSON.stringify(value);
        } else if (
          (utils$2.isArray(value) && isFlatArray(value)) ||
          ((utils$2.isFileList(value) || utils$2.endsWith(key, '[]')) && (arr = utils$2.toArray(value))
          )) {
          // eslint-disable-next-line no-param-reassign
          key = removeBrackets(key);

          arr.forEach(function each(el, index) {
            !(utils$2.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
              convertValue(el)
            );
          });
          return false;
        }
      }

      if (isVisitable(value)) {
        return true;
      }

      formData.append(renderKey(path, key, dots), convertValue(value));

      return false;
    }

    const stack = [];

    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });

    function build(value, path) {
      if (utils$2.isUndefined(value)) return;

      if (stack.indexOf(value) !== -1) {
        throw Error('Circular reference detected in ' + path.join('.'));
      }

      stack.push(value);

      utils$2.forEach(value, function each(el, key) {
        const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(
          formData, el, utils$2.isString(key) ? key.trim() : key, path, exposedHelpers
        );

        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });

      stack.pop();
    }

    if (!utils$2.isObject(obj)) {
      throw new TypeError('data must be an object');
    }

    build(obj);

    return formData;
  }

  /**
   * It encodes a string by replacing all characters that are not in the unreserved set with
   * their percent-encoded equivalents
   *
   * @param {string} str - The string to encode.
   *
   * @returns {string} The encoded string.
   */
  function encode$3(str) {
    const charMap = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }

  /**
   * It takes a params object and converts it to a FormData object
   *
   * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
   * @param {Object<string, any>} options - The options object passed to the Axios constructor.
   *
   * @returns {void}
   */
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];

    params && toFormData(params, this, options);
  }

  const prototype = AxiosURLSearchParams.prototype;

  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };

  prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$3);
    } : encode$3;

    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + '=' + _encode(pair[1]);
    }, '').join('&');
  };

  /**
   * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
   * URI encoded counterparts
   *
   * @param {string} val The value to be encoded.
   *
   * @returns {string} The encoded value.
   */
  function encode$2(val) {
    return encodeURIComponent(val).
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @param {?object} options
   *
   * @returns {string} The formatted url
   */
  function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }
    
    const _encode = options && options.encode || encode$2;

    const serializeFn = options && options.serialize;

    let serializedParams;

    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$2.isURLSearchParams(params) ?
        params.toString() :
        new AxiosURLSearchParams(params, options).toString(_encode);
    }

    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  }

  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }

    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$2.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }

  var InterceptorManager$1 = InterceptorManager;

  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };

  var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

  var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

  var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

  var platform$2 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
  };

  const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   *
   * @returns {boolean}
   */
  const hasStandardBrowserEnv = (
    (product) => {
      return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0
    })(typeof navigator !== 'undefined' && navigator.product);

  /**
   * Determine if we're running in a standard browser webWorker environment
   *
   * Although the `isStandardBrowserEnv` method indicates that
   * `allows axios to run in a web worker`, the WebWorker will still be
   * filtered out due to its judgment standard
   * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
   * This leads to a problem when axios post `FormData` in webWorker
   */
  const hasStandardBrowserWebWorkerEnv = (() => {
    return (
      typeof WorkerGlobalScope !== 'undefined' &&
      // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope &&
      typeof self.importScripts === 'function'
    );
  })();

  var utils$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv
  });

  var platform$1 = {
    ...utils$1,
    ...platform$2
  };

  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform$1.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform$1.isNode && utils$2.isBuffer(value)) {
          this.append(key, value.toString('base64'));
          return false;
        }

        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }

  /**
   * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
   *
   * @param {string} name - The name of the property to get.
   *
   * @returns An array of strings.
   */
  function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
      return match[0] === '[]' ? '' : match[1] || match[0];
    });
  }

  /**
   * Convert an array to an object.
   *
   * @param {Array<any>} arr - The array to convert to an object.
   *
   * @returns An object with the same keys and values as the array.
   */
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }

  /**
   * It takes a FormData object and returns a JavaScript object
   *
   * @param {string} formData The FormData object to convert to JSON.
   *
   * @returns {Object<string, any> | null} The converted object.
   */
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];

      if (name === '__proto__') return true;

      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$2.isArray(target) ? target.length : name;

      if (isLast) {
        if (utils$2.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }

        return !isNumericKey;
      }

      if (!target[name] || !utils$2.isObject(target[name])) {
        target[name] = [];
      }

      const result = buildPath(path, value, target[name], index);

      if (result && utils$2.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }

      return !isNumericKey;
    }

    if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
      const obj = {};

      utils$2.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });

      return obj;
    }

    return null;
  }

  /**
   * It takes a string, tries to parse it, and if it fails, it returns the stringified version
   * of the input
   *
   * @param {any} rawValue - The value to be stringified.
   * @param {Function} parser - A function that parses a string into a JavaScript object.
   * @param {Function} encoder - A function that takes a value and returns a string.
   *
   * @returns {string} A stringified version of the rawValue.
   */
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$2.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$2.trim(rawValue);
      } catch (e) {
        if (e.name !== 'SyntaxError') {
          throw e;
        }
      }
    }

    return (encoder || JSON.stringify)(rawValue);
  }

  const defaults = {

    transitional: transitionalDefaults,

    adapter: ['xhr', 'http'],

    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || '';
      const hasJSONContentType = contentType.indexOf('application/json') > -1;
      const isObjectPayload = utils$2.isObject(data);

      if (isObjectPayload && utils$2.isHTMLForm(data)) {
        data = new FormData(data);
      }

      const isFormData = utils$2.isFormData(data);

      if (isFormData) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }

      if (utils$2.isArrayBuffer(data) ||
        utils$2.isBuffer(data) ||
        utils$2.isStream(data) ||
        utils$2.isFile(data) ||
        utils$2.isBlob(data)
      ) {
        return data;
      }
      if (utils$2.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$2.isURLSearchParams(data)) {
        headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
        return data.toString();
      }

      let isFileList;

      if (isObjectPayload) {
        if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }

        if ((isFileList = utils$2.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
          const _FormData = this.env && this.env.FormData;

          return toFormData(
            isFileList ? {'files[]': data} : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }

      if (isObjectPayload || hasJSONContentType ) {
        headers.setContentType('application/json', false);
        return stringifySafely(data);
      }

      return data;
    }],

    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === 'json';

      if (data && utils$2.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;

        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === 'SyntaxError') {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,
    maxBodyLength: -1,

    env: {
      FormData: platform$1.classes.FormData,
      Blob: platform$1.classes.Blob
    },

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },

    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*',
        'Content-Type': undefined
      }
    }
  };

  utils$2.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
    defaults.headers[method] = {};
  });

  var defaults$1 = defaults;

  // RawAxiosHeaders whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  const ignoreDuplicateOf = utils$2.toObjectSet([
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ]);

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} rawHeaders Headers needing to be parsed
   *
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = rawHeaders => {
    const parsed = {};
    let key;
    let val;
    let i;

    rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
      i = line.indexOf(':');
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();

      if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
        return;
      }

      if (key === 'set-cookie') {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    });

    return parsed;
  };

  const $internals = Symbol('internals');

  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }

  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }

    return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
  }

  function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;

    while ((match = tokensRE.exec(str))) {
      tokens[match[1]] = match[2];
    }

    return tokens;
  }

  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$2.isFunction(filter)) {
      return filter.call(this, value, header);
    }

    if (isHeaderNameFilter) {
      value = header;
    }

    if (!utils$2.isString(value)) return;

    if (utils$2.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }

    if (utils$2.isRegExp(filter)) {
      return filter.test(value);
    }
  }

  function formatHeader(header) {
    return header.trim()
      .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
  }

  function buildAccessors(obj, header) {
    const accessorName = utils$2.toCamelCase(' ' + header);

    ['get', 'set', 'has'].forEach(methodName => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }

  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }

    set(header, valueOrRewrite, rewrite) {
      const self = this;

      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);

        if (!lHeader) {
          throw new Error('header name must be a non-empty string');
        }

        const key = utils$2.findKey(self, lHeader);

        if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
          self[key || _header] = normalizeValue(_value);
        }
      }

      const setHeaders = (headers, _rewrite) =>
        utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

      if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if(utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }

      return this;
    }

    get(header, parser) {
      header = normalizeHeader(header);

      if (header) {
        const key = utils$2.findKey(this, header);

        if (key) {
          const value = this[key];

          if (!parser) {
            return value;
          }

          if (parser === true) {
            return parseTokens(value);
          }

          if (utils$2.isFunction(parser)) {
            return parser.call(this, value, key);
          }

          if (utils$2.isRegExp(parser)) {
            return parser.exec(value);
          }

          throw new TypeError('parser must be boolean|regexp|function');
        }
      }
    }

    has(header, matcher) {
      header = normalizeHeader(header);

      if (header) {
        const key = utils$2.findKey(this, header);

        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }

      return false;
    }

    delete(header, matcher) {
      const self = this;
      let deleted = false;

      function deleteHeader(_header) {
        _header = normalizeHeader(_header);

        if (_header) {
          const key = utils$2.findKey(self, _header);

          if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
            delete self[key];

            deleted = true;
          }
        }
      }

      if (utils$2.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }

      return deleted;
    }

    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;

      while (i--) {
        const key = keys[i];
        if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }

      return deleted;
    }

    normalize(format) {
      const self = this;
      const headers = {};

      utils$2.forEach(this, (value, header) => {
        const key = utils$2.findKey(headers, header);

        if (key) {
          self[key] = normalizeValue(value);
          delete self[header];
          return;
        }

        const normalized = format ? formatHeader(header) : String(header).trim();

        if (normalized !== header) {
          delete self[header];
        }

        self[normalized] = normalizeValue(value);

        headers[normalized] = true;
      });

      return this;
    }

    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }

    toJSON(asStrings) {
      const obj = Object.create(null);

      utils$2.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(', ') : value);
      });

      return obj;
    }

    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }

    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
    }

    get [Symbol.toStringTag]() {
      return 'AxiosHeaders';
    }

    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }

    static concat(first, ...targets) {
      const computed = new this(first);

      targets.forEach((target) => computed.set(target));

      return computed;
    }

    static accessor(header) {
      const internals = this[$internals] = (this[$internals] = {
        accessors: {}
      });

      const accessors = internals.accessors;
      const prototype = this.prototype;

      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);

        if (!accessors[lHeader]) {
          buildAccessors(prototype, _header);
          accessors[lHeader] = true;
        }
      }

      utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

      return this;
    }
  }

  AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

  // reserved names hotfix
  utils$2.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    }
  });

  utils$2.freezeMethods(AxiosHeaders);

  var AxiosHeaders$1 = AxiosHeaders;

  /**
   * Transform the data for a request or a response
   *
   * @param {Array|Function} fns A single function or Array of functions
   * @param {?Object} response The response object
   *
   * @returns {*} The resulting transformed data
   */
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;

    utils$2.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });

    headers.normalize();

    return data;
  }

  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  /**
   * A `CanceledError` is an object that is thrown when an operation is canceled.
   *
   * @param {string=} message The message.
   * @param {Object=} config The config.
   * @param {Object=} request The request.
   *
   * @returns {CanceledError} The created error.
   */
  function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
    this.name = 'CanceledError';
  }

  utils$2.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   *
   * @returns {object} The response.
   */
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        'Request failed with status code ' + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }

  var cookies = platform$1.hasStandardBrowserEnv ?

    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + '=' + encodeURIComponent(value)];

        utils$2.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

        utils$2.isString(path) && cookie.push('path=' + path);

        utils$2.isString(domain) && cookie.push('domain=' + domain);

        secure === true && cookie.push('secure');

        document.cookie = cookie.join('; ');
      },

      read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    }

    :

    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {},
      read() {
        return null;
      },
      remove() {}
    };

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   *
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   *
   * @returns {string} The combined URL
   */
  function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  }

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   *
   * @returns {string} The combined full path
   */
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  var isURLSameOrigin = platform$1.hasStandardBrowserEnv ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement('a');
      let originURL;

      /**
      * Parse a URL to discover its components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
      function resolveURL(url) {
        let href = url;

        if (msie) {
          // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
      return function isURLSameOrigin(requestURL) {
        const parsed = (utils$2.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })();

  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || '';
  }

  /**
   * Calculate data maxRate
   * @param {Number} [samplesCount= 10]
   * @param {Number} [min= 1000]
   * @returns {Function}
   */
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;

    min = min !== undefined ? min : 1000;

    return function push(chunkLength) {
      const now = Date.now();

      const startedAt = timestamps[tail];

      if (!firstSampleTS) {
        firstSampleTS = now;
      }

      bytes[head] = chunkLength;
      timestamps[head] = now;

      let i = tail;
      let bytesCount = 0;

      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }

      head = (head + 1) % samplesCount;

      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }

      if (now - firstSampleTS < min) {
        return;
      }

      const passed = startedAt && now - startedAt;

      return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
  }

  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);

    return e => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : undefined;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;

      bytesNotified = loaded;

      const data = {
        loaded,
        total,
        progress: total ? (loaded / total) : undefined,
        bytes: progressBytes,
        rate: rate ? rate : undefined,
        estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
        event: e
      };

      data[isDownloadStream ? 'download' : 'upload'] = true;

      listener(data);
    };
  }

  const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

  var xhrAdapter = isXHRAdapterSupported && function (config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      let requestData = config.data;
      const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
      let {responseType, withXSRFToken} = config;
      let onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }

        if (config.signal) {
          config.signal.removeEventListener('abort', onCanceled);
        }
      }

      let contentType;

      if (utils$2.isFormData(requestData)) {
        if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false); // Let the browser set it
        } else if ((contentType = requestHeaders.getContentType()) !== false) {
          // fix semicolon duplication issue for ReactNative FormData implementation
          const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
          requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
        }
      }

      let request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        const username = config.auth.username || '';
        const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
        requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
      }

      const fullPath = buildFullPath(config.baseURL, config.url);

      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      function onloadend() {
        if (!request) {
          return;
        }
        // Prepare the response
        const responseHeaders = AxiosHeaders$1.from(
          'getAllResponseHeaders' in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
          request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };

        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);

        // Clean up request
        request = null;
      }

      if ('onloadend' in request) {
        // Use onloadend if available
        request.onloadend = onloadend;
      } else {
        // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }
          // readystate handler is calling before onerror or ontimeout handlers,
          // so we should call onloadend on the next 'tick'
          setTimeout(onloadend);
        };
      }

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if(platform$1.hasStandardBrowserEnv) {
        withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));

        if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
          // Add xsrf header
          const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
      }

      // Remove Content-Type if data is undefined
      requestData === undefined && requestHeaders.setContentType(null);

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }

      // Add withCredentials to request if needed
      if (!utils$2.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }

      // Add responseType to request if needed
      if (responseType && responseType !== 'json') {
        request.responseType = config.responseType;
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
      }

      if (config.cancelToken || config.signal) {
        // Handle cancellation
        // eslint-disable-next-line func-names
        onCanceled = cancel => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };

        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
        }
      }

      const protocol = parseProtocol(fullPath);

      if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
        return;
      }


      // Send the request
      request.send(requestData || null);
    });
  };

  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
  };

  utils$2.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, 'name', {value});
      } catch (e) {
        // eslint-disable-next-line no-empty
      }
      Object.defineProperty(fn, 'adapterName', {value});
    }
  });

  const renderReason = (reason) => `- ${reason}`;

  const isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;

  var adapters = {
    getAdapter: (adapters) => {
      adapters = utils$2.isArray(adapters) ? adapters : [adapters];

      const {length} = adapters;
      let nameOrAdapter;
      let adapter;

      const rejectedReasons = {};

      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters[i];
        let id;

        adapter = nameOrAdapter;

        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

          if (adapter === undefined) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }

        if (adapter) {
          break;
        }

        rejectedReasons[id || '#' + i] = adapter;
      }

      if (!adapter) {

        const reasons = Object.entries(rejectedReasons)
          .map(([id, state]) => `adapter ${id} ` +
            (state === false ? 'is not supported by the environment' : 'is not available in the build')
          );

        let s = length ?
          (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
          'as no adapter specified';

        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          'ERR_NOT_SUPPORT'
        );
      }

      return adapter;
    },
    adapters: knownAdapters
  };

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   *
   * @param {Object} config The config that is to be used for the request
   *
   * @returns {void}
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }

    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    config.headers = AxiosHeaders$1.from(config.headers);

    // Transform request data
    config.data = transformData.call(
      config,
      config.transformRequest
    );

    if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
      config.headers.setContentType('application/x-www-form-urlencoded', false);
    }

    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );

      response.headers = AxiosHeaders$1.from(response.headers);

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }

      return Promise.reject(reason);
    });
  }

  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   *
   * @returns {Object} New object resulting from merging config2 to config1
   */
  function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};

    function getMergedValue(target, source, caseless) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
        return utils$2.merge.call({caseless}, target, source);
      } else if (utils$2.isPlainObject(source)) {
        return utils$2.merge({}, source);
      } else if (utils$2.isArray(source)) {
        return source.slice();
      }
      return source;
    }

    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
      if (!utils$2.isUndefined(b)) {
        return getMergedValue(a, b, caseless);
      } else if (!utils$2.isUndefined(a)) {
        return getMergedValue(undefined, a, caseless);
      }
    }

    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
      if (!utils$2.isUndefined(b)) {
        return getMergedValue(undefined, b);
      }
    }

    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
      if (!utils$2.isUndefined(b)) {
        return getMergedValue(undefined, b);
      } else if (!utils$2.isUndefined(a)) {
        return getMergedValue(undefined, a);
      }
    }

    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(undefined, a);
      }
    }

    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };

    utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge(config1[prop], config2[prop], prop);
      (utils$2.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
    });

    return config;
  }

  const VERSION = "1.6.5";

  const validators$1 = {};

  // eslint-disable-next-line func-names
  ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
    validators$1[type] = function validator(thing) {
      return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
  });

  const deprecatedWarnings = {};

  /**
   * Transitional option validator
   *
   * @param {function|boolean?} validator - set to false if the transitional option has been removed
   * @param {string?} version - deprecated version / removed since version
   * @param {string?} message - some message with additional info
   *
   * @returns {function}
   */
  validators$1.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
      return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    }

    // eslint-disable-next-line func-names
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError(
          formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
          AxiosError.ERR_DEPRECATED
        );
      }

      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        // eslint-disable-next-line no-console
        console.warn(
          formatMessage(
            opt,
            ' has been deprecated since v' + version + ' and will be removed in the near future'
          )
        );
      }

      return validator ? validator(value, opt, opts) : true;
    };
  };

  /**
   * Assert object's properties type
   *
   * @param {object} options
   * @param {object} schema
   * @param {boolean?} allowUnknown
   *
   * @returns {object}
   */

  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== 'object') {
      throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === undefined || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }

  var validator = {
    assertOptions,
    validators: validators$1
  };

  const validators = validator.validators;

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   *
   * @return {Axios} A new instance of Axios
   */
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof configOrUrl === 'string') {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }

      config = mergeConfig(this.defaults, config);

      const {transitional, paramsSerializer, headers} = config;

      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }

      if (paramsSerializer != null) {
        if (utils$2.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }

      // Set config.method
      config.method = (config.method || this.defaults.method || 'get').toLowerCase();

      // Flatten headers
      let contextHeaders = headers && utils$2.merge(
        headers.common,
        headers[config.method]
      );

      headers && utils$2.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        (method) => {
          delete headers[method];
        }
      );

      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

      // filter out skipped interceptors
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }

        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });

      let promise;
      let i = 0;
      let len;

      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), undefined];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;

        promise = Promise.resolve(config);

        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }

        return promise;
      }

      len = requestInterceptorChain.length;

      let newConfig = config;

      i = 0;

      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }

      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      i = 0;
      len = responseInterceptorChain.length;

      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }

      return promise;
    }

    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }

  // Provide aliases for supported request methods
  utils$2.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });

  utils$2.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/

    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            'Content-Type': 'multipart/form-data'
          } : {},
          url,
          data
        }));
      };
    }

    Axios.prototype[method] = generateHTTPMethod();

    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
  });

  var Axios$1 = Axios;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @param {Function} executor The executor function.
   *
   * @returns {CancelToken}
   */
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      let resolvePromise;

      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      const token = this;

      // eslint-disable-next-line func-names
      this.promise.then(cancel => {
        if (!token._listeners) return;

        let i = token._listeners.length;

        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });

      // eslint-disable-next-line func-names
      this.promise.then = onfulfilled => {
        let _resolve;
        // eslint-disable-next-line func-names
        const promise = new Promise(resolve => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);

        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };

        return promise;
      };

      executor(function cancel(message, config, request) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }

    /**
     * Subscribe to the cancel signal
     */

    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }

      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }

    /**
     * Unsubscribe from the cancel signal
     */

    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }

  var CancelToken$1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   *
   * @returns {Function}
   */
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  /**
   * Determines whether the payload is an error thrown by Axios
   *
   * @param {*} payload The value to test
   *
   * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
   */
  function isAxiosError(payload) {
    return utils$2.isObject(payload) && (payload.isAxiosError === true);
  }

  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  };

  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });

  var HttpStatusCode$1 = HttpStatusCode;

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   *
   * @returns {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind$1(Axios$1.prototype.request, context);

    // Copy axios.prototype to instance
    utils$2.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

    // Copy context to instance
    utils$2.extend(instance, context, null, {allOwnKeys: true});

    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };

    return instance;
  }

  // Create the default instance to be exported
  const axios = createInstance(defaults$1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios$1;

  // Expose Cancel & CancelToken
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;

  // Expose AxiosError class
  axios.AxiosError = AxiosError;

  // alias for CanceledError for backward compatibility
  axios.Cancel = axios.CanceledError;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };

  axios.spread = spread;

  // Expose isAxiosError
  axios.isAxiosError = isAxiosError;

  // Expose mergeConfig
  axios.mergeConfig = mergeConfig;

  axios.AxiosHeaders = AxiosHeaders$1;

  axios.formToJSON = thing => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);

  axios.getAdapter = adapters.getAdapter;

  axios.HttpStatusCode = HttpStatusCode$1;

  axios.default = axios;

  // this module should only have a default export
  var axios$1 = axios;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			if (this instanceof a) {
          return Reflect.construct(f, arguments, this.constructor);
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var isURL$1 = {exports: {}};

  var assertString = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = assertString;

  	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  	function assertString(input) {
  	  var isString = typeof input === 'string' || input instanceof String;

  	  if (!isString) {
  	    var invalidType = _typeof(input);

  	    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;
  	    throw new TypeError("Expected a string but received a ".concat(invalidType));
  	  }
  	}

  	module.exports = exports.default;
  	module.exports.default = exports.default; 
  } (assertString, assertString.exports));

  var assertStringExports = assertString.exports;

  var isFQDN$1 = {exports: {}};

  var merge$1 = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = merge;

  	function merge() {
  	  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	  var defaults = arguments.length > 1 ? arguments[1] : undefined;

  	  for (var key in defaults) {
  	    if (typeof obj[key] === 'undefined') {
  	      obj[key] = defaults[key];
  	    }
  	  }

  	  return obj;
  	}

  	module.exports = exports.default;
  	module.exports.default = exports.default; 
  } (merge$1, merge$1.exports));

  var mergeExports = merge$1.exports;

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = isFQDN;

  	var _assertString = _interopRequireDefault(assertStringExports);

  	var _merge = _interopRequireDefault(mergeExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	var default_fqdn_options = {
  	  require_tld: true,
  	  allow_underscores: false,
  	  allow_trailing_dot: false,
  	  allow_numeric_tld: false,
  	  allow_wildcard: false,
  	  ignore_max_length: false
  	};

  	function isFQDN(str, options) {
  	  (0, _assertString.default)(str);
  	  options = (0, _merge.default)(options, default_fqdn_options);
  	  /* Remove the optional trailing dot before checking validity */

  	  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
  	    str = str.substring(0, str.length - 1);
  	  }
  	  /* Remove the optional wildcard before checking validity */


  	  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
  	    str = str.substring(2);
  	  }

  	  var parts = str.split('.');
  	  var tld = parts[parts.length - 1];

  	  if (options.require_tld) {
  	    // disallow fqdns without tld
  	    if (parts.length < 2) {
  	      return false;
  	    }

  	    if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
  	      return false;
  	    } // disallow spaces


  	    if (/\s/.test(tld)) {
  	      return false;
  	    }
  	  } // reject numeric TLDs


  	  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
  	    return false;
  	  }

  	  return parts.every(function (part) {
  	    if (part.length > 63 && !options.ignore_max_length) {
  	      return false;
  	    }

  	    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
  	      return false;
  	    } // disallow full-width chars


  	    if (/[\uff01-\uff5e]/.test(part)) {
  	      return false;
  	    } // disallow parts starting or ending with hyphen


  	    if (/^-|-$/.test(part)) {
  	      return false;
  	    }

  	    if (!options.allow_underscores && /_/.test(part)) {
  	      return false;
  	    }

  	    return true;
  	  });
  	}

  	module.exports = exports.default;
  	module.exports.default = exports.default; 
  } (isFQDN$1, isFQDN$1.exports));

  var isFQDNExports = isFQDN$1.exports;
  var isFQDN = /*@__PURE__*/getDefaultExportFromCjs(isFQDNExports);

  var isIP = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = isIP;

  	var _assertString = _interopRequireDefault(assertStringExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	/**
  	11.3.  Examples

  	   The following addresses

  	             fe80::1234 (on the 1st link of the node)
  	             ff02::5678 (on the 5th link of the node)
  	             ff08::9abc (on the 10th organization of the node)

  	   would be represented as follows:

  	             fe80::1234%1
  	             ff02::5678%5
  	             ff08::9abc%10

  	   (Here we assume a natural translation from a zone index to the
  	   <zone_id> part, where the Nth zone of any scope is translated into
  	   "N".)

  	   If we use interface names as <zone_id>, those addresses could also be
  	   represented as follows:

  	            fe80::1234%ne0
  	            ff02::5678%pvc1.3
  	            ff08::9abc%interface10

  	   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
  	   to the 5th link, and "interface10" belongs to the 10th organization.
  	 * * */
  	var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
  	var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  	var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  	var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
  	var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z-.:]{1,})?$');

  	function isIP(str) {
  	  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  	  (0, _assertString.default)(str);
  	  version = String(version);

  	  if (!version) {
  	    return isIP(str, 4) || isIP(str, 6);
  	  }

  	  if (version === '4') {
  	    return IPv4AddressRegExp.test(str);
  	  }

  	  if (version === '6') {
  	    return IPv6AddressRegExp.test(str);
  	  }

  	  return false;
  	}

  	module.exports = exports.default;
  	module.exports.default = exports.default; 
  } (isIP, isIP.exports));

  var isIPExports = isIP.exports;

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = isURL;

  	var _assertString = _interopRequireDefault(assertStringExports);

  	var _isFQDN = _interopRequireDefault(isFQDNExports);

  	var _isIP = _interopRequireDefault(isIPExports);

  	var _merge = _interopRequireDefault(mergeExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  	function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  	/*
  	options for isURL method

  	require_protocol - if set as true isURL will return false if protocol is not present in the URL
  	require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
  	protocols - valid protocols can be modified with this option
  	require_host - if set as false isURL will not check if host is present in the URL
  	require_port - if set as true isURL will check if port is present in the URL
  	allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
  	validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)

  	*/
  	var default_url_options = {
  	  protocols: ['http', 'https', 'ftp'],
  	  require_tld: true,
  	  require_protocol: false,
  	  require_host: true,
  	  require_port: false,
  	  require_valid_protocol: true,
  	  allow_underscores: false,
  	  allow_trailing_dot: false,
  	  allow_protocol_relative_urls: false,
  	  allow_fragments: true,
  	  allow_query_components: true,
  	  validate_length: true
  	};
  	var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

  	function isRegExp(obj) {
  	  return Object.prototype.toString.call(obj) === '[object RegExp]';
  	}

  	function checkHost(host, matches) {
  	  for (var i = 0; i < matches.length; i++) {
  	    var match = matches[i];

  	    if (host === match || isRegExp(match) && match.test(host)) {
  	      return true;
  	    }
  	  }

  	  return false;
  	}

  	function isURL(url, options) {
  	  (0, _assertString.default)(url);

  	  if (!url || /[\s<>]/.test(url)) {
  	    return false;
  	  }

  	  if (url.indexOf('mailto:') === 0) {
  	    return false;
  	  }

  	  options = (0, _merge.default)(options, default_url_options);

  	  if (options.validate_length && url.length >= 2083) {
  	    return false;
  	  }

  	  if (!options.allow_fragments && url.includes('#')) {
  	    return false;
  	  }

  	  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {
  	    return false;
  	  }

  	  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  	  split = url.split('#');
  	  url = split.shift();
  	  split = url.split('?');
  	  url = split.shift();
  	  split = url.split('://');

  	  if (split.length > 1) {
  	    protocol = split.shift().toLowerCase();

  	    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
  	      return false;
  	    }
  	  } else if (options.require_protocol) {
  	    return false;
  	  } else if (url.slice(0, 2) === '//') {
  	    if (!options.allow_protocol_relative_urls) {
  	      return false;
  	    }

  	    split[0] = url.slice(2);
  	  }

  	  url = split.join('://');

  	  if (url === '') {
  	    return false;
  	  }

  	  split = url.split('/');
  	  url = split.shift();

  	  if (url === '' && !options.require_host) {
  	    return true;
  	  }

  	  split = url.split('@');

  	  if (split.length > 1) {
  	    if (options.disallow_auth) {
  	      return false;
  	    }

  	    if (split[0] === '') {
  	      return false;
  	    }

  	    auth = split.shift();

  	    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
  	      return false;
  	    }

  	    var _auth$split = auth.split(':'),
  	        _auth$split2 = _slicedToArray(_auth$split, 2),
  	        user = _auth$split2[0],
  	        password = _auth$split2[1];

  	    if (user === '' && password === '') {
  	      return false;
  	    }
  	  }

  	  hostname = split.join('@');
  	  port_str = null;
  	  ipv6 = null;
  	  var ipv6_match = hostname.match(wrapped_ipv6);

  	  if (ipv6_match) {
  	    host = '';
  	    ipv6 = ipv6_match[1];
  	    port_str = ipv6_match[2] || null;
  	  } else {
  	    split = hostname.split(':');
  	    host = split.shift();

  	    if (split.length) {
  	      port_str = split.join(':');
  	    }
  	  }

  	  if (port_str !== null && port_str.length > 0) {
  	    port = parseInt(port_str, 10);

  	    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
  	      return false;
  	    }
  	  } else if (options.require_port) {
  	    return false;
  	  }

  	  if (options.host_whitelist) {
  	    return checkHost(host, options.host_whitelist);
  	  }

  	  if (host === '' && !options.require_host) {
  	    return true;
  	  }

  	  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
  	    return false;
  	  }

  	  host = host || ipv6;

  	  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
  	    return false;
  	  }

  	  return true;
  	}

  	module.exports = exports.default;
  	module.exports.default = exports.default; 
  } (isURL$1, isURL$1.exports));

  var isURLExports = isURL$1.exports;
  var isURL = /*@__PURE__*/getDefaultExportFromCjs(isURLExports);

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser$2 = true;
  var env = {};
  var argv = [];
  var version$1 = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on$1 = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser$2,
    env: env,
    argv: argv,
    version: version$1,
    versions: versions,
    on: on$1,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var lib$2 = {};

  Object.defineProperty(lib$2, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /* global window self */

  var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

  /* eslint-disable no-restricted-globals */
  var isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';
  /* eslint-enable no-restricted-globals */

  var isNode = typeof browser$1$1 !== 'undefined' && browser$1$1.versions != null && browser$1$1.versions.node != null;

  /**
   * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0
   * @see https://github.com/jsdom/jsdom/issues/1537
   */
  /* eslint-disable no-undef */
  var isJsDom = function isJsDom() {
    return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');
  };

  var isBrowser_1 = lib$2.isBrowser = isBrowser;
  lib$2.isWebWorker = isWebWorker;
  var isNode_1 = lib$2.isNode = isNode;
  lib$2.isJsDom = isJsDom;

  var crypto$2 = {};

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Contains constant values
   * @module constants
   */

  /**
   * doip.js library version
   * @constant {string}
   */
  const version = '1.2.9';

  /*
  Copyright 2022 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using ActivityPub HTTP requests
   * @module fetcher/activitypub
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.activitypub.fn({ url: 'https://domain.example/@alice' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$b = 5000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.url - The URL of the account to verify
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object>} The fetched ActivityPub object
   */
  async function fn$a (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$b
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      (async () => {
        let isConfigured = false;
        try {
          isURL(opts.claims.activitypub.url);
          isConfigured = true;
        } catch (_) {}

        const now = new Date();
        const { host, pathname, search } = new URL(data.url);

        const headers = {
          host,
          date: now.toUTCString(),
          accept: 'application/activity+json',
          // @ts-ignore
          'User-Agent': `doipjs/${version}`
        };

        if (isConfigured && isNode_1) {
          // Generate the signature
          const signedString = `(request-target): get ${pathname}${search}\nhost: ${host}\ndate: ${now.toUTCString()}`;
          const sign = crypto$2.createSign('SHA256');
          sign.write(signedString);
          sign.end();
          const signatureSig = sign.sign(opts.claims.activitypub.privateKey.replace(/\\n/g, '\n'), 'base64');
          headers.signature = `keyId="${opts.claims.activitypub.url}#main-key",headers="(request-target) host date",signature="${signatureSig}",algorithm="rsa-sha256"`;
        }

        axios$1.get(data.url,
          {
            headers
          })
          .then(res => {
            return res.data
          })
          .then(res => {
            resolve(res);
          })
          .catch(error => {
            reject(error);
          });
      })();
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var activitypub$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$a,
    timeout: timeout$b
  });

  var crypto$1 = crypto;
  const isCryptoKey = (key) => key instanceof CryptoKey;

  const digest = async (algorithm, data) => {
      const subtleDigest = `SHA-${algorithm.slice(-3)}`;
      return new Uint8Array(await crypto$1.subtle.digest(subtleDigest, data));
  };

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  function concat(...buffers) {
      const size = buffers.reduce((acc, { length }) => acc + length, 0);
      const buf = new Uint8Array(size);
      let i = 0;
      buffers.forEach((buffer) => {
          buf.set(buffer, i);
          i += buffer.length;
      });
      return buf;
  }

  const encodeBase64$1 = (input) => {
      let unencoded = input;
      if (typeof unencoded === 'string') {
          unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 0x8000;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
          arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(''));
  };
  const encode$1 = (input) => {
      return encodeBase64$1(input).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
  };
  const decodeBase64$1 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
  };
  const decode$2 = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
          encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
      try {
          return decodeBase64$1(encoded);
      }
      catch (_a) {
          throw new TypeError('The input to be decoded is not correctly encoded.');
      }
  };

  class JOSEError extends Error {
      static get code() {
          return 'ERR_JOSE_GENERIC';
      }
      constructor(message) {
          var _a;
          super(message);
          this.code = 'ERR_JOSE_GENERIC';
          this.name = this.constructor.name;
          (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
  }
  class JOSEAlgNotAllowed extends JOSEError {
      constructor() {
          super(...arguments);
          this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';
      }
      static get code() {
          return 'ERR_JOSE_ALG_NOT_ALLOWED';
      }
  }
  class JOSENotSupported extends JOSEError {
      constructor() {
          super(...arguments);
          this.code = 'ERR_JOSE_NOT_SUPPORTED';
      }
      static get code() {
          return 'ERR_JOSE_NOT_SUPPORTED';
      }
  }
  class JWSInvalid extends JOSEError {
      constructor() {
          super(...arguments);
          this.code = 'ERR_JWS_INVALID';
      }
      static get code() {
          return 'ERR_JWS_INVALID';
      }
  }
  class JWKInvalid extends JOSEError {
      constructor() {
          super(...arguments);
          this.code = 'ERR_JWK_INVALID';
      }
      static get code() {
          return 'ERR_JWK_INVALID';
      }
  }
  class JWSSignatureVerificationFailed extends JOSEError {
      constructor() {
          super(...arguments);
          this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
          this.message = 'signature verification failed';
      }
      static get code() {
          return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
      }
  }

  function unusable(name, prop = 'algorithm.name') {
      return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
  }
  function isAlgorithm(algorithm, name) {
      return algorithm.name === name;
  }
  function getHashLength(hash) {
      return parseInt(hash.name.slice(4), 10);
  }
  function getNamedCurve(alg) {
      switch (alg) {
          case 'ES256':
              return 'P-256';
          case 'ES384':
              return 'P-384';
          case 'ES512':
              return 'P-521';
          default:
              throw new Error('unreachable');
      }
  }
  function checkUsage(key, usages) {
      if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
          let msg = 'CryptoKey does not support this operation, its usages must include ';
          if (usages.length > 2) {
              const last = usages.pop();
              msg += `one of ${usages.join(', ')}, or ${last}.`;
          }
          else if (usages.length === 2) {
              msg += `one of ${usages[0]} or ${usages[1]}.`;
          }
          else {
              msg += `${usages[0]}.`;
          }
          throw new TypeError(msg);
      }
  }
  function checkSigCryptoKey(key, alg, ...usages) {
      switch (alg) {
          case 'HS256':
          case 'HS384':
          case 'HS512': {
              if (!isAlgorithm(key.algorithm, 'HMAC'))
                  throw unusable('HMAC');
              const expected = parseInt(alg.slice(2), 10);
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                  throw unusable(`SHA-${expected}`, 'algorithm.hash');
              break;
          }
          case 'RS256':
          case 'RS384':
          case 'RS512': {
              if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
                  throw unusable('RSASSA-PKCS1-v1_5');
              const expected = parseInt(alg.slice(2), 10);
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                  throw unusable(`SHA-${expected}`, 'algorithm.hash');
              break;
          }
          case 'PS256':
          case 'PS384':
          case 'PS512': {
              if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
                  throw unusable('RSA-PSS');
              const expected = parseInt(alg.slice(2), 10);
              const actual = getHashLength(key.algorithm.hash);
              if (actual !== expected)
                  throw unusable(`SHA-${expected}`, 'algorithm.hash');
              break;
          }
          case 'EdDSA': {
              if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {
                  throw unusable('Ed25519 or Ed448');
              }
              break;
          }
          case 'ES256':
          case 'ES384':
          case 'ES512': {
              if (!isAlgorithm(key.algorithm, 'ECDSA'))
                  throw unusable('ECDSA');
              const expected = getNamedCurve(alg);
              const actual = key.algorithm.namedCurve;
              if (actual !== expected)
                  throw unusable(expected, 'algorithm.namedCurve');
              break;
          }
          default:
              throw new TypeError('CryptoKey does not support this operation');
      }
      checkUsage(key, usages);
  }

  function message(msg, actual, ...types) {
      if (types.length > 2) {
          const last = types.pop();
          msg += `one of type ${types.join(', ')}, or ${last}.`;
      }
      else if (types.length === 2) {
          msg += `one of type ${types[0]} or ${types[1]}.`;
      }
      else {
          msg += `of type ${types[0]}.`;
      }
      if (actual == null) {
          msg += ` Received ${actual}`;
      }
      else if (typeof actual === 'function' && actual.name) {
          msg += ` Received function ${actual.name}`;
      }
      else if (typeof actual === 'object' && actual != null) {
          if (actual.constructor && actual.constructor.name) {
              msg += ` Received an instance of ${actual.constructor.name}`;
          }
      }
      return msg;
  }
  var invalidKeyInput = (actual, ...types) => {
      return message('Key must be ', actual, ...types);
  };
  function withAlg(alg, actual, ...types) {
      return message(`Key for the ${alg} algorithm must be `, actual, ...types);
  }

  var isKeyLike = (key) => {
      return isCryptoKey(key);
  };
  const types = ['CryptoKey'];

  const isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
          return true;
      }
      let acc;
      for (const header of sources) {
          const parameters = Object.keys(header);
          if (!acc || acc.size === 0) {
              acc = new Set(parameters);
              continue;
          }
          for (const parameter of parameters) {
              if (acc.has(parameter)) {
                  return false;
              }
              acc.add(parameter);
          }
      }
      return true;
  };

  function isObjectLike(value) {
      return typeof value === 'object' && value !== null;
  }
  function isObject$1(input) {
      if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
          return false;
      }
      if (Object.getPrototypeOf(input) === null) {
          return true;
      }
      let proto = input;
      while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(input) === proto;
  }

  var checkKeyLength = (alg, key) => {
      if (alg.startsWith('RS') || alg.startsWith('PS')) {
          const { modulusLength } = key.algorithm;
          if (typeof modulusLength !== 'number' || modulusLength < 2048) {
              throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
          }
      }
  };

  function subtleMapping(jwk) {
      let algorithm;
      let keyUsages;
      switch (jwk.kty) {
          case 'oct': {
              switch (jwk.alg) {
                  case 'HS256':
                  case 'HS384':
                  case 'HS512':
                      algorithm = { name: 'HMAC', hash: `SHA-${jwk.alg.slice(-3)}` };
                      keyUsages = ['sign', 'verify'];
                      break;
                  case 'A128CBC-HS256':
                  case 'A192CBC-HS384':
                  case 'A256CBC-HS512':
                      throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
                  case 'A128GCM':
                  case 'A192GCM':
                  case 'A256GCM':
                  case 'A128GCMKW':
                  case 'A192GCMKW':
                  case 'A256GCMKW':
                      algorithm = { name: 'AES-GCM' };
                      keyUsages = ['encrypt', 'decrypt'];
                      break;
                  case 'A128KW':
                  case 'A192KW':
                  case 'A256KW':
                      algorithm = { name: 'AES-KW' };
                      keyUsages = ['wrapKey', 'unwrapKey'];
                      break;
                  case 'PBES2-HS256+A128KW':
                  case 'PBES2-HS384+A192KW':
                  case 'PBES2-HS512+A256KW':
                      algorithm = { name: 'PBKDF2' };
                      keyUsages = ['deriveBits'];
                      break;
                  default:
                      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
              }
              break;
          }
          case 'RSA': {
              switch (jwk.alg) {
                  case 'PS256':
                  case 'PS384':
                  case 'PS512':
                      algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };
                      keyUsages = jwk.d ? ['sign'] : ['verify'];
                      break;
                  case 'RS256':
                  case 'RS384':
                  case 'RS512':
                      algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };
                      keyUsages = jwk.d ? ['sign'] : ['verify'];
                      break;
                  case 'RSA-OAEP':
                  case 'RSA-OAEP-256':
                  case 'RSA-OAEP-384':
                  case 'RSA-OAEP-512':
                      algorithm = {
                          name: 'RSA-OAEP',
                          hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,
                      };
                      keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];
                      break;
                  default:
                      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
              }
              break;
          }
          case 'EC': {
              switch (jwk.alg) {
                  case 'ES256':
                      algorithm = { name: 'ECDSA', namedCurve: 'P-256' };
                      keyUsages = jwk.d ? ['sign'] : ['verify'];
                      break;
                  case 'ES384':
                      algorithm = { name: 'ECDSA', namedCurve: 'P-384' };
                      keyUsages = jwk.d ? ['sign'] : ['verify'];
                      break;
                  case 'ES512':
                      algorithm = { name: 'ECDSA', namedCurve: 'P-521' };
                      keyUsages = jwk.d ? ['sign'] : ['verify'];
                      break;
                  case 'ECDH-ES':
                  case 'ECDH-ES+A128KW':
                  case 'ECDH-ES+A192KW':
                  case 'ECDH-ES+A256KW':
                      algorithm = { name: 'ECDH', namedCurve: jwk.crv };
                      keyUsages = jwk.d ? ['deriveBits'] : [];
                      break;
                  default:
                      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
              }
              break;
          }
          case 'OKP': {
              switch (jwk.alg) {
                  case 'EdDSA':
                      algorithm = { name: jwk.crv };
                      keyUsages = jwk.d ? ['sign'] : ['verify'];
                      break;
                  case 'ECDH-ES':
                  case 'ECDH-ES+A128KW':
                  case 'ECDH-ES+A192KW':
                  case 'ECDH-ES+A256KW':
                      algorithm = { name: jwk.crv };
                      keyUsages = jwk.d ? ['deriveBits'] : [];
                      break;
                  default:
                      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
              }
              break;
          }
          default:
              throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
      }
      return { algorithm, keyUsages };
  }
  const parse$5 = async (jwk) => {
      var _a, _b;
      if (!jwk.alg) {
          throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
          algorithm,
          (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
          (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages,
      ];
      if (algorithm.name === 'PBKDF2') {
          return crypto$1.subtle.importKey('raw', decode$2(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return crypto$1.subtle.importKey('jwk', keyData, ...rest);
  };
  var asKeyObject = parse$5;

  async function importJWK(jwk, alg, octAsKeyObject) {
      var _a;
      if (!isObject$1(jwk)) {
          throw new TypeError('JWK must be an object');
      }
      alg || (alg = jwk.alg);
      switch (jwk.kty) {
          case 'oct':
              if (typeof jwk.k !== 'string' || !jwk.k) {
                  throw new TypeError('missing "k" (Key Value) Parameter value');
              }
              octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);
              if (octAsKeyObject) {
                  return asKeyObject({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
              }
              return decode$2(jwk.k);
          case 'RSA':
              if (jwk.oth !== undefined) {
                  throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
              }
          case 'EC':
          case 'OKP':
              return asKeyObject({ ...jwk, alg });
          default:
              throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
      }
  }

  const symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
          return;
      if (!isKeyLike(key)) {
          throw new TypeError(withAlg(alg, key, ...types, 'Uint8Array'));
      }
      if (key.type !== 'secret') {
          throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
      }
  };
  const asymmetricTypeCheck = (alg, key, usage) => {
      if (!isKeyLike(key)) {
          throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === 'secret') {
          throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === 'sign' && key.type === 'public') {
          throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === 'decrypt' && key.type === 'public') {
          throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === 'verify' && key.type === 'private') {
          throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
          throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
      }
  };
  const checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith('HS') ||
          alg === 'dir' ||
          alg.startsWith('PBES2') ||
          /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
          symmetricTypeCheck(alg, key);
      }
      else {
          asymmetricTypeCheck(alg, key, usage);
      }
  };

  function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
      if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
          throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
      }
      if (!protectedHeader || protectedHeader.crit === undefined) {
          return new Set();
      }
      if (!Array.isArray(protectedHeader.crit) ||
          protectedHeader.crit.length === 0 ||
          protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
          throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
      }
      let recognized;
      if (recognizedOption !== undefined) {
          recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
      }
      else {
          recognized = recognizedDefault;
      }
      for (const parameter of protectedHeader.crit) {
          if (!recognized.has(parameter)) {
              throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
          }
          if (joseHeader[parameter] === undefined) {
              throw new Err(`Extension Header Parameter "${parameter}" is missing`);
          }
          else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
              throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
          }
      }
      return new Set(protectedHeader.crit);
  }

  const validateAlgorithms = (option, algorithms) => {
      if (algorithms !== undefined &&
          (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
          throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
          return undefined;
      }
      return new Set(algorithms);
  };

  function subtleDsa(alg, algorithm) {
      const hash = `SHA-${alg.slice(-3)}`;
      switch (alg) {
          case 'HS256':
          case 'HS384':
          case 'HS512':
              return { hash, name: 'HMAC' };
          case 'PS256':
          case 'PS384':
          case 'PS512':
              return { hash, name: 'RSA-PSS', saltLength: alg.slice(-3) >> 3 };
          case 'RS256':
          case 'RS384':
          case 'RS512':
              return { hash, name: 'RSASSA-PKCS1-v1_5' };
          case 'ES256':
          case 'ES384':
          case 'ES512':
              return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };
          case 'EdDSA':
              return { name: algorithm.name };
          default:
              throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
  }

  function getCryptoKey(alg, key, usage) {
      if (isCryptoKey(key)) {
          checkSigCryptoKey(key, alg, usage);
          return key;
      }
      if (key instanceof Uint8Array) {
          if (!alg.startsWith('HS')) {
              throw new TypeError(invalidKeyInput(key, ...types));
          }
          return crypto$1.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);
      }
      throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));
  }

  const verify = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey(alg, key, 'verify');
      checkKeyLength(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
          return await crypto$1.subtle.verify(algorithm, cryptoKey, signature, data);
      }
      catch (_a) {
          return false;
      }
  };

  async function flattenedVerify(jws, key, options) {
      var _a;
      if (!isObject$1(jws)) {
          throw new JWSInvalid('Flattened JWS must be an object');
      }
      if (jws.protected === undefined && jws.header === undefined) {
          throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
      }
      if (jws.protected !== undefined && typeof jws.protected !== 'string') {
          throw new JWSInvalid('JWS Protected Header incorrect type');
      }
      if (jws.payload === undefined) {
          throw new JWSInvalid('JWS Payload missing');
      }
      if (typeof jws.signature !== 'string') {
          throw new JWSInvalid('JWS Signature missing or incorrect type');
      }
      if (jws.header !== undefined && !isObject$1(jws.header)) {
          throw new JWSInvalid('JWS Unprotected Header incorrect type');
      }
      let parsedProt = {};
      if (jws.protected) {
          try {
              const protectedHeader = decode$2(jws.protected);
              parsedProt = JSON.parse(decoder.decode(protectedHeader));
          }
          catch (_b) {
              throw new JWSInvalid('JWS Protected Header is invalid');
          }
      }
      if (!isDisjoint(parsedProt, jws.header)) {
          throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
      }
      const joseHeader = {
          ...parsedProt,
          ...jws.header,
      };
      const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
      let b64 = true;
      if (extensions.has('b64')) {
          b64 = parsedProt.b64;
          if (typeof b64 !== 'boolean') {
              throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
      }
      const { alg } = joseHeader;
      if (typeof alg !== 'string' || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
      }
      const algorithms = options && validateAlgorithms('algorithms', options.algorithms);
      if (algorithms && !algorithms.has(alg)) {
          throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
      }
      if (b64) {
          if (typeof jws.payload !== 'string') {
              throw new JWSInvalid('JWS Payload must be a string');
          }
      }
      else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
          throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
      }
      let resolvedKey = false;
      if (typeof key === 'function') {
          key = await key(parsedProt, jws);
          resolvedKey = true;
      }
      checkKeyType(alg, key, 'verify');
      const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);
      let signature;
      try {
          signature = decode$2(jws.signature);
      }
      catch (_c) {
          throw new JWSInvalid('Failed to base64url decode the signature');
      }
      const verified = await verify(alg, key, signature, data);
      if (!verified) {
          throw new JWSSignatureVerificationFailed();
      }
      let payload;
      if (b64) {
          try {
              payload = decode$2(jws.payload);
          }
          catch (_d) {
              throw new JWSInvalid('Failed to base64url decode the payload');
          }
      }
      else if (typeof jws.payload === 'string') {
          payload = encoder.encode(jws.payload);
      }
      else {
          payload = jws.payload;
      }
      const result = { payload };
      if (jws.protected !== undefined) {
          result.protectedHeader = parsedProt;
      }
      if (jws.header !== undefined) {
          result.unprotectedHeader = jws.header;
      }
      if (resolvedKey) {
          return { ...result, key };
      }
      return result;
  }

  async function compactVerify(jws, key, options) {
      if (jws instanceof Uint8Array) {
          jws = decoder.decode(jws);
      }
      if (typeof jws !== 'string') {
          throw new JWSInvalid('Compact JWS must be a string or Uint8Array');
      }
      const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
      if (length !== 3) {
          throw new JWSInvalid('Invalid Compact JWS');
      }
      const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
      const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
      if (typeof key === 'function') {
          return { ...result, key: verified.key };
      }
      return result;
  }

  const check = (value, description) => {
      if (typeof value !== 'string' || !value) {
          throw new JWKInvalid(`${description} missing or invalid`);
      }
  };
  async function calculateJwkThumbprint(jwk, digestAlgorithm) {
      if (!isObject$1(jwk)) {
          throw new TypeError('JWK must be an object');
      }
      digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');
      if (digestAlgorithm !== 'sha256' &&
          digestAlgorithm !== 'sha384' &&
          digestAlgorithm !== 'sha512') {
          throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
      }
      let components;
      switch (jwk.kty) {
          case 'EC':
              check(jwk.crv, '"crv" (Curve) Parameter');
              check(jwk.x, '"x" (X Coordinate) Parameter');
              check(jwk.y, '"y" (Y Coordinate) Parameter');
              components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
              break;
          case 'OKP':
              check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
              check(jwk.x, '"x" (Public Key) Parameter');
              components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
              break;
          case 'RSA':
              check(jwk.e, '"e" (Exponent) Parameter');
              check(jwk.n, '"n" (Modulus) Parameter');
              components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
              break;
          case 'oct':
              check(jwk.k, '"k" (Key Value) Parameter');
              components = { k: jwk.k, kty: jwk.kty };
              break;
          default:
              throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
      }
      const data = encoder.encode(JSON.stringify(components));
      return encode$1(await digest(digestAlgorithm, data));
  }

  const decode$1 = decode$2;

  function decodeProtectedHeader(token) {
      let protectedB64u;
      if (typeof token === 'string') {
          const parts = token.split('.');
          if (parts.length === 3 || parts.length === 5) {
              [protectedB64u] = parts;
          }
      }
      else if (typeof token === 'object' && token) {
          if ('protected' in token) {
              protectedB64u = token.protected;
          }
          else {
              throw new TypeError('Token does not contain a Protected Header');
          }
      }
      try {
          if (typeof protectedB64u !== 'string' || !protectedB64u) {
              throw new Error();
          }
          const result = JSON.parse(decoder.decode(decode$1(protectedB64u)));
          if (!isObject$1(result)) {
              throw new Error();
          }
          return result;
      }
      catch (_a) {
          throw new TypeError('Invalid Token or Protected Header formatting');
      }
  }

  /* eslint-disable @typescript-eslint/strict-boolean-expressions */
  function parse$4(string, encoding, opts) {
    var _opts$out;

    if (opts === void 0) {
      opts = {};
    }

    // Build the character lookup table:
    if (!encoding.codes) {
      encoding.codes = {};

      for (var i = 0; i < encoding.chars.length; ++i) {
        encoding.codes[encoding.chars[i]] = i;
      }
    } // The string must have a whole number of bytes:


    if (!opts.loose && string.length * encoding.bits & 7) {
      throw new SyntaxError('Invalid padding');
    } // Count the padding bytes:


    var end = string.length;

    while (string[end - 1] === '=') {
      --end; // If we get a whole number of bytes, there is too much padding:

      if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
        throw new SyntaxError('Invalid padding');
      }
    } // Allocate the output:


    var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:

    var bits = 0; // Number of bits currently in the buffer

    var buffer = 0; // Bits waiting to be written out, MSB first

    var written = 0; // Next byte to write

    for (var _i = 0; _i < end; ++_i) {
      // Read one character from the string:
      var value = encoding.codes[string[_i]];

      if (value === undefined) {
        throw new SyntaxError('Invalid character ' + string[_i]);
      } // Append the bits to the buffer:


      buffer = buffer << encoding.bits | value;
      bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:

      if (bits >= 8) {
        bits -= 8;
        out[written++] = 0xff & buffer >> bits;
      }
    } // Verify that we have received just enough bits:


    if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {
      throw new SyntaxError('Unexpected end of data');
    }

    return out;
  }
  function stringify$2(data, encoding, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$pad = _opts.pad,
        pad = _opts$pad === void 0 ? true : _opts$pad;
    var mask = (1 << encoding.bits) - 1;
    var out = '';
    var bits = 0; // Number of bits currently in the buffer

    var buffer = 0; // Bits waiting to be written out, MSB first

    for (var i = 0; i < data.length; ++i) {
      // Slurp data into the buffer:
      buffer = buffer << 8 | 0xff & data[i];
      bits += 8; // Write out as much as we can:

      while (bits > encoding.bits) {
        bits -= encoding.bits;
        out += encoding.chars[mask & buffer >> bits];
      }
    } // Partial character:


    if (bits) {
      out += encoding.chars[mask & buffer << encoding.bits - bits];
    } // Add padding characters until we hit a byte boundary:


    if (pad) {
      while (out.length * encoding.bits & 7) {
        out += '=';
      }
    }

    return out;
  }
  var base32Encoding = {
    chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bits: 5
  };
  var base64UrlEncoding = {
    chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bits: 6
  };
  var base32 = {
    parse: function parse$1(string, opts) {
      if (opts === void 0) {
        opts = {};
      }

      return parse$4(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);
    },
    stringify: function stringify$1(data, opts) {
      return stringify$2(data, base32Encoding, opts);
    }
  };
  var base64url = {
    parse: function parse$1(string, opts) {
      return parse$4(string, base64UrlEncoding, opts);
    },
    stringify: function stringify$1(data, opts) {
      return stringify$2(data, base64UrlEncoding, opts);
    }
  };

  var isAlphanumeric$1 = {};

  var alpha$2 = {};

  Object.defineProperty(alpha$2, "__esModule", {
    value: true
  });
  alpha$2.commaDecimal = alpha$2.dotDecimal = alpha$2.bengaliLocales = alpha$2.farsiLocales = alpha$2.arabicLocales = alpha$2.englishLocales = alpha$2.decimal = alpha$2.alphanumeric = alpha$2.alpha = void 0;
  var alpha$1 = {
    'en-US': /^[A-Z]+$/i,
    'az-AZ': /^[A-VXYZ]+$/i,
    'bg-BG': /^[-]+$/i,
    'cs-CZ': /^[A-Z]+$/i,
    'da-DK': /^[A-Z]+$/i,
    'de-DE': /^[A-Z]+$/i,
    'el-GR': /^[-]+$/i,
    'es-ES': /^[A-Z]+$/i,
    'fa-IR': /^[]+$/i,
    'fi-FI': /^[A-Z]+$/i,
    'fr-FR': /^[A-Z]+$/i,
    'it-IT': /^[A-Z]+$/i,
    'ja-JP': /^[----]+$/i,
    'nb-NO': /^[A-Z]+$/i,
    'nl-NL': /^[A-Z]+$/i,
    'nn-NO': /^[A-Z]+$/i,
    'hu-HU': /^[A-Z]+$/i,
    'pl-PL': /^[A-Z]+$/i,
    'pt-PT': /^[A-Z]+$/i,
    'ru-RU': /^[-]+$/i,
    'kk-KZ': /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
    'sl-SI': /^[A-Z]+$/i,
    'sk-SK': /^[A-Z]+$/i,
    'sr-RS@latin': /^[A-Z]+$/i,
    'sr-RS': /^[-]+$/i,
    'sv-SE': /^[A-Z]+$/i,
    'th-TH': /^[-\s]+$/i,
    'tr-TR': /^[A-Z]+$/i,
    'uk-UA': /^[-I]+$/i,
    'vi-VN': /^[A-Z]+$/i,
    'ko-KR': /^[---]*$/,
    'ku-IQ': /^[]+$/i,
    ar: /^[]+$/,
    he: /^[-]+$/,
    fa: /^['']+$/i,
    bn: /^['']+$/,
    'hi-IN': /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
    'si-LK': /^[\u0D80-\u0DFF]+$/
  };
  alpha$2.alpha = alpha$1;
  var alphanumeric = {
    'en-US': /^[0-9A-Z]+$/i,
    'az-AZ': /^[0-9A-VXYZ]+$/i,
    'bg-BG': /^[0-9-]+$/i,
    'cs-CZ': /^[0-9A-Z]+$/i,
    'da-DK': /^[0-9A-Z]+$/i,
    'de-DE': /^[0-9A-Z]+$/i,
    'el-GR': /^[0-9-]+$/i,
    'es-ES': /^[0-9A-Z]+$/i,
    'fi-FI': /^[0-9A-Z]+$/i,
    'fr-FR': /^[0-9A-Z]+$/i,
    'it-IT': /^[0-9A-Z]+$/i,
    'ja-JP': /^[0-9-----]+$/i,
    'hu-HU': /^[0-9A-Z]+$/i,
    'nb-NO': /^[0-9A-Z]+$/i,
    'nl-NL': /^[0-9A-Z]+$/i,
    'nn-NO': /^[0-9A-Z]+$/i,
    'pl-PL': /^[0-9A-Z]+$/i,
    'pt-PT': /^[0-9A-Z]+$/i,
    'ru-RU': /^[0-9-]+$/i,
    'kk-KZ': /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
    'sl-SI': /^[0-9A-Z]+$/i,
    'sk-SK': /^[0-9A-Z]+$/i,
    'sr-RS@latin': /^[0-9A-Z]+$/i,
    'sr-RS': /^[0-9-]+$/i,
    'sv-SE': /^[0-9A-Z]+$/i,
    'th-TH': /^[-\s]+$/i,
    'tr-TR': /^[0-9A-Z]+$/i,
    'uk-UA': /^[0-9-I]+$/i,
    'ko-KR': /^[0-9---]*$/,
    'ku-IQ': /^[0-9]+$/i,
    'vi-VN': /^[0-9A-Z]+$/i,
    ar: /^[0-9]+$/,
    he: /^[0-9-]+$/,
    fa: /^['0-9']+$/i,
    bn: /^['']+$/,
    'hi-IN': /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
    'si-LK': /^[0-9\u0D80-\u0DFF]+$/
  };
  alpha$2.alphanumeric = alphanumeric;
  var decimal = {
    'en-US': '.',
    ar: ''
  };
  alpha$2.decimal = decimal;
  var englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
  alpha$2.englishLocales = englishLocales;

  for (var locale, i$1 = 0; i$1 < englishLocales.length; i$1++) {
    locale = "en-".concat(englishLocales[i$1]);
    alpha$1[locale] = alpha$1['en-US'];
    alphanumeric[locale] = alphanumeric['en-US'];
    decimal[locale] = decimal['en-US'];
  } // Source: http://www.localeplanet.com/java/


  var arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
  alpha$2.arabicLocales = arabicLocales;

  for (var _locale, _i$1 = 0; _i$1 < arabicLocales.length; _i$1++) {
    _locale = "ar-".concat(arabicLocales[_i$1]);
    alpha$1[_locale] = alpha$1.ar;
    alphanumeric[_locale] = alphanumeric.ar;
    decimal[_locale] = decimal.ar;
  }

  var farsiLocales = ['IR', 'AF'];
  alpha$2.farsiLocales = farsiLocales;

  for (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {
    _locale2 = "fa-".concat(farsiLocales[_i2]);
    alphanumeric[_locale2] = alphanumeric.fa;
    decimal[_locale2] = decimal.ar;
  }

  var bengaliLocales = ['BD', 'IN'];
  alpha$2.bengaliLocales = bengaliLocales;

  for (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {
    _locale3 = "bn-".concat(bengaliLocales[_i3]);
    alpha$1[_locale3] = alpha$1.bn;
    alphanumeric[_locale3] = alphanumeric.bn;
    decimal[_locale3] = decimal['en-US'];
  } // Source: https://en.wikipedia.org/wiki/Decimal_mark


  var dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];
  alpha$2.dotDecimal = dotDecimal;
  var commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'es-ES', 'fr-CA', 'fr-FR', 'id-ID', 'it-IT', 'ku-IQ', 'hi-IN', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'kk-KZ', 'si-LK', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN'];
  alpha$2.commaDecimal = commaDecimal;

  for (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {
    decimal[dotDecimal[_i4]] = decimal['en-US'];
  }

  for (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {
    decimal[commaDecimal[_i5]] = ',';
  }

  alpha$1['fr-CA'] = alpha$1['fr-FR'];
  alphanumeric['fr-CA'] = alphanumeric['fr-FR'];
  alpha$1['pt-BR'] = alpha$1['pt-PT'];
  alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
  decimal['pt-BR'] = decimal['pt-PT']; // see #862

  alpha$1['pl-Pl'] = alpha$1['pl-PL'];
  alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
  decimal['pl-Pl'] = decimal['pl-PL']; // see #1455

  alpha$1['fa-AF'] = alpha$1.fa;

  Object.defineProperty(isAlphanumeric$1, "__esModule", {
    value: true
  });
  var _default = isAlphanumeric$1.default = isAlphanumeric;
  isAlphanumeric$1.locales = void 0;

  var _assertString = _interopRequireDefault(assertStringExports);

  var _alpha = alpha$2;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function isAlphanumeric(_str) {
    var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _assertString.default)(_str);
    var str = _str;
    var ignore = options.ignore;

    if (ignore) {
      if (ignore instanceof RegExp) {
        str = str.replace(ignore, '');
      } else if (typeof ignore === 'string') {
        str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
      } else {
        throw new Error('ignore should be instance of a String or RegExp');
      }
    }

    if (locale in _alpha.alphanumeric) {
      return _alpha.alphanumeric[locale].test(str);
    }

    throw new Error("Invalid locale '".concat(locale, "'"));
  }

  var locales = Object.keys(_alpha.alphanumeric);
  isAlphanumeric$1.locales = locales;

  var validUrl = {exports: {}};

  (function (module) {
  	(function(module) {

  	    module.exports.is_uri = is_iri;
  	    module.exports.is_http_uri = is_http_iri;
  	    module.exports.is_https_uri = is_https_iri;
  	    module.exports.is_web_uri = is_web_iri;
  	    // Create aliases
  	    module.exports.isUri = is_iri;
  	    module.exports.isHttpUri = is_http_iri;
  	    module.exports.isHttpsUri = is_https_iri;
  	    module.exports.isWebUri = is_web_iri;


  	    // private function
  	    // internal URI spitter method - direct from RFC 3986
  	    var splitUri = function(uri) {
  	        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
  	        return splitted;
  	    };

  	    function is_iri(value) {
  	        if (!value) {
  	            return;
  	        }

  	        // check for illegal characters
  	        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

  	        // check for hex escapes that aren't complete
  	        if (/%[^0-9a-f]/i.test(value)) return;
  	        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

  	        var splitted = [];
  	        var scheme = '';
  	        var authority = '';
  	        var path = '';
  	        var query = '';
  	        var fragment = '';
  	        var out = '';

  	        // from RFC 3986
  	        splitted = splitUri(value);
  	        scheme = splitted[1]; 
  	        authority = splitted[2];
  	        path = splitted[3];
  	        query = splitted[4];
  	        fragment = splitted[5];

  	        // scheme and path are required, though the path can be empty
  	        if (!(scheme && scheme.length && path.length >= 0)) return;

  	        // if authority is present, the path must be empty or begin with a /
  	        if (authority && authority.length) {
  	            if (!(path.length === 0 || /^\//.test(path))) return;
  	        } else {
  	            // if authority is not present, the path must not start with //
  	            if (/^\/\//.test(path)) return;
  	        }

  	        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
  	        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))  return;

  	        // re-assemble the URL per section 5.3 in RFC 3986
  	        out += scheme + ':';
  	        if (authority && authority.length) {
  	            out += '//' + authority;
  	        }

  	        out += path;

  	        if (query && query.length) {
  	            out += '?' + query;
  	        }

  	        if (fragment && fragment.length) {
  	            out += '#' + fragment;
  	        }

  	        return out;
  	    }

  	    function is_http_iri(value, allowHttps) {
  	        if (!is_iri(value)) {
  	            return;
  	        }

  	        var splitted = [];
  	        var scheme = '';
  	        var authority = '';
  	        var path = '';
  	        var port = '';
  	        var query = '';
  	        var fragment = '';
  	        var out = '';

  	        // from RFC 3986
  	        splitted = splitUri(value);
  	        scheme = splitted[1]; 
  	        authority = splitted[2];
  	        path = splitted[3];
  	        query = splitted[4];
  	        fragment = splitted[5];

  	        if (!scheme)  return;

  	        if(allowHttps) {
  	            if (scheme.toLowerCase() != 'https') return;
  	        } else {
  	            if (scheme.toLowerCase() != 'http') return;
  	        }

  	        // fully-qualified URIs must have an authority section that is
  	        // a valid host
  	        if (!authority) {
  	            return;
  	        }

  	        // enable port component
  	        if (/:(\d+)$/.test(authority)) {
  	            port = authority.match(/:(\d+)$/)[0];
  	            authority = authority.replace(/:\d+$/, '');
  	        }

  	        out += scheme + ':';
  	        out += '//' + authority;
  	        
  	        if (port) {
  	            out += port;
  	        }
  	        
  	        out += path;
  	        
  	        if(query && query.length){
  	            out += '?' + query;
  	        }

  	        if(fragment && fragment.length){
  	            out += '#' + fragment;
  	        }
  	        
  	        return out;
  	    }

  	    function is_https_iri(value) {
  	        return is_http_iri(value, true);
  	    }

  	    function is_web_iri(value) {
  	        return (is_http_iri(value) || is_https_iri(value));
  	    }

  	})(module); 
  } (validUrl));

  var validUrlExports = validUrl.exports;

  var isPlainObj = value => {
  	if (Object.prototype.toString.call(value) !== '[object Object]') {
  		return false;
  	}

  	const prototype = Object.getPrototypeOf(value);
  	return prototype === null || prototype === Object.prototype;
  };

  const isOptionObject = isPlainObj;

  const {hasOwnProperty: hasOwnProperty$1} = Object.prototype;
  const {propertyIsEnumerable} = Object;
  const defineProperty = (object, name, value) => Object.defineProperty(object, name, {
  	value,
  	writable: true,
  	enumerable: true,
  	configurable: true
  });

  const globalThis$1 = commonjsGlobal;
  const defaultMergeOptions = {
  	concatArrays: false,
  	ignoreUndefined: false
  };

  const getEnumerableOwnPropertyKeys = value => {
  	const keys = [];

  	for (const key in value) {
  		if (hasOwnProperty$1.call(value, key)) {
  			keys.push(key);
  		}
  	}

  	/* istanbul ignore else  */
  	if (Object.getOwnPropertySymbols) {
  		const symbols = Object.getOwnPropertySymbols(value);

  		for (const symbol of symbols) {
  			if (propertyIsEnumerable.call(value, symbol)) {
  				keys.push(symbol);
  			}
  		}
  	}

  	return keys;
  };

  function clone$2(value) {
  	if (Array.isArray(value)) {
  		return cloneArray(value);
  	}

  	if (isOptionObject(value)) {
  		return cloneOptionObject(value);
  	}

  	return value;
  }

  function cloneArray(array) {
  	const result = array.slice(0, 0);

  	getEnumerableOwnPropertyKeys(array).forEach(key => {
  		defineProperty(result, key, clone$2(array[key]));
  	});

  	return result;
  }

  function cloneOptionObject(object) {
  	const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};

  	getEnumerableOwnPropertyKeys(object).forEach(key => {
  		defineProperty(result, key, clone$2(object[key]));
  	});

  	return result;
  }

  /**
   * @param {*} merged already cloned
   * @param {*} source something to merge
   * @param {string[]} keys keys to merge
   * @param {Object} config Config Object
   * @returns {*} cloned Object
   */
  const mergeKeys = (merged, source, keys, config) => {
  	keys.forEach(key => {
  		if (typeof source[key] === 'undefined' && config.ignoreUndefined) {
  			return;
  		}

  		// Do not recurse into prototype chain of merged
  		if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
  			defineProperty(merged, key, merge(merged[key], source[key], config));
  		} else {
  			defineProperty(merged, key, clone$2(source[key]));
  		}
  	});

  	return merged;
  };

  /**
   * @param {*} merged already cloned
   * @param {*} source something to merge
   * @param {Object} config Config Object
   * @returns {*} cloned Object
   *
   * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
   */
  const concatArrays = (merged, source, config) => {
  	let result = merged.slice(0, 0);
  	let resultIndex = 0;

  	[merged, source].forEach(array => {
  		const indices = [];

  		// `result.concat(array)` with cloning
  		for (let k = 0; k < array.length; k++) {
  			if (!hasOwnProperty$1.call(array, k)) {
  				continue;
  			}

  			indices.push(String(k));

  			if (array === merged) {
  				// Already cloned
  				defineProperty(result, resultIndex++, array[k]);
  			} else {
  				defineProperty(result, resultIndex++, clone$2(array[k]));
  			}
  		}

  		// Merge non-index keys
  		result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);
  	});

  	return result;
  };

  /**
   * @param {*} merged already cloned
   * @param {*} source something to merge
   * @param {Object} config Config Object
   * @returns {*} cloned Object
   */
  function merge(merged, source, config) {
  	if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
  		return concatArrays(merged, source, config);
  	}

  	if (!isOptionObject(source) || !isOptionObject(merged)) {
  		return clone$2(source);
  	}

  	return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
  }

  var mergeOptions = function (...options) {
  	const config = merge(clone$2(defaultMergeOptions), (this !== globalThis$1 && this) || {}, defaultMergeOptions);
  	let merged = {_: {}};

  	for (const option of options) {
  		if (option === undefined) {
  			continue;
  		}

  		if (!isOptionObject(option)) {
  			throw new TypeError('`' + option + '` is not an Option Object');
  		}

  		merged = merge(merged, {_: option}, config);
  	}

  	return merged._;
  };

  var mergeOptions$1 = /*@__PURE__*/getDefaultExportFromCjs(mergeOptions);

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Contains enums
   * @module enums
   */

  /**
   * The proxy policy that decides how to fetch a proof
   * @readonly
   * @enum {string}
   */
  const ProxyPolicy = {
    /** Proxy usage decision depends on environment and service provider */
    ADAPTIVE: 'adaptive',
    /** Always use a proxy */
    ALWAYS: 'always',
    /** Never use a proxy, skip a verification if a proxy is inevitable */
    NEVER: 'never'
  };

  /**
   * Methods for fetching proofs
   * @readonly
   * @enum {string}
   */
  const Fetcher = {
    /** HTTP requests to ActivityPub */
    ACTIVITYPUB: 'activitypub',
    /** ASPE HTTP requests */
    ASPE: 'aspe',
    /** DNS module from Node.js */
    DNS: 'dns',
    /** GraphQL over HTTP requests */
    GRAPHQL: 'graphql',
    /** Basic HTTP requests */
    HTTP: 'http',
    /** IRC module from Node.js */
    IRC: 'irc',
    /** HTTP request to Matrix API */
    MATRIX: 'matrix',
    /** HKP and WKS request for OpenPGP */
    OPENPGP: 'openpgp',
    /** HTTP request to Telegram API */
    TELEGRAM: 'telegram',
    /** XMPP module from Node.js */
    XMPP: 'xmpp'
  };

  /**
   * Entity encoding format
   * @readonly
   * @enum {string}
   */
  const EntityEncodingFormat = {
    /** No special formatting */
    PLAIN: 'plain',
    /** HTML encoded entities */
    HTML: 'html',
    /** XML encoded entities */
    XML: 'xml'
  };

  /**
   * Levels of access restriction for proof fetching
   * @readonly
   * @enum {string}
   */
  const ProofAccessRestriction = {
    /** Any HTTP request will work */
    NONE: 'none',
    /** CORS requests are denied */
    NOCORS: 'nocors',
    /** HTTP requests must contain API or access tokens */
    GRANTED: 'granted',
    /** Not accessible by HTTP request, needs server software */
    SERVER: 'server'
  };

  /**
   * Format of proof
   * @readonly
   * @enum {string}
   */
  const ProofFormat = {
    /** JSON format */
    JSON: 'json',
    /** Plaintext format */
    TEXT: 'text'
  };

  /**
   * Format of claim
   * @readonly
   * @enum {string}
   */
  const ClaimFormat = {
    /** `openpgp4fpr:123123123` */
    URI: 'uri',
    /** `123123123` */
    FINGERPRINT: 'fingerprint'
  };

  /**
   * How to find the proof inside the fetched data
   * @readonly
   * @enum {string}
   */
  const ClaimRelation = {
    /** Claim is somewhere in the JSON field's textual content */
    CONTAINS: 'contains',
    /** Claim is equal to the JSON field's textual content */
    EQUALS: 'equals',
    /** Claim is equal to an element of the JSON field's array of strings */
    ONEOF: 'oneof'
  };

  /**
   * Status of the Claim instance
   * @readonly
   * @enum {number}
   */
  const ClaimStatus = {
    /** Claim has been initialized */
    INIT: 100,
    /** Claim has matched its URI to candidate claim definitions */
    MATCHED: 101,
    /** Claim was successfully verified */
    VERIFIED: 200,
    /** Claim was successfully verified using proxied data */
    VERIFIED_VIA_PROXY: 201,
    /** Unknown matching error */
    MATCHING_ERROR: 300,
    /** No matched service providers */
    NO_MATCHES: 301,
    /** Unknown matching error */
    VERIFICATION_ERROR: 400,
    /** No proof found in data returned by service providers */
    NO_PROOF_FOUND: 401
  };

  /**
   * Profile type
   * @readonly
   * @enum {string}
   */
  const ProfileType = {
    /** ASP profile */
    ASP: 'asp',
    /** OpenPGP profile */
    OPENPGP: 'openpgp'
  };

  /**
   * Public key type
   * @readonly
   * @enum {string}
   */
  const PublicKeyType = {
    EDDSA: 'eddsa',
    ES256: 'es256',
    OPENPGP: 'openpgp',
    UNKNOWN: 'unknown',
    NONE: 'none'
  };

  /**
   * Public key format
   * @readonly
   * @enum {string}
   */
  const PublicKeyEncoding = {
    PEM: 'pem',
    JWK: 'jwk',
    ARMORED_PGP: 'armored_pgp',
    NONE: 'none'
  };

  /**
   * Method to fetch the public key
   * @readonly
   * @enum {string}
   */
  const PublicKeyFetchMethod = {
    ASPE: 'aspe',
    HKP: 'hkp',
    WKD: 'wkd',
    HTTP: 'http',
    NONE: 'none'
  };

  /**
   * Protocol to query OpenPGP public keys
   * @readonly
   * @enum {string}
   */
  const OpenPgpQueryProtocol = {
    HKP: 'hkp',
    WKD: 'wkd'
  };

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * @class
   * @classdesc A persona with identity claims
   * @example
   * const claim = Claim('https://alice.tld', '123');
   * const pers = Persona('Alice', 'About Alice', [claim]);
   */
  class Persona {
    /**
     * @param {string} name - Name of the persona
     * @param {Array<Claim>} claims - Claims of the persona
     */
    constructor (name, claims) {
      /**
       * Identifier of the persona
       * @type {string | null}
       * @public
       */
      this.identifier = null;
      /**
       * Name to be displayed on the profile page
       * @type {string}
       * @public
       */
      this.name = name;
      /**
       * Email address of the persona
       * @type {string | null}
       * @public
       */
      this.email = null;
      /**
       * Description to be displayed on the profile page
       * @type {string | null}
       * @public
       */
      this.description = null;
      /**
       * URL to an avatar image
       * @type {string | null}
       * @public
       */
      this.avatarUrl = null;
      /**
       * Theme color
       * @type {string | null}
       * @public
       */
      this.themeColor = null;
      /**
       * List of identity claims
       * @type {Array<Claim>}
       * @public
       */
      this.claims = claims;
      /**
       * Has the persona been revoked
       * @type {boolean}
       * @public
       */
      this.isRevoked = false;
    }

    /**
     * Parse a JSON object and convert it into a persona
     * @function
     * @param {object} personaObject - JSON representation of a persona
     * @param {number} profileVersion - Version of the Profile containing the persona
     * @returns {Persona | Error} Parsed persona
     * @example
     * doip.Persona.fromJSON(JSON.stringify(persona), 2);
     */
    static fromJSON (personaObject, profileVersion) {
      /** @type {Persona} */
      let persona;
      let result;

      if (typeof personaObject === 'object' && profileVersion) {
        switch (profileVersion) {
          case 2:
            result = importJsonPersonaVersion2(personaObject);
            if (result instanceof Error) {
              throw result
            }
            persona = result;
            break

          default:
            throw new Error('Invalid persona version')
        }
      }

      return persona
    }

    /**
     * Set the persona's identifier
     * @function
     * @param {string} identifier - Identifier of the persona
     */
    setIdentifier (identifier) {
      this.identifier = identifier;
    }

    /**
     * Set the persona's description
     * @function
     * @param {string} description - Description of the persona
     */
    setDescription (description) {
      this.description = description;
    }

    /**
     * Set the persona's email address
     * @function
     * @param {string} email - Email address of the persona
     */
    setEmailAddress (email) {
      this.email = email;
    }

    /**
     * Set the URL to the persona's avatar
     * @function
     * @param {string} avatarUrl - URL to the persona's avatar
     */
    setAvatarUrl (avatarUrl) {
      this.avatarUrl = avatarUrl;
    }

    /**
     * Add a claim
     * @function
     * @param {Claim} claim - Claim to add
     */
    addClaim (claim) {
      this.claims.push(claim);
    }

    /**
     * Revoke the persona
     * @function
     */
    revoke () {
      this.isRevoked = true;
    }

    /**
     * Get a JSON representation of the persona
     * @function
     * @returns {object} JSON representation of the persona
     */
    toJSON () {
      return {
        identifier: this.identifier,
        name: this.name,
        email: this.email,
        description: this.description,
        avatarUrl: this.avatarUrl,
        themeColor: this.themeColor,
        isRevoked: this.isRevoked,
        claims: this.claims.map(x => x.toJSON())
      }
    }
  }

  /**
   * @ignore
   * @param {object} personaObject - JSON representation of a persona
   * @returns {Persona | Error} Parsed persona
   */
  function importJsonPersonaVersion2 (personaObject) {
    const claims = personaObject.claims.map(x => Claim.fromJSON(x));

    const persona = new Persona(personaObject.name, claims);

    persona.identifier = personaObject.identifier;
    persona.email = personaObject.email;
    persona.description = personaObject.description;
    persona.avatarUrl = personaObject.avatarUrl;
    persona.themeColor = personaObject.avatarUrl;
    persona.isRevoked = personaObject.isRevoked;

    return persona
  }

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * @class
   * @classdesc A profile of personas with identity claims
   * @param {Array<Persona>} personas - Personas of the profile
   * @example
   * const claim = Claim('https://alice.tld', '123');
   * const pers = Persona('Alice', 'About Alice', [claim]);
   * const profile = Profile([pers]);
   */
  class Profile {
    /**
     * Create a new profile
     * @function
     * @param {ProfileType} profileType - Type of profile (ASP, OpenPGP, etc.)
     * @param {string} identifier - Profile identifier (fingerprint, URI, etc.)
     * @param {Array<Persona>} personas - Personas of the profile
     * @public
     */
    constructor (profileType, identifier, personas) {
      this.profileVersion = 2;
      /**
       * Profile version
       * @type {ProfileType}
       * @public
       */
      this.profileType = profileType;
      /**
       * Identifier of the profile (fingerprint, email address, uri...)
       * @type {string}
       * @public
       */
      this.identifier = identifier;
      /**
       * List of personas
       * @type {Array<Persona>}
       * @public
       */
      this.personas = personas || [];
      /**
       * Index of primary persona (to be displayed first or prominently)
       * @type {number}
       * @public
       */
      this.primaryPersonaIndex = personas.length > 0 ? 0 : -1;
      /**
       * The cryptographic key associated with the profile
       * @type {import('./types').ProfilePublicKey}
       * @public
       */
      this.publicKey = {
        keyType: PublicKeyType.NONE,
        fingerprint: null,
        encoding: PublicKeyEncoding.NONE,
        encodedKey: null,
        key: null,
        fetch: {
          method: PublicKeyFetchMethod.NONE,
          query: null,
          resolvedUrl: null
        }
      };
      /**
       * List of verifier URLs
       * @type {Array<import('./types').ProfileVerifier>}
       * @public
       */
      this.verifiers = [];
    }

    /**
     * Parse a JSON object and convert it into a profile
     * @function
     * @param {object} profileObject - JSON representation of a profile
     * @returns {Profile | Error} Parsed profile
     * @example
     * doip.Profile.fromJSON(JSON.stringify(profile));
     */
    static fromJSON (profileObject) {
      /** @type {Profile} */
      let profile;
      let result;

      if (typeof profileObject === 'object' && 'profileVersion' in profileObject) {
        switch (profileObject.profileVersion) {
          case 2:
            result = importJsonProfileVersion2(profileObject);
            if (result instanceof Error) {
              throw result
            }
            profile = result;
            break

          default:
            throw new Error('Invalid profile version')
        }
      }

      return profile
    }

    /**
     * Add profile verifier to the profile
     * @function
     * @param {string} name - Name of the verifier
     * @param {string} url - URL of the verifier
     */
    addVerifier (name, url) {
      this.verifiers.push({ name, url });
    }

    /**
     * Get a JSON representation of the profile
     * @function
     * @returns {object} JSON representation of the profile
     */
    toJSON () {
      return {
        profileVersion: this.profileVersion,
        profileType: this.profileType,
        identifier: this.identifier,
        personas: this.personas.map(x => x.toJSON()),
        primaryPersonaIndex: this.primaryPersonaIndex,
        publicKey: {
          keyType: this.publicKey.keyType,
          fingerprint: this.publicKey.fingerprint,
          encoding: this.publicKey.encoding,
          encodedKey: this.publicKey.encodedKey,
          fetch: {
            method: this.publicKey.fetch.method,
            query: this.publicKey.fetch.query,
            resolvedUrl: this.publicKey.fetch.resolvedUrl
          }
        },
        verifiers: this.verifiers
      }
    }
  }

  /**
   * @ignore
   * @param {object} profileObject - JSON representation of the profile
   * @returns {Profile | Error} Parsed profile
   */
  function importJsonProfileVersion2 (profileObject) {
    if (!('profileVersion' in profileObject && profileObject.profileVersion === 2)) {
      return new Error('Invalid profile')
    }

    const personas = profileObject.personas.map(x => Persona.fromJSON(x, 2));

    const profile = new Profile(profileObject.profileType, profileObject.identifier, personas);

    profile.primaryPersonaIndex = profileObject.primaryPersonaIndex;
    profile.publicKey = profileObject.publicKey;
    profile.verifiers = profileObject.verifiers;

    return profile
  }

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * A service provider matched to an identity claim
   * @class
   * @public
   */
  class ServiceProvider {
    /**
     * @param {import('./types').ServiceProviderObject} serviceProviderObject - JSON representation of a {@link ServiceProvider}
     */
    constructor (serviceProviderObject) {
      /**
       * Details about the service provider
       * @type {import('./types').ServiceProviderAbout}
       */
      this.about = serviceProviderObject.about;
      /**
       * What the profile would look like if a claim matches this service provider
       * @type {import('./types').ServiceProviderProfile}
       */
      this.profile = serviceProviderObject.profile;
      /**
       * Information about the claim matching process
       * @type {import('./types').ServiceProviderClaim}
       */
      this.claim = serviceProviderObject.claim;
      /**
       * Information for the proof verification process
       * @type {import('./types').ServiceProviderProof}
       */
      this.proof = serviceProviderObject.proof;
    }

    /**
     * Get a JSON representation of the {@link ServiceProvider}
     * @function
     * @returns {import('./types').ServiceProviderObject} JSON representation of a {@link ServiceProvider}
     */
    toJSON () {
      return {
        about: this.about,
        profile: this.profile,
        claim: this.claim,
        proof: this.proof
      }
    }
  }

  /*
  Copyright 2024 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * ASPE service provider ({@link https://docs.keyoxide.org/service-providers/aspe/|Keyoxide docs})
   * @module serviceProviders/aspe
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.activitypub.processURI('aspe:domain.example:abc123def456');
   */


  const reURI$p = /^aspe:([a-zA-Z0-9.\-_]*):([a-zA-Z0-9]*)/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$o (uri) {
    const match = uri.match(reURI$p);

    if (!isFQDN(match[1])) {
      return null
    }

    return new ServiceProvider({
      about: {
        id: 'aspe',
        name: 'ASPE'
      },
      profile: {
        display: uri,
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$p.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: null,
          fetcher: Fetcher.ASPE,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            aspeUri: uri
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['claims']
        }]
      }
    })
  }

  const tests$o = [
    {
      uri: 'aspe:domain.tld:abc123def456',
      shouldMatch: true
    },
    {
      uri: 'aspe:domain.tld',
      shouldMatch: false
    },
    {
      uri: 'dns:domain.tld',
      shouldMatch: false
    },
    {
      uri: 'https://domain.tld',
      shouldMatch: false
    }
  ];

  var aspe$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$o,
    reURI: reURI$p,
    tests: tests$o
  });

  /*
  Copyright 2024 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * OpenPGP service provider ({@link https://docs.keyoxide.org/service-providers/openpgp/|Keyoxide docs})
   * @module serviceProviders/openpgp
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.openpgp.processURI('openpgp4fpr:ABC123DEF456');
   */


  const reURI$o = /^(.*)/;

  const reURIHkp = /^openpgp4fpr:(?:0x)?([a-zA-Z0-9.\-_]*)/;
  const reURIWkdDirect = /^https:\/\/(.*)\/.well-known\/openpgpkey\/hu\/([a-zA-Z0-9]*)(?:\?l=(.*))?/;
  const reURIWkdAdvanced = /^https:\/\/(openpgpkey.*)\/.well-known\/openpgpkey\/(.*)\/hu\/([a-zA-Z0-9]*)(?:\?l=(.*))?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$n (uri) {
    let reURI = null;
    let mode = null;
    let match = null;

    if (reURIHkp.test(uri)) {
      reURI = reURIHkp;
      mode = OpenPgpQueryProtocol.HKP;
      match = uri.match(reURI);
    }
    if (!mode && reURIWkdAdvanced.test(uri)) {
      reURI = reURIWkdAdvanced;
      mode = OpenPgpQueryProtocol.WKD;
      match = uri.match(reURI);
    }
    if (!mode && reURIWkdDirect.test(uri)) {
      reURI = reURIWkdDirect;
      mode = OpenPgpQueryProtocol.WKD;
      match = uri.match(reURI);
    }

    let output = null;

    switch (mode) {
      case OpenPgpQueryProtocol.HKP:
        output = new ServiceProvider({
          about: {
            id: 'openpgp',
            name: 'OpenPGP'
          },
          profile: {
            display: `openpgp4fpr:${match[1]}`,
            uri: `https://keys.openpgp.org/search?q=${match[1]}`,
            qr: null
          },
          claim: {
            uriRegularExpression: reURI.toString(),
            uriIsAmbiguous: false
          },
          proof: {
            request: {
              uri: `https://keys.openpgp.org/vks/v1/by-fingerprint/${match[1].toUpperCase()}`,
              fetcher: Fetcher.OPENPGP,
              accessRestriction: ProofAccessRestriction.NONE,
              data: {
                url: `https://keys.openpgp.org/vks/v1/by-fingerprint/${match[1].toUpperCase()}`,
                protocol: OpenPgpQueryProtocol.HKP
              }
            },
            response: {
              format: ProofFormat.JSON
            },
            target: [{
              format: ClaimFormat.URI,
              encoding: EntityEncodingFormat.PLAIN,
              relation: ClaimRelation.EQUALS,
              path: ['notations', 'proof@ariadne.id']
            }]
          }
        });
        break
      case OpenPgpQueryProtocol.WKD:
        output = new ServiceProvider({
          about: {
            id: 'openpgp',
            name: 'OpenPGP'
          },
          profile: {
            display: 'unknown fingerprint',
            uri,
            qr: null
          },
          claim: {
            uriRegularExpression: reURI.toString(),
            uriIsAmbiguous: false
          },
          proof: {
            request: {
              uri,
              fetcher: Fetcher.OPENPGP,
              accessRestriction: ProofAccessRestriction.NONE,
              data: {
                url: uri,
                protocol: OpenPgpQueryProtocol.WKD
              }
            },
            response: {
              format: ProofFormat.JSON
            },
            target: [{
              format: ClaimFormat.URI,
              encoding: EntityEncodingFormat.PLAIN,
              relation: ClaimRelation.EQUALS,
              path: ['notations', 'proof@ariadne.id']
            }]
          }
        });
        break
    }

    return output
  }

  const tests$n = [
    {
      uri: 'openpgp4fpr:123456789',
      shouldMatch: true
    },
    {
      uri: 'openpgp4fpr:abcdef123',
      shouldMatch: true
    },
    {
      uri: 'https://openpgpkey.domain.tld/.well-known/openpgpkey/domain.tld/hu/123abc456def?l=name',
      shouldMatch: true
    },
    {
      uri: 'https://openpgpkey.domain.tld/.well-known/openpgpkey/domain.tld/hu/123abc456def',
      shouldMatch: true
    },
    {
      uri: 'https://domain.tld/.well-known/openpgpkey/hu/123abc456def?l=name',
      shouldMatch: true
    },
    {
      uri: 'https://domain.tld/.well-known/openpgpkey/hu/123abc456def',
      shouldMatch: true
    },
    // The following will not pass .processURI, but reURI currently accepts anything
    {
      uri: 'https://domain.tld',
      shouldMatch: true
    },
    {
      uri: 'https://openpgpkey.domain.tld/.well-known/openpgpkey/hu/123abc456def?l=name',
      shouldMatch: true
    },
    {
      uri: 'https://domain.tld/.well-known/openpgpkey/123abc456def?l=name',
      shouldMatch: true
    }
  ];

  var openpgp$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$n,
    reURI: reURI$o,
    tests: tests$n
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * DNS service provider ({@link https://docs.keyoxide.org/service-providers/dns/|Keyoxide docs})
   * @module serviceProviders/dns
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.dns.processURI('dns:domain.example?type=TXT');
   */


  const reURI$n = /^dns:([a-zA-Z0-9.\-_]*)(?:\?(.*))?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$m (uri) {
    const match = uri.match(reURI$n);

    return new ServiceProvider({
      about: {
        id: 'dns',
        name: 'DNS'
      },
      profile: {
        display: match[1],
        uri: `https://${match[1]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$n.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: null,
          fetcher: Fetcher.DNS,
          accessRestriction: ProofAccessRestriction.SERVER,
          data: {
            domain: match[1]
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['records', 'txt']
        }]
      }
    })
  }

  const tests$m = [
    {
      uri: 'dns:domain.org',
      shouldMatch: true
    },
    {
      uri: 'dns:domain.org?type=TXT',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org',
      shouldMatch: false
    }
  ];

  var dns$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$m,
    reURI: reURI$n,
    tests: tests$m
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * IRC service provider ({@link https://docs.keyoxide.org/service-providers/irc/|Keyoxide docs})
   * @module serviceProviders/irc
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.irc.processURI('irc://domain.example/alice');
   */


  const reURI$m = /^irc:\/\/(.*)\/([a-zA-Z0-9\-[\]\\`_^{|}]*)/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$l (uri) {
    const match = uri.match(reURI$m);

    return new ServiceProvider({
      about: {
        id: 'irc',
        name: 'IRC'
      },
      profile: {
        display: `${match[1]}/${match[2]}`,
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$m.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: null,
          fetcher: Fetcher.IRC,
          accessRestriction: ProofAccessRestriction.SERVER,
          data: {
            domain: match[1],
            nick: match[2]
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: []
        }]
      }
    })
  }

  const tests$l = [
    {
      uri: 'irc://chat.ircserver.org/Alice1',
      shouldMatch: true
    },
    {
      uri: 'irc://chat.ircserver.org/alice?param=123',
      shouldMatch: true
    },
    {
      uri: 'irc://chat.ircserver.org/alice_bob',
      shouldMatch: true
    },
    {
      uri: 'https://chat.ircserver.org/alice',
      shouldMatch: false
    }
  ];

  var irc$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$l,
    reURI: reURI$m,
    tests: tests$l
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * XMPP service provider ({@link https://docs.keyoxide.org/service-providers/xmpp/|Keyoxide docs})
   * @module serviceProviders/xmpp
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.xmpp.processURI('xmpp:alice@domain.example');
   */


  const reURI$l = /^xmpp:([a-zA-Z0-9.\-_]*)@([a-zA-Z0-9.\-_]*)(?:\?(.*))?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$k (uri) {
    const match = uri.match(reURI$l);

    return new ServiceProvider({
      about: {
        id: 'xmpp',
        name: 'XMPP',
        homepage: 'https://xmpp.org'
      },
      profile: {
        display: `${match[1]}@${match[2]}`,
        uri,
        qr: uri
      },
      claim: {
        uriRegularExpression: reURI$l.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: null,
          fetcher: Fetcher.XMPP,
          accessRestriction: ProofAccessRestriction.SERVER,
          data: {
            id: `${match[1]}@${match[2]}`
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: []
        }]
      }
    })
  }

  const tests$k = [
    {
      uri: 'xmpp:alice@domain.org',
      shouldMatch: true
    },
    {
      uri: 'xmpp:alice@domain.org?omemo-sid-123456789=A1B2C3D4E5F6G7H8I9',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org',
      shouldMatch: false
    }
  ];

  var xmpp$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$k,
    reURI: reURI$l,
    tests: tests$k
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Matrix service provider ({@link https://docs.keyoxide.org/service-providers/matrix/|Keyoxide docs})
   * @module serviceProviders/matrix
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.matrix.processURI('matrix:u/...');
   */


  const reURI$k = /^matrix:u\/(?:@)?([^@:]*:[^?]*)(\?.*)?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$j (uri) {
    const match = uri.match(reURI$k);

    if (!match[2]) {
      return null
    }

    const params = new URLSearchParams(match[2]);

    if (!(params.has('org.keyoxide.e') && params.has('org.keyoxide.r'))) {
      return null
    }

    const paramRoomId = `${params.get('org.keyoxide.r')[0] !== '!' ? '!' : ''}${params.get('org.keyoxide.r')}`;
    const paramEventId = `${params.get('org.keyoxide.e')[0] !== '$' ? '$' : ''}${params.get('org.keyoxide.e')}`;

    const profileUrl = `https://matrix.to/#/@${match[1]}`;
    const eventUrl = `https://matrix.to/#/${paramRoomId}/${paramEventId}`;

    return new ServiceProvider({
      about: {
        id: 'matrix',
        name: 'Matrix',
        homepage: 'https://matrix.org'
      },
      profile: {
        display: `@${match[1]}`,
        uri: profileUrl,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$k.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: eventUrl,
          fetcher: Fetcher.MATRIX,
          accessRestriction: ProofAccessRestriction.GRANTED,
          data: {
            eventId: paramEventId,
            roomId: paramRoomId
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['content', 'body']
        }]
      }
    })
  }

  const tests$j = [
    {
      uri:
        'matrix:u/alice:matrix.domain.org?org.keyoxide.r=123:domain.org&org.keyoxide.e=123',
      shouldMatch: true
    },
    {
      uri: 'matrix:u/alice:matrix.domain.org',
      shouldMatch: true
    },
    {
      uri:
        'matrix:u/@alice:matrix.domain.org?org.keyoxide.r=!123:domain.org&org.keyoxide.e=$123',
      shouldMatch: true
    },
    {
      uri: 'xmpp:alice@domain.org',
      shouldMatch: false
    },
    {
      uri: 'https://domain.org/@alice',
      shouldMatch: false
    }
  ];

  var matrix$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$j,
    reURI: reURI$k,
    tests: tests$j
  });

  /*
  Copyright 2022 Maximilian Siling

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Telegram service provider ({@link https://docs.keyoxide.org/service-providers/telegram/|Keyoxide docs})
   * @module serviceProviders/telegram
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.telegram.processURI('https://t.me/alice?proof=mygroup');
   */


  const reURI$j = /https:\/\/t.me\/([A-Za-z0-9_]{5,32})\?proof=([A-Za-z0-9_]{5,32})/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$i (uri) {
    const match = uri.match(reURI$j);

    return new ServiceProvider({
      about: {
        id: 'telegram',
        name: 'Telegram',
        homepage: 'https://telegram.org'
      },
      profile: {
        display: `@${match[1]}`,
        uri: `https://t.me/${match[1]}`,
        qr: `https://t.me/${match[1]}`
      },
      claim: {
        uriRegularExpression: reURI$j.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: `https://t.me/${match[2]}`,
          fetcher: Fetcher.TELEGRAM,
          accessRestriction: ProofAccessRestriction.GRANTED,
          data: {
            user: match[1],
            chat: match[2]
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.EQUALS,
          path: ['text']
        }]
      }
    })
  }

  const tests$i = [
    {
      uri: 'https://t.me/alice?proof=foobar',
      shouldMatch: true
    },
    {
      uri: 'https://t.me/complex_user_1234?proof=complex_chat_1234',
      shouldMatch: true
    },
    {
      uri: 'https://t.me/foobar',
      shouldMatch: false
    },
    {
      uri: 'https://t.me/foobar?proof=',
      shouldMatch: false
    },
    {
      uri: 'https://t.me/?proof=foobar',
      shouldMatch: false
    }
  ];

  var telegram$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$i,
    reURI: reURI$j,
    tests: tests$i
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Twitter service provider ({@link https://docs.keyoxide.org/service-providers/twitter/|Keyoxide docs})
   * @module serviceProviders/twitter
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.twitter.processURI('https://twitter.com/alice/status/123456789');
   */


  const reURI$i = /^https:\/\/twitter\.com\/(.*)\/status\/([0-9]*)(?:\?.*)?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$h (uri) {
    const match = uri.match(reURI$i);

    const urlsp = new URLSearchParams();
    urlsp.set('url', match[0]);
    urlsp.set('omit_script', '1');

    return new ServiceProvider({
      about: {
        id: 'twitter',
        name: 'Twitter',
        homepage: 'https://twitter.com'
      },
      profile: {
        display: `@${match[1]}`,
        uri: `https://twitter.com/${match[1]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$i.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            // Returns an oembed json object with the tweet content in html form
            url: `https://publish.twitter.com/oembed?${urlsp}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['html']
        }]
      }
    })
  }

  const tests$h = [
    {
      uri: 'https://twitter.com/alice/status/1234567890123456789',
      shouldMatch: true
    },
    {
      uri: 'https://twitter.com/alice/status/1234567890123456789/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/status/1234567890123456789',
      shouldMatch: false
    }
  ];

  var twitter = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$h,
    reURI: reURI$i,
    tests: tests$h
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Reddit service provider ({@link https://docs.keyoxide.org/service-providers/reddit/|Keyoxide docs})
   * @module serviceProviders/reddit
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.reddit.processURI('https://reddit.com/...');
   */


  const reURI$h = /^https:\/\/(?:www\.)?reddit\.com\/user\/(.*)\/comments\/(.*)\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$g (uri) {
    const match = uri.match(reURI$h);

    return new ServiceProvider({
      about: {
        id: 'reddit',
        name: 'Reddit',
        homepage: 'https://reddit.com'
      },
      profile: {
        display: match[1],
        uri: `https://www.reddit.com/user/${match[1]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$h.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://www.reddit.com/user/${match[1]}/comments/${match[2]}.json`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['data', 'children', 'data', 'selftext']
        }]
      }
    })
  }

  const tests$g = [
    {
      uri: 'https://www.reddit.com/user/Alice/comments/123456/post',
      shouldMatch: true
    },
    {
      uri: 'https://www.reddit.com/user/Alice/comments/123456/post/',
      shouldMatch: true
    },
    {
      uri: 'https://reddit.com/user/Alice/comments/123456/post',
      shouldMatch: true
    },
    {
      uri: 'https://reddit.com/user/Alice/comments/123456/post/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/user/Alice/comments/123456/post',
      shouldMatch: false
    }
  ];

  var reddit = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$g,
    reURI: reURI$h,
    tests: tests$g
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Liberapay service provider ({@link https://docs.keyoxide.org/service-providers/liberapay/|Keyoxide docs})
   * @module serviceProviders/liberapay
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.liberapay.processURI('https://liberapay.com/alice');
   */


  const reURI$g = /^https:\/\/liberapay\.com\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$f (uri) {
    const match = uri.match(reURI$g);

    return new ServiceProvider({
      about: {
        id: 'liberapay',
        name: 'Liberapay',
        homepage: 'https://liberapay.com'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$g.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: `https://liberapay.com/${match[1]}/public.json`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['statements', 'content']
        }]
      }
    })
  }

  const tests$f = [
    {
      uri: 'https://liberapay.com/alice',
      shouldMatch: true
    },
    {
      uri: 'https://liberapay.com/alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice',
      shouldMatch: false
    }
  ];

  var liberapay = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$f,
    reURI: reURI$g,
    tests: tests$f
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Lichess service provider ({@link https://docs.keyoxide.org/service-providers/lichess/|Keyoxide docs})
   * @module serviceProviders/lichess
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.lichess.processURI('https://lichess.org/@/alice');
   */


  const reURI$f = /^https:\/\/lichess\.org\/@\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$e (uri) {
    const match = uri.match(reURI$f);

    return new ServiceProvider({
      about: {
        id: 'lichess',
        name: 'Lichess',
        homepage: 'https://lichess.org'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$f.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: `https://lichess.org/api/user/${match[1]}`,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: `https://lichess.org/api/user/${match[1]}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.FINGERPRINT,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['profile', 'links']
        }]
      }
    })
  }

  const tests$e = [
    {
      uri: 'https://lichess.org/@/Alice',
      shouldMatch: true
    },
    {
      uri: 'https://lichess.org/@/Alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/@/Alice',
      shouldMatch: false
    }
  ];

  var lichess = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$e,
    reURI: reURI$f,
    tests: tests$e
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Hackernews service provider ({@link https://docs.keyoxide.org/service-providers/hackernews/|Keyoxide docs})
   * @module serviceProviders/hackernews
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.hackernews.processURI('https://news.ycombinator.com/user?id=alice');
   */


  const reURI$e = /^https:\/\/news\.ycombinator\.com\/user\?id=(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$d (uri) {
    const match = uri.match(reURI$e);

    return new ServiceProvider({
      about: {
        id: 'hackernews',
        name: 'Hacker News',
        homepage: 'https://news.ycombinator.com'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$e.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: `https://hacker-news.firebaseio.com/v0/user/${match[1]}.json`,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://hacker-news.firebaseio.com/v0/user/${match[1]}.json`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.HTML,
          relation: ClaimRelation.CONTAINS,
          path: ['about']
        }]
      }
    })
  }

  const tests$d = [
    {
      uri: 'https://news.ycombinator.com/user?id=Alice',
      shouldMatch: true
    },
    {
      uri: 'https://news.ycombinator.com/user?id=Alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/user?id=Alice',
      shouldMatch: false
    }
  ];

  var hackernews = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$d,
    reURI: reURI$e,
    tests: tests$d
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Lobste.rs service provider ({@link https://docs.keyoxide.org/service-providers/lobsters/|Keyoxide docs})
   * @module serviceProviders/lobsters
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.lobsters.processURI('https://lobste.rs/~alice');
   */


  const reURI$d = /^https:\/\/lobste\.rs\/(?:~|u\/)(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$c (uri) {
    const match = uri.match(reURI$d);

    return new ServiceProvider({
      about: {
        id: 'lobsters',
        name: 'Lobsters',
        homepage: 'https://lobste.rs'
      },
      profile: {
        display: match[1],
        uri: `https://lobste.rs/~${match[1]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$d.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: `https://lobste.rs/~${match[1]}.json`,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://lobste.rs/~${match[1]}.json`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['about']
        }]
      }
    })
  }

  const tests$c = [
    {
      uri: 'https://lobste.rs/~Alice',
      shouldMatch: true
    },
    {
      uri: 'https://lobste.rs/u/Alice',
      shouldMatch: true
    },
    {
      uri: 'https://lobste.rs/u/Alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/~Alice',
      shouldMatch: false
    },
    {
      uri: 'https://domain.org/u/Alice',
      shouldMatch: false
    }
  ];

  var lobsters = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$c,
    reURI: reURI$d,
    tests: tests$c
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Forem service provider ({@link https://docs.keyoxide.org/service-providers/forem/|Keyoxide docs})
   * @module serviceProviders/forem
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.forem.processURI('https://domain.example/alice/title');
   */


  const reURI$c = /^https:\/\/(.*)\/(.*)\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$b (uri) {
    const match = uri.match(reURI$c);

    return new ServiceProvider({
      about: {
        id: 'forem',
        name: 'Forem',
        homepage: 'https://www.forem.com'
      },
      profile: {
        display: `${match[2]}@${match[1]}`,
        uri: `https://${match[1]}/${match[2]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$c.toString().toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://${match[1]}/api/articles/${match[2]}/${match[3]}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['body_markdown']
        }]
      }
    })
  }

  const tests$b = [
    {
      uri: 'https://domain.org/alice/post',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/post/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice',
      shouldMatch: false
    }
  ];

  var forem = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$b,
    reURI: reURI$c,
    tests: tests$b
  });

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Forgejo service provider ({@link https://docs.keyoxide.org/service-providers/forgejo/|Keyoxide docs})
   * @module serviceProviders/forgejo
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.forgejo.processURI('https://domain.example/alice/repo');
   */


  const reURI$b = /^https:\/\/(.*)\/(.*)\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$a (uri) {
    const match = uri.match(reURI$b);

    return new ServiceProvider({
      about: {
        id: 'forgejo',
        name: 'Forgejo',
        homepage: 'https://forgejo.org'
      },
      profile: {
        display: `${match[2]}@${match[1]}`,
        uri: `https://${match[1]}/${match[2]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$b.toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://${match[1]}/api/v1/repos/${match[2]}/${match[3]}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.EQUALS,
          path: ['description']
        }]
      }
    })
  }

  const functions$1 = {
    validate: async (/** @type {ServiceProvider} */ claimData, proofData, opts) => {
      const url = `https://${new URL(claimData.proof.request.uri).hostname}/api/forgejo/v1/version`;
      const forgejoData = await fn$5({ url, format: ProofFormat.JSON });
      return forgejoData && 'version' in forgejoData
    }
  };

  const tests$a = [
    {
      uri: 'https://domain.org/alice/forgejo_proof',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/forgejo_proof/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/other_proof',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice',
      shouldMatch: false
    }
  ];

  var forgejo = /*#__PURE__*/Object.freeze({
    __proto__: null,
    functions: functions$1,
    processURI: processURI$a,
    reURI: reURI$b,
    tests: tests$a
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Gitea service provider ({@link https://docs.keyoxide.org/service-providers/gitea/|Keyoxide docs})
   * @module serviceProviders/gitea
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.gitea.processURI('https://domain.example/alice/repo');
   */


  const reURI$a = /^https:\/\/(.*)\/(.*)\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$9 (uri) {
    const match = uri.match(reURI$a);

    return new ServiceProvider({
      about: {
        id: 'gitea',
        name: 'Gitea',
        homepage: 'https://about.gitea.com'
      },
      profile: {
        display: `${match[2]}@${match[1]}`,
        uri: `https://${match[1]}/${match[2]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$a.toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://${match[1]}/api/v1/repos/${match[2]}/${match[3]}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.EQUALS,
          path: ['description']
        }]
      }
    })
  }

  const tests$9 = [
    {
      uri: 'https://domain.org/alice/gitea_proof',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/gitea_proof/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/other_proof',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice',
      shouldMatch: false
    }
  ];

  var gitea = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$9,
    reURI: reURI$a,
    tests: tests$9
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Gitlab service provider ({@link https://docs.keyoxide.org/service-providers/gitlab/|Keyoxide docs})
   * @module serviceProviders/gitlab
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.gitlab.processURI('https://domain.example/alice/repo');
   */


  const reURI$9 = /^https:\/\/(.*)\/(.*)\/gitlab_proof\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$8 (uri) {
    const match = uri.match(reURI$9);

    return new ServiceProvider({
      about: {
        id: 'gitlab',
        name: 'GitLab',
        homepage: 'https://about.gitlab.com'
      },
      profile: {
        display: `${match[2]}@${match[1]}`,
        uri: `https://${match[1]}/${match[2]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$9.toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: `https://${match[1]}/api/v4/projects/${match[2]}%2Fgitlab_proof`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.EQUALS,
          path: ['description']
        }]
      }
    })
  }

  const tests$8 = [
    {
      uri: 'https://gitlab.domain.org/alice/gitlab_proof',
      shouldMatch: true
    },
    {
      uri: 'https://gitlab.domain.org/alice/gitlab_proof/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice/other_proof',
      shouldMatch: false
    }
  ];

  var gitlab = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$8,
    reURI: reURI$9,
    tests: tests$8
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Github service provider ({@link https://docs.keyoxide.org/service-providers/github/|Keyoxide docs})
   * @module serviceProviders/github
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.github.processURI('https://gist.github.com/alice/title');
   */


  const reURI$8 = /^https:\/\/gist\.github\.com\/(.*)\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$7 (uri) {
    const match = uri.match(reURI$8);

    return new ServiceProvider({
      about: {
        id: 'github',
        name: 'GitHub',
        homepage: 'https://github.com'
      },
      profile: {
        display: match[1],
        uri: `https://github.com/${match[1]}`,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$8.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: `https://api.github.com/gists/${match[2]}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [
          {
            format: ClaimFormat.URI,
            encoding: EntityEncodingFormat.PLAIN,
            relation: ClaimRelation.CONTAINS,
            path: ['files', 'proof.md', 'content']
          },
          {
            format: ClaimFormat.URI,
            encoding: EntityEncodingFormat.PLAIN,
            relation: ClaimRelation.CONTAINS,
            path: ['files', 'openpgp.md', 'content']
          }
        ]
      }
    })
  }

  const tests$7 = [
    {
      uri: 'https://gist.github.com/Alice/123456789',
      shouldMatch: true
    },
    {
      uri: 'https://gist.github.com/Alice/123456789/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/Alice/123456789',
      shouldMatch: false
    }
  ];

  var github = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$7,
    reURI: reURI$8,
    tests: tests$7
  });

  /*
  Copyright 2022 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * ActivityPub service provider ({@link https://docs.keyoxide.org/service-providers/activitypub/|Keyoxide docs})
   * @module serviceProviders/activitypub
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.activitypub.processURI('https://domain.example/@alice');
   */


  const reURI$7 = /^https:\/\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$6 (uri) {
    return new ServiceProvider({
      about: {
        id: 'activitypub',
        name: 'ActivityPub',
        homepage: 'https://activitypub.rocks'
      },
      profile: {
        display: uri,
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$7.toString().toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.ACTIVITYPUB,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: uri
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [
          {
            format: ClaimFormat.URI,
            encoding: EntityEncodingFormat.PLAIN,
            relation: ClaimRelation.CONTAINS,
            path: ['summary']
          },
          {
            format: ClaimFormat.URI,
            encoding: EntityEncodingFormat.PLAIN,
            relation: ClaimRelation.CONTAINS,
            path: ['attachment', 'value']
          },
          {
            format: ClaimFormat.URI,
            encoding: EntityEncodingFormat.PLAIN,
            relation: ClaimRelation.CONTAINS,
            path: ['content']
          }
        ]
      }
    })
  }

  const functions = {
    postprocess: async (/** @type {ServiceProvider} */ claimData, proofData, opts) => {
      switch (proofData.result.type) {
        case 'Note': {
          claimData.profile.uri = proofData.result.attributedTo;
          claimData.profile.display = proofData.result.attributedTo;
          const personData = await fn$a({ url: proofData.result.attributedTo }, opts)
            .catch(_ => null);
          if (personData) {
            claimData.profile.display = `@${personData.preferredUsername}@${new URL(claimData.proof.request.uri).hostname}`;
          }
          break
        }

        case 'Person':
          claimData.profile.display = `@${proofData.result.preferredUsername}@${new URL(claimData.proof.request.uri).hostname}`;
          break
      }

      // Attempt to fetch and process the instance's NodeInfo data
      const nodeinfo = await _processNodeinfo(new URL(claimData.proof.request.uri).hostname);
      if (nodeinfo) {
        claimData.about.name = nodeinfo.software.name;
        claimData.about.id = nodeinfo.software.name;
        claimData.about.homepage = nodeinfo.software.homepage;
      }

      return { claimData, proofData }
    }
  };

  const _processNodeinfo = async (/** @type {string} */ domain) => {
    const nodeinfoRef = await fetch(`https://${domain}/.well-known/nodeinfo`)
      .then(res => {
        if (res.status !== 200) {
          throw new Error('HTTP Status was not 200')
        }
        return res.json()
      })
      .catch(_ => {
        return null
      });

    if (!nodeinfoRef) return null

    // NodeInfo version 2.1
    {
      const nodeinfo = nodeinfoRef.links.find(x => { return x.rel === 'http://nodeinfo.diaspora.software/ns/schema/2.1' });
      if (nodeinfo) {
        return await fetch(nodeinfo.href)
          .then(res => {
            if (res.status !== 200) {
              throw new Error('HTTP Status was not 200')
            }
            return res.json()
          })
          .then(res => {
            return {
              software: {
                name: res.software.name,
                version: res.software.version,
                homepage: res.software.homepage || 'https://activitypub.rocks'
              }
            }
          })
          .catch(_ => {
            return null
          })
      }
    }
    // NodeInfo version 2.0
    {
      const nodeinfo = nodeinfoRef.links.find(x => { return x.rel === 'http://nodeinfo.diaspora.software/ns/schema/2.0' });
      if (nodeinfo) {
        return await fetch(nodeinfo.href)
          .then(res => {
            if (res.status !== 200) {
              throw new Error('HTTP Status was not 200')
            }
            return res.json()
          })
          .then(res => {
            return {
              software: {
                name: res.software.name,
                version: res.software.version,
                homepage: 'https://activitypub.rocks'
              }
            }
          })
          .catch(_ => {
            return null
          })
      }
    }
    // NodeInfo version 1.1
    {
      const nodeinfo = nodeinfoRef.links.find(x => { return x.rel === 'http://nodeinfo.diaspora.software/ns/schema/1.1' });
      if (nodeinfo) {
        return await fetch(nodeinfo.href)
          .then(res => {
            if (res.status !== 200) {
              throw new Error('HTTP Status was not 200')
            }
            return res.json()
          })
          .then(res => {
            return {
              software: {
                name: res.software.name,
                version: res.software.version,
                homepage: 'https://activitypub.rocks'
              }
            }
          })
          .catch(_ => {
            return null
          })
      }
    }
    // NodeInfo version 1.0
    {
      const nodeinfo = nodeinfoRef.links.find(x => { return x.rel === 'http://nodeinfo.diaspora.software/ns/schema/1.0' });
      if (nodeinfo) {
        return await fetch(nodeinfo.href)
          .then(res => {
            if (res.status !== 200) {
              throw new Error('HTTP Status was not 200')
            }
            return res.json()
          })
          .then(res => {
            return {
              software: {
                name: res.software.name,
                version: res.software.version,
                homepage: 'https://activitypub.rocks'
              }
            }
          })
          .catch(_ => {
            return null
          })
      }
    }
  };

  const tests$6 = [
    {
      uri: 'https://domain.org',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/@/alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/@alice',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/@alice/123456',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/u/alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/users/alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/users/alice/123456',
      shouldMatch: true
    },
    {
      uri: 'http://domain.org/alice',
      shouldMatch: false
    }
  ];

  var activitypub = /*#__PURE__*/Object.freeze({
    __proto__: null,
    functions: functions,
    processURI: processURI$6,
    reURI: reURI$7,
    tests: tests$6
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Discourse service provider ({@link https://docs.keyoxide.org/service-providers/discourse/|Keyoxide docs})
   * @module serviceProviders/discourse
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.activitypub.processURI('https://domain.example/u/alice');
   */


  const reURI$6 = /^https:\/\/(.*)\/u\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$5 (uri) {
    const match = uri.match(reURI$6);

    return new ServiceProvider({
      about: {
        id: 'discourse',
        name: 'Discourse',
        homepage: 'https://www.discourse.org'
      },
      profile: {
        display: `${match[2]}@${match[1]}`,
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$6.toString().toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://${match[1]}/u/${match[2]}.json`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['user', 'bio_raw']
        }]
      }
    })
  }

  const tests$5 = [
    {
      uri: 'https://domain.org/u/alice',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/u/alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/alice',
      shouldMatch: false
    }
  ];

  var discourse = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$5,
    reURI: reURI$6,
    tests: tests$5
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Owncast service provider ({@link https://docs.keyoxide.org/service-providers/owncast/|Keyoxide docs})
   * @module serviceProviders/owncast
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.owncast.processURI('https://domain.example');
   */


  const reURI$5 = /^https:\/\/(.*)/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$4 (uri) {
    const match = uri.match(reURI$5);

    return new ServiceProvider({
      about: {
        id: 'owncast',
        name: 'Owncast',
        homepage: 'https://owncast.online'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$5.toString(),
        uriIsAmbiguous: true
      },
      proof: {
        request: {
          uri: `${uri}/api/config`,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: `${uri}/api/config`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.FINGERPRINT,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['socialHandles', 'url']
        }]
      }
    })
  }

  const tests$4 = [
    {
      uri: 'https://live.domain.org',
      shouldMatch: true
    },
    {
      uri: 'https://live.domain.org/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/live',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/live/',
      shouldMatch: true
    }
  ];

  var owncast = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$4,
    reURI: reURI$5,
    tests: tests$4
  });

  /*
  Copyright 2022 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * StackExchange service provider ({@link https://docs.keyoxide.org/service-providers/stackexchange/|Keyoxide docs})
   * @module serviceProviders/stackexchange
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.stackexchange.processURI('https://stackoverflow.com/users/123/alice');
   */


  const reURI$4 = /^https:\/\/(.*(?:askubuntu|mathoverflow|serverfault|stackapps|stackoverflow|superuser)|.+\.stackexchange)\.com\/users\/(\d+)/;
  const reStackExchange = /\.stackexchange$/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$3 (uri) {
    const [, domain, id] = uri.match(reURI$4);
    const site = domain.replace(reStackExchange, '');

    return new ServiceProvider({
      about: {
        id: 'stackexchange',
        name: 'Stack Exchange',
        homepage: 'https://stackexchange.com'
      },
      profile: {
        display: `${id}@${site}`,
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$4.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: `https://${domain}.com/users/${id}?tab=profile`,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: `https://api.stackexchange.com/2.3/users/${id}?site=${site}&filter=!AH)b5JqVyImf`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['items', 'about_me']
        }]
      }
    })
  }

  const tests$3 = [
    {
      uri: 'https://stackoverflow.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://stackoverflow.com/users/1234/alice',
      shouldMatch: true
    },
    {
      uri: 'https://stackoverflow.com/users/1234?tab=topactivity',
      shouldMatch: true
    },
    {
      uri: 'https://stackoverflow.com/users/1234/alice?tab=profile',
      shouldMatch: true
    },
    {
      uri: 'https://meta.stackoverflow.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://pt.stackoverflow.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://pt.meta.stackoverflow.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://serverfault.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://meta.stackexchange.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://gaming.meta.stackexchange.com/users/1234',
      shouldMatch: true
    },
    {
      uri: 'https://stackexchange.com/users/1234',
      shouldMatch: false
    },
    {
      uri: 'https://domain.com/users/1234',
      shouldMatch: false
    },
    {
      uri: 'https://meta.domain.com/users/1234',
      shouldMatch: false
    }

  ];

  var stackexchange = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$3,
    reURI: reURI$4,
    tests: tests$3
  });

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Keybase service provider ({@link https://docs.keyoxide.org/service-providers/keybase/|Keyoxide docs})
   * @module serviceProviders/keybase
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.keybase.processURI('https://keybase.io/alice');
   */


  const reURI$3 = /^https:\/\/keybase.io\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$2 (uri) {
    const match = uri.match(reURI$3);

    return new ServiceProvider({
      about: {
        id: 'keybase',
        name: 'keybase',
        homepage: 'https://keybase.io'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$3.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri: `https://keybase.io/_/api/1.0/user/lookup.json?username=${match[1]}`,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: `https://keybase.io/_/api/1.0/user/lookup.json?username=${match[1]}`,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.FINGERPRINT,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['them', 'public_keys', 'primary', 'key_fingerprint']
        }]
      }
    })
  }

  const tests$2 = [
    {
      uri: 'https://keybase.io/Alice',
      shouldMatch: true
    },
    {
      uri: 'https://keybase.io/Alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/Alice',
      shouldMatch: false
    }
  ];

  var keybase = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$2,
    reURI: reURI$3,
    tests: tests$2
  });

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * OpenCollective service provider ({@link https://docs.keyoxide.org/service-providers/opencollective/|Keyoxide docs})
   * @module serviceProviders/opencollective
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.opencollective.processURI('https://opencollective.com/alice');
   */


  const reURI$2 = /^https:\/\/opencollective\.com\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI$1 (uri) {
    const match = uri.match(reURI$2);

    return new ServiceProvider({
      about: {
        id: 'opencollective',
        name: 'Open Collective',
        homepage: 'https://opencollective.com'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$2.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.GRAPHQL,
          accessRestriction: ProofAccessRestriction.NOCORS,
          data: {
            url: 'https://api.opencollective.com/graphql/v2',
            query: `{ "query": "query { account(slug: \\"${match[1]}\\") { longDescription } }" }`
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['data', 'account', 'longDescription']
        }]
      }
    })
  }

  const tests$1 = [
    {
      uri: 'https://opencollective.com/Alice',
      shouldMatch: true
    },
    {
      uri: 'https://opencollective.com/Alice/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/Alice',
      shouldMatch: false
    }
  ];

  var opencollective = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI$1,
    reURI: reURI$2,
    tests: tests$1
  });

  /*
  Copyright 2023 Tim Haase

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * ORCiD service provider ({@link https://docs.keyoxide.org/service-providers/orcid/|Keyoxide docs})
   * @module serviceProviders/orcid
   * @example
   * import { ServiceProviderDefinitions } from 'doipjs';
   * const sp = ServiceProviderDefinitions.data.orcid.processURI('https://orcid.org/123-456-789-123');
   */


  const reURI$1 = /^https:\/\/orcid\.org\/(.*)\/?/;

  /**
   * @function
   * @param {string} uri - Claim URI to process
   * @returns {ServiceProvider} The service provider information based on the claim URI
   */
  function processURI (uri) {
    const match = uri.match(reURI$1);

    return new ServiceProvider({
      about: {
        id: 'orcid',
        name: 'ORCiD',
        homepage: 'https://orcid.org/'
      },
      profile: {
        display: match[1],
        uri,
        qr: null
      },
      claim: {
        uriRegularExpression: reURI$1.toString(),
        uriIsAmbiguous: false
      },
      proof: {
        request: {
          uri,
          fetcher: Fetcher.HTTP,
          accessRestriction: ProofAccessRestriction.NONE,
          data: {
            url: uri,
            format: ProofFormat.JSON
          }
        },
        response: {
          format: ProofFormat.JSON
        },
        target: [{
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.CONTAINS,
          path: ['person', 'biography', 'content']
        }, {
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.EQUALS,
          path: ['person', 'researcher-urls', 'researcher-url', 'url', 'value']
        }, {
          format: ClaimFormat.URI,
          encoding: EntityEncodingFormat.PLAIN,
          relation: ClaimRelation.EQUALS,
          path: ['person', 'keywords', 'keyword', 'content']
        }]
      }
    })
  }

  const tests = [
    {
      uri: 'https://orcid.org/0000-0000-0000-0000',
      shouldMatch: true
    },
    {
      uri: 'https://orcid.org/0000-0000-0000-0000/',
      shouldMatch: true
    },
    {
      uri: 'https://domain.org/0000-0000-0000-0000',
      shouldMatch: false
    }
  ];

  var orcid = /*#__PURE__*/Object.freeze({
    __proto__: null,
    processURI: processURI,
    reURI: reURI$1,
    tests: tests
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  const _data = {
    aspe: aspe$1,
    openpgp: openpgp$1,
    dns: dns$3,
    irc: irc$2,
    xmpp: xmpp$2,
    matrix: matrix$1,
    telegram: telegram$1,
    twitter,
    reddit,
    liberapay,
    lichess,
    hackernews,
    lobsters,
    forem,
    forgejo,
    gitea,
    gitlab,
    github,
    activitypub,
    discourse,
    owncast,
    stackexchange,
    keybase,
    opencollective,
    orcid
  };

  const list = Object.keys(_data);

  /*! OpenPGP.js v5.11.0 - 2023-10-25 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
  const e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=Symbol("doneWritingPromise"),r=Symbol("doneWritingResolve"),i=Symbol("doneWritingReject"),n=Symbol("readingIndex");class a extends Array{constructor(){super(),this[t]=new Promise(((e,t)=>{this[r]=e,this[i]=t;})),this[t].catch((()=>{}));}}function s(e){return e&&e.getReader&&Array.isArray(e)}function o(e){if(!s(e)){const t=e.getWriter(),r=t.releaseLock;return t.releaseLock=()=>{t.closed.catch((function(){})),r.call(t);},t}this.stream=e;}a.prototype.getReader=function(){return void 0===this[n]&&(this[n]=0),{read:async()=>(await this[t],this[n]===this.length?{value:void 0,done:!0}:{value:this[this[n]++],done:!1})}},a.prototype.readToEnd=async function(e){await this[t];const r=e(this.slice(this[n]));return this.length=0,r},a.prototype.clone=function(){const e=new a;return e[t]=this[t].then((()=>{e.push(...this);})),e},o.prototype.write=async function(e){this.stream.push(e);},o.prototype.close=async function(){this.stream[r]();},o.prototype.abort=async function(e){return this.stream[i](e),e},o.prototype.releaseLock=function(){};const c="object"==typeof e.process&&"object"==typeof e.process.versions,u=c&&void 0;function h(t){return s(t)?"array":e.ReadableStream&&e.ReadableStream.prototype.isPrototypeOf(t)?"web":k&&k.prototype.isPrototypeOf(t)?"ponyfill":u&&u.prototype.isPrototypeOf(t)?"node":!(!t||!t.getReader)&&"web-like"}function d(e){return Uint8Array.prototype.isPrototypeOf(e)}function f(e){if(1===e.length)return e[0];let t=0;for(let r=0;r<e.length;r++){if(!d(e[r]))throw Error("concatUint8Array: Data must be in the form of a Uint8Array");t+=e[r].length;}const r=new Uint8Array(t);let i=0;return e.forEach((function(e){r.set(e,i),i+=e.length;})),r}const l=c&&void 0,p=c&&void 0;let y,b;if(p){y=function(e){let t=!1;return new k({start(r){e.pause(),e.on("data",(i=>{t||(l.isBuffer(i)&&(i=new Uint8Array(i.buffer,i.byteOffset,i.byteLength)),r.enqueue(i),e.pause());})),e.on("end",(()=>{t||r.close();})),e.on("error",(e=>r.error(e)));},pull(){e.resume();},cancel(r){t=!0,e.destroy(r);}})};class e extends p{constructor(e,t){super(t),this._reader=C(e);}async _read(e){try{for(;;){const{done:e,value:t}=await this._reader.read();if(e){this.push(null);break}if(!this.push(t))break}}catch(e){this.destroy(e);}}async _destroy(e,t){this._reader.cancel(e).then(t,t);}}b=function(t,r){return new e(t,r)};}const m=new WeakSet,g=Symbol("externalBuffer");function w(e){if(this.stream=e,e[g]&&(this[g]=e[g].slice()),s(e)){const t=e.getReader();return this._read=t.read.bind(t),this._releaseLock=()=>{},void(this._cancel=async()=>{})}let t=h(e);if("node"===t&&(e=y(e)),t){const t=e.getReader();return this._read=t.read.bind(t),this._releaseLock=()=>{t.closed.catch((function(){})),t.releaseLock();},void(this._cancel=t.cancel.bind(t))}let r=!1;this._read=async()=>r||m.has(e)?{value:void 0,done:!0}:(r=!0,{value:e,done:!1}),this._releaseLock=()=>{if(r)try{m.add(e);}catch(e){}};}w.prototype.read=async function(){if(this[g]&&this[g].length){return {done:!1,value:this[g].shift()}}return this._read()},w.prototype.releaseLock=function(){this[g]&&(this.stream[g]=this[g]),this._releaseLock();},w.prototype.cancel=function(e){return this._cancel(e)},w.prototype.readLine=async function(){let e,t=[];for(;!e;){let{done:r,value:i}=await this.read();if(i+="",r)return t.length?K(t):void 0;const n=i.indexOf("\n")+1;n&&(e=K(t.concat(i.substr(0,n))),t=[]),n!==i.length&&t.push(i.substr(n));}return this.unshift(...t),e},w.prototype.readByte=async function(){const{done:e,value:t}=await this.read();if(e)return;const r=t[0];return this.unshift(L(t,1)),r},w.prototype.readBytes=async function(e){const t=[];let r=0;for(;;){const{done:i,value:n}=await this.read();if(i)return t.length?K(t):void 0;if(t.push(n),r+=n.length,r>=e){const r=K(t);return this.unshift(L(r,e)),L(r,0,e)}}},w.prototype.peekBytes=async function(e){const t=await this.readBytes(e);return this.unshift(t),t},w.prototype.unshift=function(...e){this[g]||(this[g]=[]),1===e.length&&d(e[0])&&this[g].length&&e[0].length&&this[g][0].byteOffset>=e[0].length?this[g][0]=new Uint8Array(this[g][0].buffer,this[g][0].byteOffset-e[0].length,this[g][0].byteLength+e[0].length):this[g].unshift(...e.filter((e=>e&&e.length)));},w.prototype.readToEnd=async function(e=K){const t=[];for(;;){const{done:e,value:r}=await this.read();if(e)break;t.push(r);}return e(t)};let v$1,{ReadableStream:k,WritableStream:A,TransformStream:S}=e;const P=c&&void 0;function x(e){let t=h(e);return "node"===t?y(e):"web"===t&&v$1?v$1(e):t?e:new k({start(t){t.enqueue(e),t.close();}})}function M(e){if(h(e))return e;const t=new a;return (async()=>{const r=D(t);await r.write(e),await r.close();})(),t}function K(e){return e.some((e=>h(e)&&!s(e)))?function(e){e=e.map(x);const t=I((async function(e){await Promise.all(i.map((t=>j(t,e))));}));let r=Promise.resolve();const i=e.map(((i,n)=>T(i,((i,a)=>(r=r.then((()=>U(i,t.writable,{preventClose:n!==e.length-1}))),r)))));return t.readable}(e):e.some((e=>s(e)))?function(e){const t=new a;let r=Promise.resolve();return e.forEach(((i,n)=>(r=r.then((()=>U(i,t,{preventClose:n!==e.length-1}))),r))),t}(e):"string"==typeof e[0]?e.join(""):P&&P.isBuffer(e[0])?P.concat(e):f(e)}function C(e){return new w(e)}function D(e){return new o(e)}async function U(e,t,{preventClose:r=!1,preventAbort:i=!1,preventCancel:n=!1}={}){if(h(e)&&!s(e)){e=x(e);try{if(e[g]){const r=D(t);for(let t=0;t<e[g].length;t++)await r.ready,await r.write(e[g][t]);r.releaseLock();}await e.pipeTo(t,{preventClose:r,preventAbort:i,preventCancel:n});}catch(e){}return}const a=C(e=M(e)),o=D(t);try{for(;;){await o.ready;const{done:e,value:t}=await a.read();if(e){r||await o.close();break}await o.write(t);}}catch(e){i||await o.abort(e);}finally{a.releaseLock(),o.releaseLock();}}function R(e,t){const r=new S(t);return U(e,r.writable),r.readable}function I(e){let t,r,i=!1;return {readable:new k({start(e){r=e;},pull(){t?t():i=!0;},cancel:e},{highWaterMark:0}),writable:new A({write:async function(e){r.enqueue(e),i?i=!1:(await new Promise((e=>{t=e;})),t=null);},close:r.close.bind(r),abort:r.error.bind(r)})}}function B(e,t=(()=>{}),r=(()=>{})){if(s(e)){const i=new a;return (async()=>{const n=D(i);try{const i=await N(e),a=t(i),s=r();let o;o=void 0!==a&&void 0!==s?K([a,s]):void 0!==a?a:s,await n.write(o),await n.close();}catch(e){await n.abort(e);}})(),i}if(h(e))return R(e,{async transform(e,r){try{const i=await t(e);void 0!==i&&r.enqueue(i);}catch(e){r.error(e);}},async flush(e){try{const t=await r();void 0!==t&&e.enqueue(t);}catch(t){e.error(t);}}});const i=t(e),n=r();return void 0!==i&&void 0!==n?K([i,n]):void 0!==i?i:n}function T(e,t){if(h(e)&&!s(e)){let r;const i=new S({start(e){r=e;}}),n=U(e,i.writable),a=I((async function(e){r.error(e),await n,await new Promise(setTimeout);}));return t(i.readable,a.writable),a.readable}e=M(e);const r=new a;return t(e,r),r}function q(e){if(s(e))return e.clone();if(h(e)){const t=function(e){if(s(e))throw Error("ArrayStream cannot be tee()d, use clone() instead");if(h(e)){const t=x(e).tee();return t[0][g]=t[1][g]=e[g],t}return [L(e),L(e)]}(e);return O(e,t[0]),t[1]}return L(e)}function F(e){return s(e)?q(e):h(e)?new k({start(t){const r=T(e,(async(e,r)=>{const i=C(e),n=D(r);try{for(;;){await n.ready;const{done:e,value:r}=await i.read();if(e){try{t.close();}catch(e){}return void await n.close()}try{t.enqueue(r);}catch(e){}await n.write(r);}}catch(e){t.error(e),await n.abort(e);}}));O(e,r);}}):L(e)}function O(e,t){Object.entries(Object.getOwnPropertyDescriptors(e.constructor.prototype)).forEach((([r,i])=>{"constructor"!==r&&(i.value?i.value=i.value.bind(t):i.get=i.get.bind(t),Object.defineProperty(e,r,i));}));}function L(e,t=0,r=1/0){if(s(e))throw Error("Not implemented");if(h(e)){if(t>=0&&r>=0){let i=0;return R(e,{transform(e,n){i<r?(i+e.length>=t&&n.enqueue(L(e,Math.max(t-i,0),r-i)),i+=e.length):n.terminate();}})}if(t<0&&(r<0||r===1/0)){let i=[];return B(e,(e=>{e.length>=-t?i=[e]:i.push(e);}),(()=>L(K(i),t,r)))}if(0===t&&r<0){let i;return B(e,(e=>{const n=i?K([i,e]):e;if(n.length>=-r)return i=L(n,r),L(n,t,r);i=n;}))}return console.warn(`stream.slice(input, ${t}, ${r}) not implemented efficiently.`),H((async()=>L(await N(e),t,r)))}return e[g]&&(e=K(e[g].concat([e]))),!d(e)||P&&P.isBuffer(e)?e.slice(t,r):(r===1/0&&(r=e.length),e.subarray(t,r))}async function N(e,t=K){return s(e)?e.readToEnd(t):h(e)?C(e).readToEnd(t):e}async function j(e,t){if(h(e)){if(e.cancel)return e.cancel(t);if(e.destroy)return e.destroy(t),await new Promise(setTimeout),t}}function H(e){const t=new a;return (async()=>{const r=D(t);try{await r.write(await e()),await r.close();}catch(e){await r.abort(e);}})(),t}class W{constructor(e){if(void 0===e)throw Error("Invalid BigInteger input");if(e instanceof Uint8Array){const t=e,r=Array(t.length);for(let e=0;e<t.length;e++){const i=t[e].toString(16);r[e]=t[e]<=15?"0"+i:i;}this.value=BigInt("0x0"+r.join(""));}else this.value=BigInt(e);}clone(){return new W(this.value)}iinc(){return this.value++,this}inc(){return this.clone().iinc()}idec(){return this.value--,this}dec(){return this.clone().idec()}iadd(e){return this.value+=e.value,this}add(e){return this.clone().iadd(e)}isub(e){return this.value-=e.value,this}sub(e){return this.clone().isub(e)}imul(e){return this.value*=e.value,this}mul(e){return this.clone().imul(e)}imod(e){return this.value%=e.value,this.isNegative()&&this.iadd(e),this}mod(e){return this.clone().imod(e)}modExp(e,t){if(t.isZero())throw Error("Modulo cannot be zero");if(t.isOne())return new W(0);if(e.isNegative())throw Error("Unsopported negative exponent");let r=e.value,i=this.value;i%=t.value;let n=BigInt(1);for(;r>BigInt(0);){const e=r&BigInt(1);r>>=BigInt(1);const a=n*i%t.value;n=e?a:n,i=i*i%t.value;}return new W(n)}modInv(e){const{gcd:t,x:r}=this._egcd(e);if(!t.isOne())throw Error("Inverse does not exist");return r.add(e).mod(e)}_egcd(e){let t=BigInt(0),r=BigInt(1),i=BigInt(1),n=BigInt(0),a=this.value;for(e=e.value;e!==BigInt(0);){const s=a/e;let o=t;t=i-s*t,i=o,o=r,r=n-s*r,n=o,o=e,e=a%e,a=o;}return {x:new W(i),y:new W(n),gcd:new W(a)}}gcd(e){let t=this.value;for(e=e.value;e!==BigInt(0);){const r=e;e=t%e,t=r;}return new W(t)}ileftShift(e){return this.value<<=e.value,this}leftShift(e){return this.clone().ileftShift(e)}irightShift(e){return this.value>>=e.value,this}rightShift(e){return this.clone().irightShift(e)}equal(e){return this.value===e.value}lt(e){return this.value<e.value}lte(e){return this.value<=e.value}gt(e){return this.value>e.value}gte(e){return this.value>=e.value}isZero(){return this.value===BigInt(0)}isOne(){return this.value===BigInt(1)}isNegative(){return this.value<BigInt(0)}isEven(){return !(this.value&BigInt(1))}abs(){const e=this.clone();return this.isNegative()&&(e.value=-e.value),e}toString(){return this.value.toString()}toNumber(){const e=Number(this.value);if(e>Number.MAX_SAFE_INTEGER)throw Error("Number can only safely store up to 53 bits");return e}getBit(e){return (this.value>>BigInt(e)&BigInt(1))===BigInt(0)?0:1}bitLength(){const e=new W(0),t=new W(1),r=new W(-1),i=this.isNegative()?r:e;let n=1;const a=this.clone();for(;!a.irightShift(t).equal(i);)n++;return n}byteLength(){const e=new W(0),t=new W(-1),r=this.isNegative()?t:e,i=new W(8);let n=1;const a=this.clone();for(;!a.irightShift(i).equal(r);)n++;return n}toUint8Array(e="be",t){let r=this.value.toString(16);r.length%2==1&&(r="0"+r);const i=r.length/2,n=new Uint8Array(t||i),a=t?t-i:0;let s=0;for(;s<i;)n[s+a]=parseInt(r.slice(2*s,2*s+2),16),s++;return "be"!==e&&n.reverse(),n}}const G=()=>"undefined"!=typeof BigInt;const V=Symbol("byValue");var $={curve:{p256:"p256","P-256":"p256",secp256r1:"p256",prime256v1:"p256","1.2.840.10045.3.1.7":"p256","2a8648ce3d030107":"p256","2A8648CE3D030107":"p256",p384:"p384","P-384":"p384",secp384r1:"p384","1.3.132.0.34":"p384","2b81040022":"p384","2B81040022":"p384",p521:"p521","P-521":"p521",secp521r1:"p521","1.3.132.0.35":"p521","2b81040023":"p521","2B81040023":"p521",secp256k1:"secp256k1","1.3.132.0.10":"secp256k1","2b8104000a":"secp256k1","2B8104000A":"secp256k1",ed25519Legacy:"ed25519",ED25519:"ed25519",ed25519:"ed25519",Ed25519:"ed25519","1.3.6.1.4.1.11591.15.1":"ed25519","2b06010401da470f01":"ed25519","2B06010401DA470F01":"ed25519",curve25519Legacy:"curve25519",X25519:"curve25519",cv25519:"curve25519",curve25519:"curve25519",Curve25519:"curve25519","1.3.6.1.4.1.3029.1.5.1":"curve25519","2b060104019755010501":"curve25519","2B060104019755010501":"curve25519",brainpoolP256r1:"brainpoolP256r1","1.3.36.3.3.2.8.1.1.7":"brainpoolP256r1","2b2403030208010107":"brainpoolP256r1","2B2403030208010107":"brainpoolP256r1",brainpoolP384r1:"brainpoolP384r1","1.3.36.3.3.2.8.1.1.11":"brainpoolP384r1","2b240303020801010b":"brainpoolP384r1","2B240303020801010B":"brainpoolP384r1",brainpoolP512r1:"brainpoolP512r1","1.3.36.3.3.2.8.1.1.13":"brainpoolP512r1","2b240303020801010d":"brainpoolP512r1","2B240303020801010D":"brainpoolP512r1"},s2k:{simple:0,salted:1,iterated:3,gnu:101},publicKey:{rsaEncryptSign:1,rsaEncrypt:2,rsaSign:3,elgamal:16,dsa:17,ecdh:18,ecdsa:19,eddsaLegacy:22,ed25519Legacy:22,eddsa:22,aedh:23,aedsa:24,x25519:25,x448:26,ed25519:27,ed448:28},symmetric:{plaintext:0,idea:1,tripledes:2,cast5:3,blowfish:4,aes128:7,aes192:8,aes256:9,twofish:10},compression:{uncompressed:0,zip:1,zlib:2,bzip2:3},hash:{md5:1,sha1:2,ripemd:3,sha256:8,sha384:9,sha512:10,sha224:11},webHash:{"SHA-1":2,"SHA-256":8,"SHA-384":9,"SHA-512":10},aead:{eax:1,ocb:2,experimentalGCM:100},packet:{publicKeyEncryptedSessionKey:1,signature:2,symEncryptedSessionKey:3,onePassSignature:4,secretKey:5,publicKey:6,secretSubkey:7,compressedData:8,symmetricallyEncryptedData:9,marker:10,literalData:11,trust:12,userID:13,publicSubkey:14,userAttribute:17,symEncryptedIntegrityProtectedData:18,modificationDetectionCode:19,aeadEncryptedData:20},literal:{binary:98,text:116,utf8:117,mime:109},signature:{binary:0,text:1,standalone:2,certGeneric:16,certPersona:17,certCasual:18,certPositive:19,certRevocation:48,subkeyBinding:24,keyBinding:25,key:31,keyRevocation:32,subkeyRevocation:40,timestamp:64,thirdParty:80},signatureSubpacket:{signatureCreationTime:2,signatureExpirationTime:3,exportableCertification:4,trustSignature:5,regularExpression:6,revocable:7,keyExpirationTime:9,placeholderBackwardsCompatibility:10,preferredSymmetricAlgorithms:11,revocationKey:12,issuer:16,notationData:20,preferredHashAlgorithms:21,preferredCompressionAlgorithms:22,keyServerPreferences:23,preferredKeyServer:24,primaryUserID:25,policyURI:26,keyFlags:27,signersUserID:28,reasonForRevocation:29,features:30,signatureTarget:31,embeddedSignature:32,issuerFingerprint:33,preferredAEADAlgorithms:34},keyFlags:{certifyKeys:1,signData:2,encryptCommunication:4,encryptStorage:8,splitPrivateKey:16,authentication:32,sharedPrivateKey:128},armor:{multipartSection:0,multipartLast:1,signed:2,message:3,publicKey:4,privateKey:5,signature:6},reasonForRevocation:{noReason:0,keySuperseded:1,keyCompromised:2,keyRetired:3,userIDInvalid:32},features:{modificationDetection:1,aead:2,v5Keys:4},write:function(e,t){if("number"==typeof t&&(t=this.read(e,t)),void 0!==e[t])return e[t];throw Error("Invalid enum value.")},read:function(e,t){if(e[V]||(e[V]=[],Object.entries(e).forEach((([t,r])=>{e[V][r]=t;}))),void 0!==e[V][t])return e[V][t];throw Error("Invalid enum value.")}};const Z=(()=>{try{return "development"===process.env.NODE_ENV}catch(e){}return !1})(),X={isString:function(e){return "string"==typeof e||e instanceof String},isArray:function(e){return e instanceof Array},isUint8Array:d,isStream:h,readNumber:function(e){let t=0;for(let r=0;r<e.length;r++)t+=256**r*e[e.length-1-r];return t},writeNumber:function(e,t){const r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e>>8*(t-i-1)&255;return r},readDate:function(e){const t=X.readNumber(e);return new Date(1e3*t)},writeDate:function(e){const t=Math.floor(e.getTime()/1e3);return X.writeNumber(t,4)},normalizeDate:function(e=Date.now()){return null===e||e===1/0?e:new Date(1e3*Math.floor(+e/1e3))},readMPI:function(e){const t=(e[0]<<8|e[1])+7>>>3;return e.subarray(2,2+t)},leftPad(e,t){const r=new Uint8Array(t),i=t-e.length;return r.set(e,i),r},uint8ArrayToMPI:function(e){const t=X.uint8ArrayBitLength(e);if(0===t)throw Error("Zero MPI");const r=e.subarray(e.length-Math.ceil(t/8)),i=new Uint8Array([(65280&t)>>8,255&t]);return X.concatUint8Array([i,r])},uint8ArrayBitLength:function(e){let t;for(t=0;t<e.length&&0===e[t];t++);if(t===e.length)return 0;const r=e.subarray(t);return 8*(r.length-1)+X.nbits(r[0])},hexToUint8Array:function(e){const t=new Uint8Array(e.length>>1);for(let r=0;r<e.length>>1;r++)t[r]=parseInt(e.substr(r<<1,2),16);return t},uint8ArrayToHex:function(e){const t=[],r=e.length;let i,n=0;for(;n<r;){for(i=e[n++].toString(16);i.length<2;)i="0"+i;t.push(""+i);}return t.join("")},stringToUint8Array:function(e){return B(e,(e=>{if(!X.isString(e))throw Error("stringToUint8Array: Data must be in the form of a string");const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t}))},uint8ArrayToString:function(e){const t=[],r=16384,i=(e=new Uint8Array(e)).length;for(let n=0;n<i;n+=r)t.push(String.fromCharCode.apply(String,e.subarray(n,n+r<i?n+r:i)));return t.join("")},encodeUTF8:function(e){const t=new TextEncoder("utf-8");function r(e,r=!1){return t.encode(e,{stream:!r})}return B(e,r,(()=>r("",!0)))},decodeUTF8:function(e){const t=new TextDecoder("utf-8");function r(e,r=!1){return t.decode(e,{stream:!r})}return B(e,r,(()=>r(new Uint8Array,!0)))},concat:K,concatUint8Array:f,equalsUint8Array:function(e,t){if(!X.isUint8Array(e)||!X.isUint8Array(t))throw Error("Data must be in the form of a Uint8Array");if(e.length!==t.length)return !1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return !1;return !0},writeChecksum:function(e){let t=0;for(let r=0;r<e.length;r++)t=t+e[r]&65535;return X.writeNumber(t,2)},printDebug:function(e){Z&&console.log("[OpenPGP.js debug]",e);},printDebugError:function(e){Z&&console.error("[OpenPGP.js debug]",e);},nbits:function(e){let t=1,r=e>>>16;return 0!==r&&(e=r,t+=16),r=e>>8,0!==r&&(e=r,t+=8),r=e>>4,0!==r&&(e=r,t+=4),r=e>>2,0!==r&&(e=r,t+=2),r=e>>1,0!==r&&(e=r,t+=1),t},double:function(e){const t=new Uint8Array(e.length),r=e.length-1;for(let i=0;i<r;i++)t[i]=e[i]<<1^e[i+1]>>7;return t[r]=e[r]<<1^135*(e[0]>>7),t},shiftRight:function(e,t){if(t)for(let r=e.length-1;r>=0;r--)e[r]>>=t,r>0&&(e[r]|=e[r-1]<<8-t);return e},getWebCrypto:function(){return void 0!==e&&e.crypto&&e.crypto.subtle},getBigInteger:async function(){if(G())return W;{const{default:e}=await Promise.resolve().then((function(){return uy}));return e}},getNodeCrypto:function(){},getNodeZlib:function(){},getNodeBuffer:function(){return {}.Buffer},getHardwareConcurrency:function(){if("undefined"!=typeof navigator)return navigator.hardwareConcurrency||1;return (void 0).cpus().length},isEmailAddress:function(e){if(!X.isString(e))return !1;return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+([a-zA-Z]{2,}[0-9]*|xn--[a-zA-Z\-0-9]+)))$/.test(e)},canonicalizeEOL:function(e){let t=!1;return B(e,(e=>{let r;t&&(e=X.concatUint8Array([new Uint8Array([13]),e])),13===e[e.length-1]?(t=!0,e=e.subarray(0,-1)):t=!1;const i=[];for(let t=0;r=e.indexOf(10,t)+1,r;t=r)13!==e[r-2]&&i.push(r);if(!i.length)return e;const n=new Uint8Array(e.length+i.length);let a=0;for(let t=0;t<i.length;t++){const r=e.subarray(i[t-1]||0,i[t]);n.set(r,a),a+=r.length,n[a-1]=13,n[a]=10,a++;}return n.set(e.subarray(i[i.length-1]||0),a),n}),(()=>t?new Uint8Array([13]):void 0))},nativeEOL:function(e){let t=!1;return B(e,(e=>{let r;13===(e=t&&10!==e[0]?X.concatUint8Array([new Uint8Array([13]),e]):new Uint8Array(e))[e.length-1]?(t=!0,e=e.subarray(0,-1)):t=!1;let i=0;for(let t=0;t!==e.length;t=r){r=e.indexOf(13,t)+1,r||(r=e.length);const n=r-(10===e[r]?1:0);t&&e.copyWithin(i,t,n),i+=n-t;}return e.subarray(0,i)}),(()=>t?new Uint8Array([13]):void 0))},removeTrailingSpaces:function(e){return e.split("\n").map((e=>{let t=e.length-1;for(;t>=0&&(" "===e[t]||"\t"===e[t]||"\r"===e[t]);t--);return e.substr(0,t+1)})).join("\n")},wrapError:function(e,t){if(!t)return Error(e);try{t.message=e+": "+t.message;}catch(e){}return t},constructAllowedPackets:function(e){const t={};return e.forEach((e=>{if(!e.tag)throw Error("Invalid input: expected a packet class");t[e.tag]=e;})),t},anyPromise:function(e){return new Promise((async(t,r)=>{let i;await Promise.all(e.map((async e=>{try{t(await e);}catch(e){i=e;}}))),r(i);}))},selectUint8Array:function(e,t,r){const i=Math.max(t.length,r.length),n=new Uint8Array(i);let a=0;for(let i=0;i<n.length;i++)n[i]=t[i]&256-e|r[i]&255+e,a+=e&i<t.length|1-e&i<r.length;return n.subarray(0,a)},selectUint8:function(e,t,r){return t&256-e|r&255+e},isAES:function(e){return e===$.symmetric.aes128||e===$.symmetric.aes192||e===$.symmetric.aes256}},Y=X.getNodeBuffer();let Q,J;function ee(e){let t=new Uint8Array;return B(e,(e=>{t=X.concatUint8Array([t,e]);const r=[],i=Math.floor(t.length/45),n=45*i,a=Q(t.subarray(0,n));for(let e=0;e<i;e++)r.push(a.substr(60*e,60)),r.push("\n");return t=t.subarray(n),r.join("")}),(()=>t.length?Q(t)+"\n":""))}function te(e){let t="";return B(e,(e=>{t+=e;let r=0;const i=[" ","\t","\r","\n"];for(let e=0;e<i.length;e++){const n=i[e];for(let e=t.indexOf(n);-1!==e;e=t.indexOf(n,e+1))r++;}let n=t.length;for(;n>0&&(n-r)%4!=0;n--)i.includes(t[n])&&r--;const a=J(t.substr(0,n));return t=t.substr(n),a}),(()=>J(t)))}function re(e){return te(e.replace(/-/g,"+").replace(/_/g,"/"))}function ie(e,t){let r=ee(e).replace(/[\r\n]/g,"");return t&&(r=r.replace(/[+]/g,"-").replace(/[/]/g,"_").replace(/[=]/g,"")),r}Y?(Q=e=>Y.from(e).toString("base64"),J=e=>{const t=Y.from(e,"base64");return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}):(Q=e=>btoa(X.uint8ArrayToString(e)),J=e=>X.stringToUint8Array(atob(e)));var ne={preferredHashAlgorithm:$.hash.sha256,preferredSymmetricAlgorithm:$.symmetric.aes256,preferredCompressionAlgorithm:$.compression.uncompressed,deflateLevel:6,aeadProtect:!1,preferredAEADAlgorithm:$.aead.eax,aeadChunkSizeByte:12,v5Keys:!1,s2kIterationCountByte:224,allowUnauthenticatedMessages:!1,allowUnauthenticatedStream:!1,checksumRequired:!1,minRSABits:2047,passwordCollisionCheck:!1,revocationsExpire:!1,allowInsecureDecryptionWithSigningKeys:!1,allowInsecureVerificationWithReformattedKeys:!1,constantTimePKCS1Decryption:!1,constantTimePKCS1DecryptionSupportedSymmetricAlgorithms:new Set([$.symmetric.aes128,$.symmetric.aes192,$.symmetric.aes256]),minBytesForWebCrypto:1e3,ignoreUnsupportedPackets:!0,ignoreMalformedPackets:!1,additionalAllowedPackets:[],showVersion:!1,showComment:!1,versionString:"OpenPGP.js 5.11.0",commentString:"https://openpgpjs.org",maxUserIDLength:5120,knownNotations:[],useIndutnyElliptic:!0,rejectHashAlgorithms:new Set([$.hash.md5,$.hash.ripemd]),rejectMessageHashAlgorithms:new Set([$.hash.md5,$.hash.ripemd,$.hash.sha1]),rejectPublicKeyAlgorithms:new Set([$.publicKey.elgamal,$.publicKey.dsa]),rejectCurves:new Set([$.curve.secp256k1])};function ae(e){const t=e.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);if(!t)throw Error("Unknown ASCII armor type");return /MESSAGE, PART \d+\/\d+/.test(t[1])?$.armor.multipartSection:/MESSAGE, PART \d+/.test(t[1])?$.armor.multipartLast:/SIGNED MESSAGE/.test(t[1])?$.armor.signed:/MESSAGE/.test(t[1])?$.armor.message:/PUBLIC KEY BLOCK/.test(t[1])?$.armor.publicKey:/PRIVATE KEY BLOCK/.test(t[1])?$.armor.privateKey:/SIGNATURE/.test(t[1])?$.armor.signature:void 0}function se(e,t){let r="";return t.showVersion&&(r+="Version: "+t.versionString+"\n"),t.showComment&&(r+="Comment: "+t.commentString+"\n"),e&&(r+="Comment: "+e+"\n"),r+="\n",r}function oe(e){return ee(function(e){let t=13501623;return B(e,(e=>{const r=ue?Math.floor(e.length/4):0,i=new Uint32Array(e.buffer,e.byteOffset,r);for(let e=0;e<r;e++)t^=i[e],t=ce[0][t>>24&255]^ce[1][t>>16&255]^ce[2][t>>8&255]^ce[3][t>>0&255];for(let i=4*r;i<e.length;i++)t=t>>8^ce[0][255&t^e[i]];}),(()=>new Uint8Array([t,t>>8,t>>16])))}(e))}const ce=[Array(255),Array(255),Array(255),Array(255)];for(let e=0;e<=255;e++){let t=e<<16;for(let e=0;e<8;e++)t=t<<1^(0!=(8388608&t)?8801531:0);ce[0][e]=(16711680&t)>>16|65280&t|(255&t)<<16;}for(let e=0;e<=255;e++)ce[1][e]=ce[0][e]>>8^ce[0][255&ce[0][e]];for(let e=0;e<=255;e++)ce[2][e]=ce[1][e]>>8^ce[0][255&ce[1][e]];for(let e=0;e<=255;e++)ce[3][e]=ce[2][e]>>8^ce[0][255&ce[2][e]];const ue=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,255,!0),255===new Int16Array(e)[0]}();function he(e){for(let t=0;t<e.length;t++)/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(e[t])||X.printDebugError(Error("Improperly formatted armor header: "+e[t])),/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(e[t])||X.printDebugError(Error("Unknown header: "+e[t]));}function de(e){let t=e,r="";const i=e.lastIndexOf("=");return i>=0&&i!==e.length-1&&(t=e.slice(0,i),r=e.slice(i+1).substr(0,4)),{body:t,checksum:r}}function fe(e,t=ne){return new Promise((async(r,i)=>{try{const n=/^-----[^-]+-----$/m,a=/^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;let s;const o=[];let c,u,h,d=o,f=[],l=te(T(e,(async(e,t)=>{const p=C(e);try{for(;;){let e=await p.readLine();if(void 0===e)throw Error("Misformed armored text");if(e=X.removeTrailingSpaces(e.replace(/[\r\n]/g,"")),s)if(c)u||2!==s||(n.test(e)?(f=f.join("\r\n"),u=!0,he(d),d=[],c=!1):f.push(e.replace(/^- /,"")));else if(n.test(e)&&i(Error("Mandatory blank line missing between armor headers and armor data")),a.test(e)){if(he(d),c=!0,u||2!==s){r({text:f,data:l,headers:o,type:s});break}}else d.push(e);else n.test(e)&&(s=ae(e));}}catch(e){return void i(e)}const y=D(t);try{for(;;){await y.ready;const{done:e,value:t}=await p.read();if(e)throw Error("Misformed armored text");const r=t+"";if(-1!==r.indexOf("=")||-1!==r.indexOf("-")){let e=await p.readToEnd();e.length||(e=""),e=r+e,e=X.removeTrailingSpaces(e.replace(/\r/g,""));const t=e.split(n);if(1===t.length)throw Error("Misformed armored text");const i=de(t[0].slice(0,-1));h=i.checksum,await y.write(i.body);break}await y.write(r);}await y.ready,await y.close();}catch(e){await y.abort(e);}})));l=T(l,(async(e,r)=>{const i=N(oe(F(e)));i.catch((()=>{})),await U(e,r,{preventClose:!0});const n=D(r);try{const e=(await i).replace("\n","");if(h!==e&&(h||t.checksumRequired))throw Error("Ascii armor integrity check failed");await n.ready,await n.close();}catch(e){await n.abort(e);}}));}catch(e){i(e);}})).then((async e=>(s(e.data)&&(e.data=await N(e.data)),e)))}function le(e,t,r,i,n,a=ne){let s,o;e===$.armor.signed&&(s=t.text,o=t.hash,t=t.data);const c=F(t),u=[];switch(e){case $.armor.multipartSection:u.push("-----BEGIN PGP MESSAGE, PART "+r+"/"+i+"-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP MESSAGE, PART "+r+"/"+i+"-----\n");break;case $.armor.multipartLast:u.push("-----BEGIN PGP MESSAGE, PART "+r+"-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP MESSAGE, PART "+r+"-----\n");break;case $.armor.signed:u.push("-----BEGIN PGP SIGNED MESSAGE-----\n"),u.push("Hash: "+o+"\n\n"),u.push(s.replace(/^-/gm,"- -")),u.push("\n-----BEGIN PGP SIGNATURE-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP SIGNATURE-----\n");break;case $.armor.message:u.push("-----BEGIN PGP MESSAGE-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP MESSAGE-----\n");break;case $.armor.publicKey:u.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP PUBLIC KEY BLOCK-----\n");break;case $.armor.privateKey:u.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP PRIVATE KEY BLOCK-----\n");break;case $.armor.signature:u.push("-----BEGIN PGP SIGNATURE-----\n"),u.push(se(n,a)),u.push(ee(t)),u.push("=",oe(c)),u.push("-----END PGP SIGNATURE-----\n");}return X.concat(u)}class pe{constructor(){this.bytes="";}read(e){return this.bytes=X.uint8ArrayToString(e.subarray(0,8)),this.bytes.length}write(){return X.stringToUint8Array(this.bytes)}toHex(){return X.uint8ArrayToHex(X.stringToUint8Array(this.bytes))}equals(e,t=!1){return t&&(e.isWildcard()||this.isWildcard())||this.bytes===e.bytes}isNull(){return ""===this.bytes}isWildcard(){return /^0+$/.test(this.toHex())}static mapToHex(e){return e.toHex()}static fromID(e){const t=new pe;return t.read(X.hexToUint8Array(e)),t}static wildcard(){const e=new pe;return e.read(new Uint8Array(8)),e}}var ye=function(){var e,t,r=!1;function i(r,i){var n=e[(t[r]+t[i])%255];return 0!==r&&0!==i||(n=0),n}var n,a,s,o,c=!1;function u(){function u(r){var i,n,a;for(n=a=function(r){var i=e[255-t[r]];return 0===r&&(i=0),i}(r),i=0;i<4;i++)a^=n=255&(n<<1|n>>>7);return a^=99}r||function(){e=[],t=[];var i,n,a=1;for(i=0;i<255;i++)e[i]=a,n=128&a,a<<=1,a&=255,128===n&&(a^=27),a^=e[i],t[e[i]]=i;e[255]=e[0],t[0]=0,r=!0;}(),n=[],a=[],s=[[],[],[],[]],o=[[],[],[],[]];for(var h=0;h<256;h++){var d=u(h);n[h]=d,a[d]=h,s[0][h]=i(2,d)<<24|d<<16|d<<8|i(3,d),o[0][d]=i(14,h)<<24|i(9,h)<<16|i(13,h)<<8|i(11,h);for(var f=1;f<4;f++)s[f][h]=s[f-1][h]>>>8|s[f-1][h]<<24,o[f][d]=o[f-1][d]>>>8|o[f-1][d]<<24;}c=!0;}var h=function(e,t){c||u();var r=new Uint32Array(t);r.set(n,512),r.set(a,768);for(var i=0;i<4;i++)r.set(s[i],4096+1024*i>>2),r.set(o[i],8192+1024*i>>2);var h=function(e,t,r){"use asm";var i=0,n=0,a=0,s=0,o=0,c=0,u=0,h=0,d=0,f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0,v=0,_=0,k=0,A=0;var S=new e.Uint32Array(r),E=new e.Uint8Array(r);function P(e,t,r,o,c,u,h,d){e=e|0;t=t|0;r=r|0;o=o|0;c=c|0;u=u|0;h=h|0;d=d|0;var f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0;f=r|0x400,l=r|0x800,p=r|0xc00;c=c^S[(e|0)>>2],u=u^S[(e|4)>>2],h=h^S[(e|8)>>2],d=d^S[(e|12)>>2];for(w=16;(w|0)<=o<<4;w=w+16|0){y=S[(r|c>>22&1020)>>2]^S[(f|u>>14&1020)>>2]^S[(l|h>>6&1020)>>2]^S[(p|d<<2&1020)>>2]^S[(e|w|0)>>2],b=S[(r|u>>22&1020)>>2]^S[(f|h>>14&1020)>>2]^S[(l|d>>6&1020)>>2]^S[(p|c<<2&1020)>>2]^S[(e|w|4)>>2],m=S[(r|h>>22&1020)>>2]^S[(f|d>>14&1020)>>2]^S[(l|c>>6&1020)>>2]^S[(p|u<<2&1020)>>2]^S[(e|w|8)>>2],g=S[(r|d>>22&1020)>>2]^S[(f|c>>14&1020)>>2]^S[(l|u>>6&1020)>>2]^S[(p|h<<2&1020)>>2]^S[(e|w|12)>>2];c=y,u=b,h=m,d=g;}i=S[(t|c>>22&1020)>>2]<<24^S[(t|u>>14&1020)>>2]<<16^S[(t|h>>6&1020)>>2]<<8^S[(t|d<<2&1020)>>2]^S[(e|w|0)>>2],n=S[(t|u>>22&1020)>>2]<<24^S[(t|h>>14&1020)>>2]<<16^S[(t|d>>6&1020)>>2]<<8^S[(t|c<<2&1020)>>2]^S[(e|w|4)>>2],a=S[(t|h>>22&1020)>>2]<<24^S[(t|d>>14&1020)>>2]<<16^S[(t|c>>6&1020)>>2]<<8^S[(t|u<<2&1020)>>2]^S[(e|w|8)>>2],s=S[(t|d>>22&1020)>>2]<<24^S[(t|c>>14&1020)>>2]<<16^S[(t|u>>6&1020)>>2]<<8^S[(t|h<<2&1020)>>2]^S[(e|w|12)>>2];}function x(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;P(0x0000,0x0800,0x1000,A,e,t,r,i);}function M(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;var a=0;P(0x0400,0x0c00,0x2000,A,e,i,r,t);a=n,n=s,s=a;}function K(e,t,r,d){e=e|0;t=t|0;r=r|0;d=d|0;P(0x0000,0x0800,0x1000,A,o^e,c^t,u^r,h^d);o=i,c=n,u=a,h=s;}function C(e,t,r,d){e=e|0;t=t|0;r=r|0;d=d|0;var f=0;P(0x0400,0x0c00,0x2000,A,e,d,r,t);f=n,n=s,s=f;i=i^o,n=n^c,a=a^u,s=s^h;o=e,c=t,u=r,h=d;}function D(e,t,r,d){e=e|0;t=t|0;r=r|0;d=d|0;P(0x0000,0x0800,0x1000,A,o,c,u,h);o=i=i^e,c=n=n^t,u=a=a^r,h=s=s^d;}function U(e,t,r,d){e=e|0;t=t|0;r=r|0;d=d|0;P(0x0000,0x0800,0x1000,A,o,c,u,h);i=i^e,n=n^t,a=a^r,s=s^d;o=e,c=t,u=r,h=d;}function R(e,t,r,d){e=e|0;t=t|0;r=r|0;d=d|0;P(0x0000,0x0800,0x1000,A,o,c,u,h);o=i,c=n,u=a,h=s;i=i^e,n=n^t,a=a^r,s=s^d;}function I(e,t,r,o){e=e|0;t=t|0;r=r|0;o=o|0;P(0x0000,0x0800,0x1000,A,d,f,l,p);p=~g&p|g&p+1;l=~m&l|m&l+((p|0)==0);f=~b&f|b&f+((l|0)==0);d=~y&d|y&d+((f|0)==0);i=i^e;n=n^t;a=a^r;s=s^o;}function B(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;var n=0,a=0,s=0,d=0,f=0,l=0,p=0,y=0,b=0,m=0;e=e^o,t=t^c,r=r^u,i=i^h;n=w|0,a=v|0,s=_|0,d=k|0;for(;(b|0)<128;b=b+1|0){if(n>>>31){f=f^e,l=l^t,p=p^r,y=y^i;}n=n<<1|a>>>31,a=a<<1|s>>>31,s=s<<1|d>>>31,d=d<<1;m=i&1;i=i>>>1|r<<31,r=r>>>1|t<<31,t=t>>>1|e<<31,e=e>>>1;if(m)e=e^0xe1000000;}o=f,c=l,u=p,h=y;}function T(e){e=e|0;A=e;}function z(e,t,r,o){e=e|0;t=t|0;r=r|0;o=o|0;i=e,n=t,a=r,s=o;}function q(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;o=e,c=t,u=r,h=i;}function F(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;d=e,f=t,l=r,p=i;}function O(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;y=e,b=t,m=r,g=i;}function L(e,t,r,i){e=e|0;t=t|0;r=r|0;i=i|0;p=~g&p|g&i,l=~m&l|m&r,f=~b&f|b&t,d=~y&d|y&e;}function N(e){e=e|0;if(e&15)return -1;E[e|0]=i>>>24,E[e|1]=i>>>16&255,E[e|2]=i>>>8&255,E[e|3]=i&255,E[e|4]=n>>>24,E[e|5]=n>>>16&255,E[e|6]=n>>>8&255,E[e|7]=n&255,E[e|8]=a>>>24,E[e|9]=a>>>16&255,E[e|10]=a>>>8&255,E[e|11]=a&255,E[e|12]=s>>>24,E[e|13]=s>>>16&255,E[e|14]=s>>>8&255,E[e|15]=s&255;return 16}function j(e){e=e|0;if(e&15)return -1;E[e|0]=o>>>24,E[e|1]=o>>>16&255,E[e|2]=o>>>8&255,E[e|3]=o&255,E[e|4]=c>>>24,E[e|5]=c>>>16&255,E[e|6]=c>>>8&255,E[e|7]=c&255,E[e|8]=u>>>24,E[e|9]=u>>>16&255,E[e|10]=u>>>8&255,E[e|11]=u&255,E[e|12]=h>>>24,E[e|13]=h>>>16&255,E[e|14]=h>>>8&255,E[e|15]=h&255;return 16}function H(){x(0,0,0,0);w=i,v=n,_=a,k=s;}function W(e,t,r){e=e|0;t=t|0;r=r|0;var o=0;if(t&15)return -1;while((r|0)>=16){V[e&7](E[t|0]<<24|E[t|1]<<16|E[t|2]<<8|E[t|3],E[t|4]<<24|E[t|5]<<16|E[t|6]<<8|E[t|7],E[t|8]<<24|E[t|9]<<16|E[t|10]<<8|E[t|11],E[t|12]<<24|E[t|13]<<16|E[t|14]<<8|E[t|15]);E[t|0]=i>>>24,E[t|1]=i>>>16&255,E[t|2]=i>>>8&255,E[t|3]=i&255,E[t|4]=n>>>24,E[t|5]=n>>>16&255,E[t|6]=n>>>8&255,E[t|7]=n&255,E[t|8]=a>>>24,E[t|9]=a>>>16&255,E[t|10]=a>>>8&255,E[t|11]=a&255,E[t|12]=s>>>24,E[t|13]=s>>>16&255,E[t|14]=s>>>8&255,E[t|15]=s&255;o=o+16|0,t=t+16|0,r=r-16|0;}return o|0}function G(e,t,r){e=e|0;t=t|0;r=r|0;var i=0;if(t&15)return -1;while((r|0)>=16){$[e&1](E[t|0]<<24|E[t|1]<<16|E[t|2]<<8|E[t|3],E[t|4]<<24|E[t|5]<<16|E[t|6]<<8|E[t|7],E[t|8]<<24|E[t|9]<<16|E[t|10]<<8|E[t|11],E[t|12]<<24|E[t|13]<<16|E[t|14]<<8|E[t|15]);i=i+16|0,t=t+16|0,r=r-16|0;}return i|0}var V=[x,M,K,C,D,U,R,I];var $=[K,B];return {set_rounds:T,set_state:z,set_iv:q,set_nonce:F,set_mask:O,set_counter:L,get_state:N,get_iv:j,gcm_init:H,cipher:W,mac:G}}({Uint8Array,Uint32Array},e,t);return h.set_key=function(e,t,i,a,s,c,u,d,f){var l=r.subarray(0,60),p=r.subarray(256,316);l.set([t,i,a,s,c,u,d,f]);for(var y=e,b=1;y<4*e+28;y++){var m=l[y-1];(y%e==0||8===e&&y%e==4)&&(m=n[m>>>24]<<24^n[m>>>16&255]<<16^n[m>>>8&255]<<8^n[255&m]),y%e==0&&(m=m<<8^m>>>24^b<<24,b=b<<1^(128&b?27:0)),l[y]=l[y-e]^m;}for(var g=0;g<y;g+=4)for(var w=0;w<4;w++){m=l[y-(4+g)+(4-w)%4];p[g+w]=g<4||g>=y-4?m:o[0][n[m>>>24]]^o[1][n[m>>>16&255]]^o[2][n[m>>>8&255]]^o[3][n[255&m]];}h.set_rounds(e+5);},h};return h.ENC={ECB:0,CBC:2,CFB:4,OFB:6,CTR:7},h.DEC={ECB:1,CBC:3,CFB:5,OFB:6,CTR:7},h.MAC={CBC:0,GCM:1},h.HEAP_DATA=16384,h}();function be(e){return e instanceof Uint8Array}function me(e,t){const r=e?e.byteLength:t||65536;if(4095&r||r<=0)throw Error("heap size must be a positive integer and a multiple of 4096");return e=e||new Uint8Array(new ArrayBuffer(r))}function ge(e,t,r,i,n){const a=e.length-t,s=a<n?a:n;return e.set(r.subarray(i,i+s),t),s}function we(...e){const t=e.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(t);let i=0;for(let t=0;t<e.length;t++)r.set(e[t],i),i+=e[t].length;return r}class ve extends Error{constructor(...e){super(...e);}}class _e extends Error{constructor(...e){super(...e);}}class ke extends Error{constructor(...e){super(...e);}}const Ae=[],Se=[];class Ee{constructor(e,t,r=!0,i,n,a){this.pos=0,this.len=0,this.mode=i,this.pos=0,this.len=0,this.key=e,this.iv=t,this.padding=r,this.acquire_asm(n,a);}acquire_asm(e,t){return void 0!==this.heap&&void 0!==this.asm||(this.heap=e||Ae.pop()||me().subarray(ye.HEAP_DATA),this.asm=t||Se.pop()||new ye(null,this.heap.buffer),this.reset(this.key,this.iv)),{heap:this.heap,asm:this.asm}}release_asm(){void 0!==this.heap&&void 0!==this.asm&&(Ae.push(this.heap),Se.push(this.asm)),this.heap=void 0,this.asm=void 0;}reset(e,t){const{asm:r}=this.acquire_asm(),i=e.length;if(16!==i&&24!==i&&32!==i)throw new _e("illegal key size");const n=new DataView(e.buffer,e.byteOffset,e.byteLength);if(r.set_key(i>>2,n.getUint32(0),n.getUint32(4),n.getUint32(8),n.getUint32(12),i>16?n.getUint32(16):0,i>16?n.getUint32(20):0,i>24?n.getUint32(24):0,i>24?n.getUint32(28):0),void 0!==t){if(16!==t.length)throw new _e("illegal iv size");let e=new DataView(t.buffer,t.byteOffset,t.byteLength);r.set_iv(e.getUint32(0),e.getUint32(4),e.getUint32(8),e.getUint32(12));}else r.set_iv(0,0,0,0);}AES_Encrypt_process(e){if(!be(e))throw new TypeError("data isn't of expected type");let{heap:t,asm:r}=this.acquire_asm(),i=ye.ENC[this.mode],n=ye.HEAP_DATA,a=this.pos,s=this.len,o=0,c=e.length||0,u=0,h=0,d=new Uint8Array(s+c&-16);for(;c>0;)h=ge(t,a+s,e,o,c),s+=h,o+=h,c-=h,h=r.cipher(i,n+a,s),h&&d.set(t.subarray(a,a+h),u),u+=h,h<s?(a+=h,s-=h):(a=0,s=0);return this.pos=a,this.len=s,d}AES_Encrypt_finish(){let{heap:e,asm:t}=this.acquire_asm(),r=ye.ENC[this.mode],i=ye.HEAP_DATA,n=this.pos,a=this.len,s=16-a%16,o=a;if(this.hasOwnProperty("padding")){if(this.padding){for(let t=0;t<s;++t)e[n+a+t]=s;a+=s,o=a;}else if(a%16)throw new _e("data length must be a multiple of the block size")}else a+=s;const c=new Uint8Array(o);return a&&t.cipher(r,i+n,a),o&&c.set(e.subarray(n,n+o)),this.pos=0,this.len=0,this.release_asm(),c}AES_Decrypt_process(e){if(!be(e))throw new TypeError("data isn't of expected type");let{heap:t,asm:r}=this.acquire_asm(),i=ye.DEC[this.mode],n=ye.HEAP_DATA,a=this.pos,s=this.len,o=0,c=e.length||0,u=0,h=s+c&-16,d=0,f=0;this.padding&&(d=s+c-h||16,h-=d);const l=new Uint8Array(h);for(;c>0;)f=ge(t,a+s,e,o,c),s+=f,o+=f,c-=f,f=r.cipher(i,n+a,s-(c?0:d)),f&&l.set(t.subarray(a,a+f),u),u+=f,f<s?(a+=f,s-=f):(a=0,s=0);return this.pos=a,this.len=s,l}AES_Decrypt_finish(){let{heap:e,asm:t}=this.acquire_asm(),r=ye.DEC[this.mode],i=ye.HEAP_DATA,n=this.pos,a=this.len,s=a;if(a>0){if(a%16){if(this.hasOwnProperty("padding"))throw new _e("data length must be a multiple of the block size");a+=16-a%16;}if(t.cipher(r,i+n,a),this.hasOwnProperty("padding")&&this.padding){let t=e[n+s-1];if(t<1||t>16||t>s)throw new ke("bad padding");let r=0;for(let i=t;i>1;i--)r|=t^e[n+s-i];if(r)throw new ke("bad padding");s-=t;}}const o=new Uint8Array(s);return s>0&&o.set(e.subarray(n,n+s)),this.pos=0,this.len=0,this.release_asm(),o}}class Pe{static encrypt(e,t,r=!1){return new Pe(t,r).encrypt(e)}static decrypt(e,t,r=!1){return new Pe(t,r).decrypt(e)}constructor(e,t=!1,r){this.aes=r||new Ee(e,void 0,t,"ECB");}encrypt(e){return we(this.aes.AES_Encrypt_process(e),this.aes.AES_Encrypt_finish())}decrypt(e){return we(this.aes.AES_Decrypt_process(e),this.aes.AES_Decrypt_finish())}}function xe(e){const t=function(e){const t=new Pe(e);this.encrypt=function(e){return t.encrypt(e)},this.decrypt=function(e){return t.decrypt(e)};};return t.blockSize=t.prototype.blockSize=16,t.keySize=t.prototype.keySize=e/8,t}function Me(e,t,r,i,n,a){const s=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],o=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],c=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],u=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],h=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],d=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],f=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],l=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696];let p,y,b,m,g,w,v,_,k,A,S,E,P,x,M=0,K=t.length;const C=32===e.length?3:9;_=3===C?r?[0,32,2]:[30,-2,-2]:r?[0,32,2,62,30,-2,64,96,2]:[94,62,-2,32,64,2,30,-2,-2],r&&(t=function(e,t){const r=8-e.length%8;let i;if(2===t&&r<8)i=32;else if(1===t)i=r;else {if(t||!(r<8)){if(8===r)return e;throw Error("des: invalid padding")}i=0;}const n=new Uint8Array(e.length+r);for(let t=0;t<e.length;t++)n[t]=e[t];for(let t=0;t<r;t++)n[e.length+t]=i;return n}(t,a),K=t.length);let D=new Uint8Array(K),U=0;for(1===i&&(k=n[M++]<<24|n[M++]<<16|n[M++]<<8|n[M++],S=n[M++]<<24|n[M++]<<16|n[M++]<<8|n[M++],M=0);M<K;){for(w=t[M++]<<24|t[M++]<<16|t[M++]<<8|t[M++],v=t[M++]<<24|t[M++]<<16|t[M++]<<8|t[M++],1===i&&(r?(w^=k,v^=S):(A=k,E=S,k=w,S=v)),b=252645135&(w>>>4^v),v^=b,w^=b<<4,b=65535&(w>>>16^v),v^=b,w^=b<<16,b=858993459&(v>>>2^w),w^=b,v^=b<<2,b=16711935&(v>>>8^w),w^=b,v^=b<<8,b=1431655765&(w>>>1^v),v^=b,w^=b<<1,w=w<<1|w>>>31,v=v<<1|v>>>31,y=0;y<C;y+=3){for(P=_[y+1],x=_[y+2],p=_[y];p!==P;p+=x)m=v^e[p],g=(v>>>4|v<<28)^e[p+1],b=w,w=v,v=b^(o[m>>>24&63]|u[m>>>16&63]|d[m>>>8&63]|l[63&m]|s[g>>>24&63]|c[g>>>16&63]|h[g>>>8&63]|f[63&g]);b=w,w=v,v=b;}w=w>>>1|w<<31,v=v>>>1|v<<31,b=1431655765&(w>>>1^v),v^=b,w^=b<<1,b=16711935&(v>>>8^w),w^=b,v^=b<<8,b=858993459&(v>>>2^w),w^=b,v^=b<<2,b=65535&(w>>>16^v),v^=b,w^=b<<16,b=252645135&(w>>>4^v),v^=b,w^=b<<4,1===i&&(r?(k=w,S=v):(w^=A,v^=E)),D[U++]=w>>>24,D[U++]=w>>>16&255,D[U++]=w>>>8&255,D[U++]=255&w,D[U++]=v>>>24,D[U++]=v>>>16&255,D[U++]=v>>>8&255,D[U++]=255&v;}return r||(D=function(e,t){let r,i=null;if(2===t)r=32;else if(1===t)i=e[e.length-1];else {if(t)throw Error("des: invalid padding");r=0;}if(!i){for(i=1;e[e.length-i]===r;)i++;i--;}return e.subarray(0,e.length-i)}(D,a)),D}function Ke(e){const t=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],r=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],i=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],n=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],a=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],s=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],o=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],c=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],u=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],h=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],d=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],f=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],l=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],p=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],y=e.length>8?3:1,b=Array(32*y),m=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];let g,w,v,_=0,k=0;for(let A=0;A<y;A++){let y=e[_++]<<24|e[_++]<<16|e[_++]<<8|e[_++],A=e[_++]<<24|e[_++]<<16|e[_++]<<8|e[_++];v=252645135&(y>>>4^A),A^=v,y^=v<<4,v=65535&(A>>>-16^y),y^=v,A^=v<<-16,v=858993459&(y>>>2^A),A^=v,y^=v<<2,v=65535&(A>>>-16^y),y^=v,A^=v<<-16,v=1431655765&(y>>>1^A),A^=v,y^=v<<1,v=16711935&(A>>>8^y),y^=v,A^=v<<8,v=1431655765&(y>>>1^A),A^=v,y^=v<<1,v=y<<8|A>>>20&240,y=A<<24|A<<8&16711680|A>>>8&65280|A>>>24&240,A=v;for(let e=0;e<16;e++)m[e]?(y=y<<2|y>>>26,A=A<<2|A>>>26):(y=y<<1|y>>>27,A=A<<1|A>>>27),y&=-15,A&=-15,g=t[y>>>28]|r[y>>>24&15]|i[y>>>20&15]|n[y>>>16&15]|a[y>>>12&15]|s[y>>>8&15]|o[y>>>4&15],w=c[A>>>28]|u[A>>>24&15]|h[A>>>20&15]|d[A>>>16&15]|f[A>>>12&15]|l[A>>>8&15]|p[A>>>4&15],v=65535&(w>>>16^g),b[k++]=g^v,b[k++]=w^v<<16;}return b}function Ce(e){this.key=[];for(let t=0;t<3;t++)this.key.push(new Uint8Array(e.subarray(8*t,8*t+8)));this.encrypt=function(e){return Me(Ke(this.key[2]),Me(Ke(this.key[1]),Me(Ke(this.key[0]),e,!0,0,null,null),!1,0,null,null),!0,0,null,null)};}function De(){this.BlockSize=8,this.KeySize=16,this.setKey=function(e){if(this.masking=Array(16),this.rotate=Array(16),this.reset(),e.length!==this.KeySize)throw Error("CAST-128: keys must be 16 bytes");return this.keySchedule(e),!0},this.reset=function(){for(let e=0;e<16;e++)this.masking[e]=0,this.rotate[e]=0;},this.getBlockSize=function(){return this.BlockSize},this.encrypt=function(e){const t=Array(e.length);for(let a=0;a<e.length;a+=8){let s,o=e[a]<<24|e[a+1]<<16|e[a+2]<<8|e[a+3],c=e[a+4]<<24|e[a+5]<<16|e[a+6]<<8|e[a+7];s=c,c=o^r(c,this.masking[0],this.rotate[0]),o=s,s=c,c=o^i(c,this.masking[1],this.rotate[1]),o=s,s=c,c=o^n(c,this.masking[2],this.rotate[2]),o=s,s=c,c=o^r(c,this.masking[3],this.rotate[3]),o=s,s=c,c=o^i(c,this.masking[4],this.rotate[4]),o=s,s=c,c=o^n(c,this.masking[5],this.rotate[5]),o=s,s=c,c=o^r(c,this.masking[6],this.rotate[6]),o=s,s=c,c=o^i(c,this.masking[7],this.rotate[7]),o=s,s=c,c=o^n(c,this.masking[8],this.rotate[8]),o=s,s=c,c=o^r(c,this.masking[9],this.rotate[9]),o=s,s=c,c=o^i(c,this.masking[10],this.rotate[10]),o=s,s=c,c=o^n(c,this.masking[11],this.rotate[11]),o=s,s=c,c=o^r(c,this.masking[12],this.rotate[12]),o=s,s=c,c=o^i(c,this.masking[13],this.rotate[13]),o=s,s=c,c=o^n(c,this.masking[14],this.rotate[14]),o=s,s=c,c=o^r(c,this.masking[15],this.rotate[15]),o=s,t[a]=c>>>24&255,t[a+1]=c>>>16&255,t[a+2]=c>>>8&255,t[a+3]=255&c,t[a+4]=o>>>24&255,t[a+5]=o>>>16&255,t[a+6]=o>>>8&255,t[a+7]=255&o;}return t},this.decrypt=function(e){const t=Array(e.length);for(let a=0;a<e.length;a+=8){let s,o=e[a]<<24|e[a+1]<<16|e[a+2]<<8|e[a+3],c=e[a+4]<<24|e[a+5]<<16|e[a+6]<<8|e[a+7];s=c,c=o^r(c,this.masking[15],this.rotate[15]),o=s,s=c,c=o^n(c,this.masking[14],this.rotate[14]),o=s,s=c,c=o^i(c,this.masking[13],this.rotate[13]),o=s,s=c,c=o^r(c,this.masking[12],this.rotate[12]),o=s,s=c,c=o^n(c,this.masking[11],this.rotate[11]),o=s,s=c,c=o^i(c,this.masking[10],this.rotate[10]),o=s,s=c,c=o^r(c,this.masking[9],this.rotate[9]),o=s,s=c,c=o^n(c,this.masking[8],this.rotate[8]),o=s,s=c,c=o^i(c,this.masking[7],this.rotate[7]),o=s,s=c,c=o^r(c,this.masking[6],this.rotate[6]),o=s,s=c,c=o^n(c,this.masking[5],this.rotate[5]),o=s,s=c,c=o^i(c,this.masking[4],this.rotate[4]),o=s,s=c,c=o^r(c,this.masking[3],this.rotate[3]),o=s,s=c,c=o^n(c,this.masking[2],this.rotate[2]),o=s,s=c,c=o^i(c,this.masking[1],this.rotate[1]),o=s,s=c,c=o^r(c,this.masking[0],this.rotate[0]),o=s,t[a]=c>>>24&255,t[a+1]=c>>>16&255,t[a+2]=c>>>8&255,t[a+3]=255&c,t[a+4]=o>>>24&255,t[a+5]=o>>16&255,t[a+6]=o>>8&255,t[a+7]=255&o;}return t};const e=[,,,,];e[0]=[,,,,],e[0][0]=[4,0,13,15,12,14,8],e[0][1]=[5,2,16,18,17,19,10],e[0][2]=[6,3,23,22,21,20,9],e[0][3]=[7,1,26,25,27,24,11],e[1]=[,,,,],e[1][0]=[0,6,21,23,20,22,16],e[1][1]=[1,4,0,2,1,3,18],e[1][2]=[2,5,7,6,5,4,17],e[1][3]=[3,7,10,9,11,8,19],e[2]=[,,,,],e[2][0]=[4,0,13,15,12,14,8],e[2][1]=[5,2,16,18,17,19,10],e[2][2]=[6,3,23,22,21,20,9],e[2][3]=[7,1,26,25,27,24,11],e[3]=[,,,,],e[3][0]=[0,6,21,23,20,22,16],e[3][1]=[1,4,0,2,1,3,18],e[3][2]=[2,5,7,6,5,4,17],e[3][3]=[3,7,10,9,11,8,19];const t=[,,,,];function r(e,t,r){const i=t+e,n=i<<r|i>>>32-r;return (a[0][n>>>24]^a[1][n>>>16&255])-a[2][n>>>8&255]+a[3][255&n]}function i(e,t,r){const i=t^e,n=i<<r|i>>>32-r;return a[0][n>>>24]-a[1][n>>>16&255]+a[2][n>>>8&255]^a[3][255&n]}function n(e,t,r){const i=t-e,n=i<<r|i>>>32-r;return (a[0][n>>>24]+a[1][n>>>16&255]^a[2][n>>>8&255])-a[3][255&n]}t[0]=[,,,,],t[0][0]=[24,25,23,22,18],t[0][1]=[26,27,21,20,22],t[0][2]=[28,29,19,18,25],t[0][3]=[30,31,17,16,28],t[1]=[,,,,],t[1][0]=[3,2,12,13,8],t[1][1]=[1,0,14,15,13],t[1][2]=[7,6,8,9,3],t[1][3]=[5,4,10,11,7],t[2]=[,,,,],t[2][0]=[19,18,28,29,25],t[2][1]=[17,16,30,31,28],t[2][2]=[23,22,24,25,18],t[2][3]=[21,20,26,27,22],t[3]=[,,,,],t[3][0]=[8,9,7,6,3],t[3][1]=[10,11,5,4,7],t[3][2]=[12,13,3,2,8],t[3][3]=[14,15,1,0,13],this.keySchedule=function(r){const i=[,,,,,,,,],n=Array(32);let s;for(let e=0;e<4;e++)s=4*e,i[e]=r[s]<<24|r[s+1]<<16|r[s+2]<<8|r[s+3];const o=[6,7,4,5];let c,u=0;for(let r=0;r<2;r++)for(let r=0;r<4;r++){for(s=0;s<4;s++){const t=e[r][s];c=i[t[1]],c^=a[4][i[t[2]>>>2]>>>24-8*(3&t[2])&255],c^=a[5][i[t[3]>>>2]>>>24-8*(3&t[3])&255],c^=a[6][i[t[4]>>>2]>>>24-8*(3&t[4])&255],c^=a[7][i[t[5]>>>2]>>>24-8*(3&t[5])&255],c^=a[o[s]][i[t[6]>>>2]>>>24-8*(3&t[6])&255],i[t[0]]=c;}for(s=0;s<4;s++){const e=t[r][s];c=a[4][i[e[0]>>>2]>>>24-8*(3&e[0])&255],c^=a[5][i[e[1]>>>2]>>>24-8*(3&e[1])&255],c^=a[6][i[e[2]>>>2]>>>24-8*(3&e[2])&255],c^=a[7][i[e[3]>>>2]>>>24-8*(3&e[3])&255],c^=a[4+s][i[e[4]>>>2]>>>24-8*(3&e[4])&255],n[u]=c,u++;}}for(let e=0;e<16;e++)this.masking[e]=n[e],this.rotate[e]=31&n[16+e];};const a=[,,,,,,,,];a[0]=[821772500,2678128395,1810681135,1059425402,505495343,2617265619,1610868032,3483355465,3218386727,2294005173,3791863952,2563806837,1852023008,365126098,3269944861,584384398,677919599,3229601881,4280515016,2002735330,1136869587,3744433750,2289869850,2731719981,2714362070,879511577,1639411079,575934255,717107937,2857637483,576097850,2731753936,1725645e3,2810460463,5111599,767152862,2543075244,1251459544,1383482551,3052681127,3089939183,3612463449,1878520045,1510570527,2189125840,2431448366,582008916,3163445557,1265446783,1354458274,3529918736,3202711853,3073581712,3912963487,3029263377,1275016285,4249207360,2905708351,3304509486,1442611557,3585198765,2712415662,2731849581,3248163920,2283946226,208555832,2766454743,1331405426,1447828783,3315356441,3108627284,2957404670,2981538698,3339933917,1669711173,286233437,1465092821,1782121619,3862771680,710211251,980974943,1651941557,430374111,2051154026,704238805,4128970897,3144820574,2857402727,948965521,3333752299,2227686284,718756367,2269778983,2731643755,718440111,2857816721,3616097120,1113355533,2478022182,410092745,1811985197,1944238868,2696854588,1415722873,1682284203,1060277122,1998114690,1503841958,82706478,2315155686,1068173648,845149890,2167947013,1768146376,1993038550,3566826697,3390574031,940016341,3355073782,2328040721,904371731,1205506512,4094660742,2816623006,825647681,85914773,2857843460,1249926541,1417871568,3287612,3211054559,3126306446,1975924523,1353700161,2814456437,2438597621,1800716203,722146342,2873936343,1151126914,4160483941,2877670899,458611604,2866078500,3483680063,770352098,2652916994,3367839148,3940505011,3585973912,3809620402,718646636,2504206814,2914927912,3631288169,2857486607,2860018678,575749918,2857478043,718488780,2069512688,3548183469,453416197,1106044049,3032691430,52586708,3378514636,3459808877,3211506028,1785789304,218356169,3571399134,3759170522,1194783844,1523787992,3007827094,1975193539,2555452411,1341901877,3045838698,3776907964,3217423946,2802510864,2889438986,1057244207,1636348243,3761863214,1462225785,2632663439,481089165,718503062,24497053,3332243209,3344655856,3655024856,3960371065,1195698900,2971415156,3710176158,2115785917,4027663609,3525578417,2524296189,2745972565,3564906415,1372086093,1452307862,2780501478,1476592880,3389271281,18495466,2378148571,901398090,891748256,3279637769,3157290713,2560960102,1447622437,4284372637,216884176,2086908623,1879786977,3588903153,2242455666,2938092967,3559082096,2810645491,758861177,1121993112,215018983,642190776,4169236812,1196255959,2081185372,3508738393,941322904,4124243163,2877523539,1848581667,2205260958,3180453958,2589345134,3694731276,550028657,2519456284,3789985535,2973870856,2093648313,443148163,46942275,2734146937,1117713533,1115362972,1523183689,3717140224,1551984063],a[1]=[522195092,4010518363,1776537470,960447360,4267822970,4005896314,1435016340,1929119313,2913464185,1310552629,3579470798,3724818106,2579771631,1594623892,417127293,2715217907,2696228731,1508390405,3994398868,3925858569,3695444102,4019471449,3129199795,3770928635,3520741761,990456497,4187484609,2783367035,21106139,3840405339,631373633,3783325702,532942976,396095098,3548038825,4267192484,2564721535,2011709262,2039648873,620404603,3776170075,2898526339,3612357925,4159332703,1645490516,223693667,1567101217,3362177881,1029951347,3470931136,3570957959,1550265121,119497089,972513919,907948164,3840628539,1613718692,3594177948,465323573,2659255085,654439692,2575596212,2699288441,3127702412,277098644,624404830,4100943870,2717858591,546110314,2403699828,3655377447,1321679412,4236791657,1045293279,4010672264,895050893,2319792268,494945126,1914543101,2777056443,3894764339,2219737618,311263384,4275257268,3458730721,669096869,3584475730,3835122877,3319158237,3949359204,2005142349,2713102337,2228954793,3769984788,569394103,3855636576,1425027204,108000370,2736431443,3671869269,3043122623,1750473702,2211081108,762237499,3972989403,2798899386,3061857628,2943854345,867476300,964413654,1591880597,1594774276,2179821409,552026980,3026064248,3726140315,2283577634,3110545105,2152310760,582474363,1582640421,1383256631,2043843868,3322775884,1217180674,463797851,2763038571,480777679,2718707717,2289164131,3118346187,214354409,200212307,3810608407,3025414197,2674075964,3997296425,1847405948,1342460550,510035443,4080271814,815934613,833030224,1620250387,1945732119,2703661145,3966000196,1388869545,3456054182,2687178561,2092620194,562037615,1356438536,3409922145,3261847397,1688467115,2150901366,631725691,3840332284,549916902,3455104640,394546491,837744717,2114462948,751520235,2221554606,2415360136,3999097078,2063029875,803036379,2702586305,821456707,3019566164,360699898,4018502092,3511869016,3677355358,2402471449,812317050,49299192,2570164949,3259169295,2816732080,3331213574,3101303564,2156015656,3705598920,3546263921,143268808,3200304480,1638124008,3165189453,3341807610,578956953,2193977524,3638120073,2333881532,807278310,658237817,2969561766,1641658566,11683945,3086995007,148645947,1138423386,4158756760,1981396783,2401016740,3699783584,380097457,2680394679,2803068651,3334260286,441530178,4016580796,1375954390,761952171,891809099,2183123478,157052462,3683840763,1592404427,341349109,2438483839,1417898363,644327628,2233032776,2353769706,2201510100,220455161,1815641738,182899273,2995019788,3627381533,3702638151,2890684138,1052606899,588164016,1681439879,4038439418,2405343923,4229449282,167996282,1336969661,1688053129,2739224926,1543734051,1046297529,1138201970,2121126012,115334942,1819067631,1902159161,1941945968,2206692869,1159982321],a[2]=[2381300288,637164959,3952098751,3893414151,1197506559,916448331,2350892612,2932787856,3199334847,4009478890,3905886544,1373570990,2450425862,4037870920,3778841987,2456817877,286293407,124026297,3001279700,1028597854,3115296800,4208886496,2691114635,2188540206,1430237888,1218109995,3572471700,308166588,570424558,2187009021,2455094765,307733056,1310360322,3135275007,1384269543,2388071438,863238079,2359263624,2801553128,3380786597,2831162807,1470087780,1728663345,4072488799,1090516929,532123132,2389430977,1132193179,2578464191,3051079243,1670234342,1434557849,2711078940,1241591150,3314043432,3435360113,3091448339,1812415473,2198440252,267246943,796911696,3619716990,38830015,1526438404,2806502096,374413614,2943401790,1489179520,1603809326,1920779204,168801282,260042626,2358705581,1563175598,2397674057,1356499128,2217211040,514611088,2037363785,2186468373,4022173083,2792511869,2913485016,1173701892,4200428547,3896427269,1334932762,2455136706,602925377,2835607854,1613172210,41346230,2499634548,2457437618,2188827595,41386358,4172255629,1313404830,2405527007,3801973774,2217704835,873260488,2528884354,2478092616,4012915883,2555359016,2006953883,2463913485,575479328,2218240648,2099895446,660001756,2341502190,3038761536,3888151779,3848713377,3286851934,1022894237,1620365795,3449594689,1551255054,15374395,3570825345,4249311020,4151111129,3181912732,310226346,1133119310,530038928,136043402,2476768958,3107506709,2544909567,1036173560,2367337196,1681395281,1758231547,3641649032,306774401,1575354324,3716085866,1990386196,3114533736,2455606671,1262092282,3124342505,2768229131,4210529083,1833535011,423410938,660763973,2187129978,1639812e3,3508421329,3467445492,310289298,272797111,2188552562,2456863912,310240523,677093832,1013118031,901835429,3892695601,1116285435,3036471170,1337354835,243122523,520626091,277223598,4244441197,4194248841,1766575121,594173102,316590669,742362309,3536858622,4176435350,3838792410,2501204839,1229605004,3115755532,1552908988,2312334149,979407927,3959474601,1148277331,176638793,3614686272,2083809052,40992502,1340822838,2731552767,3535757508,3560899520,1354035053,122129617,7215240,2732932949,3118912700,2718203926,2539075635,3609230695,3725561661,1928887091,2882293555,1988674909,2063640240,2491088897,1459647954,4189817080,2302804382,1113892351,2237858528,1927010603,4002880361,1856122846,1594404395,2944033133,3855189863,3474975698,1643104450,4054590833,3431086530,1730235576,2984608721,3084664418,2131803598,4178205752,267404349,1617849798,1616132681,1462223176,736725533,2327058232,551665188,2945899023,1749386277,2575514597,1611482493,674206544,2201269090,3642560800,728599968,1680547377,2620414464,1388111496,453204106,4156223445,1094905244,2754698257,2201108165,3757000246,2704524545,3922940700,3996465027],a[3]=[2645754912,532081118,2814278639,3530793624,1246723035,1689095255,2236679235,4194438865,2116582143,3859789411,157234593,2045505824,4245003587,1687664561,4083425123,605965023,672431967,1336064205,3376611392,214114848,4258466608,3232053071,489488601,605322005,3998028058,264917351,1912574028,756637694,436560991,202637054,135989450,85393697,2152923392,3896401662,2895836408,2145855233,3535335007,115294817,3147733898,1922296357,3464822751,4117858305,1037454084,2725193275,2127856640,1417604070,1148013728,1827919605,642362335,2929772533,909348033,1346338451,3547799649,297154785,1917849091,4161712827,2883604526,3968694238,1469521537,3780077382,3375584256,1763717519,136166297,4290970789,1295325189,2134727907,2798151366,1566297257,3672928234,2677174161,2672173615,965822077,2780786062,289653839,1133871874,3491843819,35685304,1068898316,418943774,672553190,642281022,2346158704,1954014401,3037126780,4079815205,2030668546,3840588673,672283427,1776201016,359975446,3750173538,555499703,2769985273,1324923,69110472,152125443,3176785106,3822147285,1340634837,798073664,1434183902,15393959,216384236,1303690150,3881221631,3711134124,3960975413,106373927,2578434224,1455997841,1801814300,1578393881,1854262133,3188178946,3258078583,2302670060,1539295533,3505142565,3078625975,2372746020,549938159,3278284284,2620926080,181285381,2865321098,3970029511,68876850,488006234,1728155692,2608167508,836007927,2435231793,919367643,3339422534,3655756360,1457871481,40520939,1380155135,797931188,234455205,2255801827,3990488299,397000196,739833055,3077865373,2871719860,4022553888,772369276,390177364,3853951029,557662966,740064294,1640166671,1699928825,3535942136,622006121,3625353122,68743880,1742502,219489963,1664179233,1577743084,1236991741,410585305,2366487942,823226535,1050371084,3426619607,3586839478,212779912,4147118561,1819446015,1911218849,530248558,3486241071,3252585495,2886188651,3410272728,2342195030,20547779,2982490058,3032363469,3631753222,312714466,1870521650,1493008054,3491686656,615382978,4103671749,2534517445,1932181,2196105170,278426614,6369430,3274544417,2913018367,697336853,2143000447,2946413531,701099306,1558357093,2805003052,3500818408,2321334417,3567135975,216290473,3591032198,23009561,1996984579,3735042806,2024298078,3739440863,569400510,2339758983,3016033873,3097871343,3639523026,3844324983,3256173865,795471839,2951117563,4101031090,4091603803,3603732598,971261452,534414648,428311343,3389027175,2844869880,694888862,1227866773,2456207019,3043454569,2614353370,3749578031,3676663836,459166190,4132644070,1794958188,51825668,2252611902,3084671440,2036672799,3436641603,1099053433,2469121526,3059204941,1323291266,2061838604,1018778475,2233344254,2553501054,334295216,3556750194,1065731521,183467730],a[4]=[2127105028,745436345,2601412319,2788391185,3093987327,500390133,1155374404,389092991,150729210,3891597772,3523549952,1935325696,716645080,946045387,2901812282,1774124410,3869435775,4039581901,3293136918,3438657920,948246080,363898952,3867875531,1286266623,1598556673,68334250,630723836,1104211938,1312863373,613332731,2377784574,1101634306,441780740,3129959883,1917973735,2510624549,3238456535,2544211978,3308894634,1299840618,4076074851,1756332096,3977027158,297047435,3790297736,2265573040,3621810518,1311375015,1667687725,47300608,3299642885,2474112369,201668394,1468347890,576830978,3594690761,3742605952,1958042578,1747032512,3558991340,1408974056,3366841779,682131401,1033214337,1545599232,4265137049,206503691,103024618,2855227313,1337551222,2428998917,2963842932,4015366655,3852247746,2796956967,3865723491,3747938335,247794022,3755824572,702416469,2434691994,397379957,851939612,2314769512,218229120,1380406772,62274761,214451378,3170103466,2276210409,3845813286,28563499,446592073,1693330814,3453727194,29968656,3093872512,220656637,2470637031,77972100,1667708854,1358280214,4064765667,2395616961,325977563,4277240721,4220025399,3605526484,3355147721,811859167,3069544926,3962126810,652502677,3075892249,4132761541,3498924215,1217549313,3250244479,3858715919,3053989961,1538642152,2279026266,2875879137,574252750,3324769229,2651358713,1758150215,141295887,2719868960,3515574750,4093007735,4194485238,1082055363,3417560400,395511885,2966884026,179534037,3646028556,3738688086,1092926436,2496269142,257381841,3772900718,1636087230,1477059743,2499234752,3811018894,2675660129,3285975680,90732309,1684827095,1150307763,1723134115,3237045386,1769919919,1240018934,815675215,750138730,2239792499,1234303040,1995484674,138143821,675421338,1145607174,1936608440,3238603024,2345230278,2105974004,323969391,779555213,3004902369,2861610098,1017501463,2098600890,2628620304,2940611490,2682542546,1171473753,3656571411,3687208071,4091869518,393037935,159126506,1662887367,1147106178,391545844,3452332695,1891500680,3016609650,1851642611,546529401,1167818917,3194020571,2848076033,3953471836,575554290,475796850,4134673196,450035699,2351251534,844027695,1080539133,86184846,1554234488,3692025454,1972511363,2018339607,1491841390,1141460869,1061690759,4244549243,2008416118,2351104703,2868147542,1598468138,722020353,1027143159,212344630,1387219594,1725294528,3745187956,2500153616,458938280,4129215917,1828119673,544571780,3503225445,2297937496,1241802790,267843827,2694610800,1397140384,1558801448,3782667683,1806446719,929573330,2234912681,400817706,616011623,4121520928,3603768725,1761550015,1968522284,4053731006,4192232858,4005120285,872482584,3140537016,3894607381,2287405443,1963876937,3663887957,1584857e3,2975024454,1833426440,4025083860],a[5]=[4143615901,749497569,1285769319,3795025788,2514159847,23610292,3974978748,844452780,3214870880,3751928557,2213566365,1676510905,448177848,3730751033,4086298418,2307502392,871450977,3222878141,4110862042,3831651966,2735270553,1310974780,2043402188,1218528103,2736035353,4274605013,2702448458,3936360550,2693061421,162023535,2827510090,687910808,23484817,3784910947,3371371616,779677500,3503626546,3473927188,4157212626,3500679282,4248902014,2466621104,3899384794,1958663117,925738300,1283408968,3669349440,1840910019,137959847,2679828185,1239142320,1315376211,1547541505,1690155329,739140458,3128809933,3933172616,3876308834,905091803,1548541325,4040461708,3095483362,144808038,451078856,676114313,2861728291,2469707347,993665471,373509091,2599041286,4025009006,4170239449,2149739950,3275793571,3749616649,2794760199,1534877388,572371878,2590613551,1753320020,3467782511,1405125690,4270405205,633333386,3026356924,3475123903,632057672,2846462855,1404951397,3882875879,3915906424,195638627,2385783745,3902872553,1233155085,3355999740,2380578713,2702246304,2144565621,3663341248,3894384975,2502479241,4248018925,3094885567,1594115437,572884632,3385116731,767645374,1331858858,1475698373,3793881790,3532746431,1321687957,619889600,1121017241,3440213920,2070816767,2833025776,1933951238,4095615791,890643334,3874130214,859025556,360630002,925594799,1764062180,3920222280,4078305929,979562269,2810700344,4087740022,1949714515,546639971,1165388173,3069891591,1495988560,922170659,1291546247,2107952832,1813327274,3406010024,3306028637,4241950635,153207855,2313154747,1608695416,1150242611,1967526857,721801357,1220138373,3691287617,3356069787,2112743302,3281662835,1111556101,1778980689,250857638,2298507990,673216130,2846488510,3207751581,3562756981,3008625920,3417367384,2198807050,529510932,3547516680,3426503187,2364944742,102533054,2294910856,1617093527,1204784762,3066581635,1019391227,1069574518,1317995090,1691889997,3661132003,510022745,3238594800,1362108837,1817929911,2184153760,805817662,1953603311,3699844737,120799444,2118332377,207536705,2282301548,4120041617,145305846,2508124933,3086745533,3261524335,1877257368,2977164480,3160454186,2503252186,4221677074,759945014,254147243,2767453419,3801518371,629083197,2471014217,907280572,3900796746,940896768,2751021123,2625262786,3161476951,3661752313,3260732218,1425318020,2977912069,1496677566,3988592072,2140652971,3126511541,3069632175,977771578,1392695845,1698528874,1411812681,1369733098,1343739227,3620887944,1142123638,67414216,3102056737,3088749194,1626167401,2546293654,3941374235,697522451,33404913,143560186,2595682037,994885535,1247667115,3859094837,2699155541,3547024625,4114935275,2968073508,3199963069,2732024527,1237921620,951448369,1898488916,1211705605,2790989240,2233243581,3598044975],a[6]=[2246066201,858518887,1714274303,3485882003,713916271,2879113490,3730835617,539548191,36158695,1298409750,419087104,1358007170,749914897,2989680476,1261868530,2995193822,2690628854,3443622377,3780124940,3796824509,2976433025,4259637129,1551479e3,512490819,1296650241,951993153,2436689437,2460458047,144139966,3136204276,310820559,3068840729,643875328,1969602020,1680088954,2185813161,3283332454,672358534,198762408,896343282,276269502,3014846926,84060815,197145886,376173866,3943890818,3813173521,3545068822,1316698879,1598252827,2633424951,1233235075,859989710,2358460855,3503838400,3409603720,1203513385,1193654839,2792018475,2060853022,207403770,1144516871,3068631394,1121114134,177607304,3785736302,326409831,1929119770,2983279095,4183308101,3474579288,3200513878,3228482096,119610148,1170376745,3378393471,3163473169,951863017,3337026068,3135789130,2907618374,1183797387,2015970143,4045674555,2182986399,2952138740,3928772205,384012900,2454997643,10178499,2879818989,2596892536,111523738,2995089006,451689641,3196290696,235406569,1441906262,3890558523,3013735005,4158569349,1644036924,376726067,1006849064,3664579700,2041234796,1021632941,1374734338,2566452058,371631263,4007144233,490221539,206551450,3140638584,1053219195,1853335209,3412429660,3562156231,735133835,1623211703,3104214392,2738312436,4096837757,3366392578,3110964274,3956598718,3196820781,2038037254,3877786376,2339753847,300912036,3766732888,2372630639,1516443558,4200396704,1574567987,4069441456,4122592016,2699739776,146372218,2748961456,2043888151,35287437,2596680554,655490400,1132482787,110692520,1031794116,2188192751,1324057718,1217253157,919197030,686247489,3261139658,1028237775,3135486431,3059715558,2460921700,986174950,2661811465,4062904701,2752986992,3709736643,367056889,1353824391,731860949,1650113154,1778481506,784341916,357075625,3608602432,1074092588,2480052770,3811426202,92751289,877911070,3600361838,1231880047,480201094,3756190983,3094495953,434011822,87971354,363687820,1717726236,1901380172,3926403882,2481662265,400339184,1490350766,2661455099,1389319756,2558787174,784598401,1983468483,30828846,3550527752,2716276238,3841122214,1765724805,1955612312,1277890269,1333098070,1564029816,2704417615,1026694237,3287671188,1260819201,3349086767,1016692350,1582273796,1073413053,1995943182,694588404,1025494639,3323872702,3551898420,4146854327,453260480,1316140391,1435673405,3038941953,3486689407,1622062951,403978347,817677117,950059133,4246079218,3278066075,1486738320,1417279718,481875527,2549965225,3933690356,760697757,1452955855,3897451437,1177426808,1702951038,4085348628,2447005172,1084371187,3516436277,3068336338,1073369276,1027665953,3284188590,1230553676,1368340146,2226246512,267243139,2274220762,4070734279,2497715176,2423353163,2504755875],a[7]=[3793104909,3151888380,2817252029,895778965,2005530807,3871412763,237245952,86829237,296341424,3851759377,3974600970,2475086196,709006108,1994621201,2972577594,937287164,3734691505,168608556,3189338153,2225080640,3139713551,3033610191,3025041904,77524477,185966941,1208824168,2344345178,1721625922,3354191921,1066374631,1927223579,1971335949,2483503697,1551748602,2881383779,2856329572,3003241482,48746954,1398218158,2050065058,313056748,4255789917,393167848,1912293076,940740642,3465845460,3091687853,2522601570,2197016661,1727764327,364383054,492521376,1291706479,3264136376,1474851438,1685747964,2575719748,1619776915,1814040067,970743798,1561002147,2925768690,2123093554,1880132620,3151188041,697884420,2550985770,2607674513,2659114323,110200136,1489731079,997519150,1378877361,3527870668,478029773,2766872923,1022481122,431258168,1112503832,897933369,2635587303,669726182,3383752315,918222264,163866573,3246985393,3776823163,114105080,1903216136,761148244,3571337562,1690750982,3166750252,1037045171,1888456500,2010454850,642736655,616092351,365016990,1185228132,4174898510,1043824992,2023083429,2241598885,3863320456,3279669087,3674716684,108438443,2132974366,830746235,606445527,4173263986,2204105912,1844756978,2532684181,4245352700,2969441100,3796921661,1335562986,4061524517,2720232303,2679424040,634407289,885462008,3294724487,3933892248,2094100220,339117932,4048830727,3202280980,1458155303,2689246273,1022871705,2464987878,3714515309,353796843,2822958815,4256850100,4052777845,551748367,618185374,3778635579,4020649912,1904685140,3069366075,2670879810,3407193292,2954511620,4058283405,2219449317,3135758300,1120655984,3447565834,1474845562,3577699062,550456716,3466908712,2043752612,881257467,869518812,2005220179,938474677,3305539448,3850417126,1315485940,3318264702,226533026,965733244,321539988,1136104718,804158748,573969341,3708209826,937399083,3290727049,2901666755,1461057207,4013193437,4066861423,3242773476,2421326174,1581322155,3028952165,786071460,3900391652,3918438532,1485433313,4023619836,3708277595,3678951060,953673138,1467089153,1930354364,1533292819,2492563023,1346121658,1685000834,1965281866,3765933717,4190206607,2052792609,3515332758,690371149,3125873887,2180283551,2903598061,3933952357,436236910,289419410,14314871,1242357089,2904507907,1616633776,2666382180,585885352,3471299210,2699507360,1432659641,277164553,3354103607,770115018,2303809295,3741942315,3177781868,2853364978,2269453327,3774259834,987383833,1290892879,225909803,1741533526,890078084,1496906255,1111072499,916028167,243534141,1252605537,2204162171,531204876,290011180,3916834213,102027703,237315147,209093447,1486785922,220223953,2758195998,4175039106,82940208,3127791296,2569425252,518464269,1353887104,3941492737,2377294467,3935040926];}function Ue(e){this.cast5=new De,this.cast5.setKey(e),this.encrypt=function(e){return this.cast5.encrypt(e)};}Ce.keySize=Ce.prototype.keySize=24,Ce.blockSize=Ce.prototype.blockSize=8,Ue.blockSize=Ue.prototype.blockSize=8,Ue.keySize=Ue.prototype.keySize=16;const Re=4294967295;function Ie(e,t){return (e<<t|e>>>32-t)&Re}function Be(e,t){return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24}function Te(e,t,r){e.splice(t,4,255&r,r>>>8&255,r>>>16&255,r>>>24&255);}function ze(e,t){return e>>>8*t&255}function qe(e){this.tf=function(){let e=null,t=null,r=-1,i=[],n=[[],[],[],[]];function a(e){return n[0][ze(e,0)]^n[1][ze(e,1)]^n[2][ze(e,2)]^n[3][ze(e,3)]}function s(e){return n[0][ze(e,3)]^n[1][ze(e,0)]^n[2][ze(e,1)]^n[3][ze(e,2)]}function o(e,t){let r=a(t[0]),n=s(t[1]);t[2]=Ie(t[2]^r+n+i[4*e+8]&Re,31),t[3]=Ie(t[3],1)^r+2*n+i[4*e+9]&Re,r=a(t[2]),n=s(t[3]),t[0]=Ie(t[0]^r+n+i[4*e+10]&Re,31),t[1]=Ie(t[1],1)^r+2*n+i[4*e+11]&Re;}function c(e,t){let r=a(t[0]),n=s(t[1]);t[2]=Ie(t[2],1)^r+n+i[4*e+10]&Re,t[3]=Ie(t[3]^r+2*n+i[4*e+11]&Re,31),r=a(t[2]),n=s(t[3]),t[0]=Ie(t[0],1)^r+n+i[4*e+8]&Re,t[1]=Ie(t[1]^r+2*n+i[4*e+9]&Re,31);}return {name:"twofish",blocksize:16,open:function(t){let r,a,s,o,c;e=t;const u=[],h=[],d=[];let f;const l=[];let p,y,b;const m=[[8,1,7,13,6,15,3,2,0,11,5,9,14,12,10,4],[2,8,11,13,15,7,6,14,3,1,9,4,0,10,12,5]],g=[[14,12,11,8,1,2,3,5,15,4,10,6,7,0,9,13],[1,14,2,11,4,12,3,7,6,13,10,5,15,9,0,8]],w=[[11,10,5,14,6,13,9,0,12,8,15,3,2,4,7,1],[4,12,7,5,1,6,9,10,0,14,13,8,2,11,3,15]],v=[[13,7,15,4,1,2,6,14,9,11,3,0,8,5,12,10],[11,9,5,1,12,3,13,14,6,4,7,15,2,0,8,10]],_=[0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15],k=[0,9,2,11,4,13,6,15,8,1,10,3,12,5,14,7],A=[[],[]],S=[[],[],[],[]];function E(e){return e^e>>2^[0,90,180,238][3&e]}function P(e){return e^e>>1^e>>2^[0,238,180,90][3&e]}function x(e,t){let r,i,n;for(r=0;r<8;r++)i=t>>>24,t=t<<8&Re|e>>>24,e=e<<8&Re,n=i<<1,128&i&&(n^=333),t^=i^n<<16,n^=i>>>1,1&i&&(n^=166),t^=n<<24|n<<8;return t}function M(e,t){const r=t>>4,i=15&t,n=m[e][r^i],a=g[e][_[i]^k[r]];return v[e][_[a]^k[n]]<<4|w[e][n^a]}function K(e,t){let r=ze(e,0),i=ze(e,1),n=ze(e,2),a=ze(e,3);switch(f){case 4:r=A[1][r]^ze(t[3],0),i=A[0][i]^ze(t[3],1),n=A[0][n]^ze(t[3],2),a=A[1][a]^ze(t[3],3);case 3:r=A[1][r]^ze(t[2],0),i=A[1][i]^ze(t[2],1),n=A[0][n]^ze(t[2],2),a=A[0][a]^ze(t[2],3);case 2:r=A[0][A[0][r]^ze(t[1],0)]^ze(t[0],0),i=A[0][A[1][i]^ze(t[1],1)]^ze(t[0],1),n=A[1][A[0][n]^ze(t[1],2)]^ze(t[0],2),a=A[1][A[1][a]^ze(t[1],3)]^ze(t[0],3);}return S[0][r]^S[1][i]^S[2][n]^S[3][a]}for(e=e.slice(0,32),r=e.length;16!==r&&24!==r&&32!==r;)e[r++]=0;for(r=0;r<e.length;r+=4)d[r>>2]=Be(e,r);for(r=0;r<256;r++)A[0][r]=M(0,r),A[1][r]=M(1,r);for(r=0;r<256;r++)p=A[1][r],y=E(p),b=P(p),S[0][r]=p+(y<<8)+(b<<16)+(b<<24),S[2][r]=y+(b<<8)+(p<<16)+(b<<24),p=A[0][r],y=E(p),b=P(p),S[1][r]=b+(b<<8)+(y<<16)+(p<<24),S[3][r]=y+(p<<8)+(b<<16)+(y<<24);for(f=d.length/2,r=0;r<f;r++)a=d[r+r],u[r]=a,s=d[r+r+1],h[r]=s,l[f-r-1]=x(a,s);for(r=0;r<40;r+=2)a=16843009*r,s=a+16843009,a=K(a,u),s=Ie(K(s,h),8),i[r]=a+s&Re,i[r+1]=Ie(a+2*s,9);for(r=0;r<256;r++)switch(a=s=o=c=r,f){case 4:a=A[1][a]^ze(l[3],0),s=A[0][s]^ze(l[3],1),o=A[0][o]^ze(l[3],2),c=A[1][c]^ze(l[3],3);case 3:a=A[1][a]^ze(l[2],0),s=A[1][s]^ze(l[2],1),o=A[0][o]^ze(l[2],2),c=A[0][c]^ze(l[2],3);case 2:n[0][r]=S[0][A[0][A[0][a]^ze(l[1],0)]^ze(l[0],0)],n[1][r]=S[1][A[0][A[1][s]^ze(l[1],1)]^ze(l[0],1)],n[2][r]=S[2][A[1][A[0][o]^ze(l[1],2)]^ze(l[0],2)],n[3][r]=S[3][A[1][A[1][c]^ze(l[1],3)]^ze(l[0],3)];}},close:function(){i=[],n=[[],[],[],[]];},encrypt:function(e,n){t=e,r=n;const a=[Be(t,r)^i[0],Be(t,r+4)^i[1],Be(t,r+8)^i[2],Be(t,r+12)^i[3]];for(let e=0;e<8;e++)o(e,a);return Te(t,r,a[2]^i[4]),Te(t,r+4,a[3]^i[5]),Te(t,r+8,a[0]^i[6]),Te(t,r+12,a[1]^i[7]),r+=16,t},decrypt:function(e,n){t=e,r=n;const a=[Be(t,r)^i[4],Be(t,r+4)^i[5],Be(t,r+8)^i[6],Be(t,r+12)^i[7]];for(let e=7;e>=0;e--)c(e,a);Te(t,r,a[2]^i[0]),Te(t,r+4,a[3]^i[1]),Te(t,r+8,a[0]^i[2]),Te(t,r+12,a[1]^i[3]),r+=16;},finalize:function(){return t}}}(),this.tf.open(Array.from(e),0),this.encrypt=function(e){return this.tf.encrypt(Array.from(e),0)};}function Fe(){}function Oe(e){this.bf=new Fe,this.bf.init(e),this.encrypt=function(e){return this.bf.encryptBlock(e)};}qe.keySize=qe.prototype.keySize=32,qe.blockSize=qe.prototype.blockSize=16,Fe.prototype.BLOCKSIZE=8,Fe.prototype.SBOXES=[[3509652390,2564797868,805139163,3491422135,3101798381,1780907670,3128725573,4046225305,614570311,3012652279,134345442,2240740374,1667834072,1901547113,2757295779,4103290238,227898511,1921955416,1904987480,2182433518,2069144605,3260701109,2620446009,720527379,3318853667,677414384,3393288472,3101374703,2390351024,1614419982,1822297739,2954791486,3608508353,3174124327,2024746970,1432378464,3864339955,2857741204,1464375394,1676153920,1439316330,715854006,3033291828,289532110,2706671279,2087905683,3018724369,1668267050,732546397,1947742710,3462151702,2609353502,2950085171,1814351708,2050118529,680887927,999245976,1800124847,3300911131,1713906067,1641548236,4213287313,1216130144,1575780402,4018429277,3917837745,3693486850,3949271944,596196993,3549867205,258830323,2213823033,772490370,2760122372,1774776394,2652871518,566650946,4142492826,1728879713,2882767088,1783734482,3629395816,2517608232,2874225571,1861159788,326777828,3124490320,2130389656,2716951837,967770486,1724537150,2185432712,2364442137,1164943284,2105845187,998989502,3765401048,2244026483,1075463327,1455516326,1322494562,910128902,469688178,1117454909,936433444,3490320968,3675253459,1240580251,122909385,2157517691,634681816,4142456567,3825094682,3061402683,2540495037,79693498,3249098678,1084186820,1583128258,426386531,1761308591,1047286709,322548459,995290223,1845252383,2603652396,3431023940,2942221577,3202600964,3727903485,1712269319,422464435,3234572375,1170764815,3523960633,3117677531,1434042557,442511882,3600875718,1076654713,1738483198,4213154764,2393238008,3677496056,1014306527,4251020053,793779912,2902807211,842905082,4246964064,1395751752,1040244610,2656851899,3396308128,445077038,3742853595,3577915638,679411651,2892444358,2354009459,1767581616,3150600392,3791627101,3102740896,284835224,4246832056,1258075500,768725851,2589189241,3069724005,3532540348,1274779536,3789419226,2764799539,1660621633,3471099624,4011903706,913787905,3497959166,737222580,2514213453,2928710040,3937242737,1804850592,3499020752,2949064160,2386320175,2390070455,2415321851,4061277028,2290661394,2416832540,1336762016,1754252060,3520065937,3014181293,791618072,3188594551,3933548030,2332172193,3852520463,3043980520,413987798,3465142937,3030929376,4245938359,2093235073,3534596313,375366246,2157278981,2479649556,555357303,3870105701,2008414854,3344188149,4221384143,3956125452,2067696032,3594591187,2921233993,2428461,544322398,577241275,1471733935,610547355,4027169054,1432588573,1507829418,2025931657,3646575487,545086370,48609733,2200306550,1653985193,298326376,1316178497,3007786442,2064951626,458293330,2589141269,3591329599,3164325604,727753846,2179363840,146436021,1461446943,4069977195,705550613,3059967265,3887724982,4281599278,3313849956,1404054877,2845806497,146425753,1854211946],[1266315497,3048417604,3681880366,3289982499,290971e4,1235738493,2632868024,2414719590,3970600049,1771706367,1449415276,3266420449,422970021,1963543593,2690192192,3826793022,1062508698,1531092325,1804592342,2583117782,2714934279,4024971509,1294809318,4028980673,1289560198,2221992742,1669523910,35572830,157838143,1052438473,1016535060,1802137761,1753167236,1386275462,3080475397,2857371447,1040679964,2145300060,2390574316,1461121720,2956646967,4031777805,4028374788,33600511,2920084762,1018524850,629373528,3691585981,3515945977,2091462646,2486323059,586499841,988145025,935516892,3367335476,2599673255,2839830854,265290510,3972581182,2759138881,3795373465,1005194799,847297441,406762289,1314163512,1332590856,1866599683,4127851711,750260880,613907577,1450815602,3165620655,3734664991,3650291728,3012275730,3704569646,1427272223,778793252,1343938022,2676280711,2052605720,1946737175,3164576444,3914038668,3967478842,3682934266,1661551462,3294938066,4011595847,840292616,3712170807,616741398,312560963,711312465,1351876610,322626781,1910503582,271666773,2175563734,1594956187,70604529,3617834859,1007753275,1495573769,4069517037,2549218298,2663038764,504708206,2263041392,3941167025,2249088522,1514023603,1998579484,1312622330,694541497,2582060303,2151582166,1382467621,776784248,2618340202,3323268794,2497899128,2784771155,503983604,4076293799,907881277,423175695,432175456,1378068232,4145222326,3954048622,3938656102,3820766613,2793130115,2977904593,26017576,3274890735,3194772133,1700274565,1756076034,4006520079,3677328699,720338349,1533947780,354530856,688349552,3973924725,1637815568,332179504,3949051286,53804574,2852348879,3044236432,1282449977,3583942155,3416972820,4006381244,1617046695,2628476075,3002303598,1686838959,431878346,2686675385,1700445008,1080580658,1009431731,832498133,3223435511,2605976345,2271191193,2516031870,1648197032,4164389018,2548247927,300782431,375919233,238389289,3353747414,2531188641,2019080857,1475708069,455242339,2609103871,448939670,3451063019,1395535956,2413381860,1841049896,1491858159,885456874,4264095073,4001119347,1565136089,3898914787,1108368660,540939232,1173283510,2745871338,3681308437,4207628240,3343053890,4016749493,1699691293,1103962373,3625875870,2256883143,3830138730,1031889488,3479347698,1535977030,4236805024,3251091107,2132092099,1774941330,1199868427,1452454533,157007616,2904115357,342012276,595725824,1480756522,206960106,497939518,591360097,863170706,2375253569,3596610801,1814182875,2094937945,3421402208,1082520231,3463918190,2785509508,435703966,3908032597,1641649973,2842273706,3305899714,1510255612,2148256476,2655287854,3276092548,4258621189,236887753,3681803219,274041037,1734335097,3815195456,3317970021,1899903192,1026095262,4050517792,356393447,2410691914,3873677099,3682840055],[3913112168,2491498743,4132185628,2489919796,1091903735,1979897079,3170134830,3567386728,3557303409,857797738,1136121015,1342202287,507115054,2535736646,337727348,3213592640,1301675037,2528481711,1895095763,1721773893,3216771564,62756741,2142006736,835421444,2531993523,1442658625,3659876326,2882144922,676362277,1392781812,170690266,3921047035,1759253602,3611846912,1745797284,664899054,1329594018,3901205900,3045908486,2062866102,2865634940,3543621612,3464012697,1080764994,553557557,3656615353,3996768171,991055499,499776247,1265440854,648242737,3940784050,980351604,3713745714,1749149687,3396870395,4211799374,3640570775,1161844396,3125318951,1431517754,545492359,4268468663,3499529547,1437099964,2702547544,3433638243,2581715763,2787789398,1060185593,1593081372,2418618748,4260947970,69676912,2159744348,86519011,2512459080,3838209314,1220612927,3339683548,133810670,1090789135,1078426020,1569222167,845107691,3583754449,4072456591,1091646820,628848692,1613405280,3757631651,526609435,236106946,48312990,2942717905,3402727701,1797494240,859738849,992217954,4005476642,2243076622,3870952857,3732016268,765654824,3490871365,2511836413,1685915746,3888969200,1414112111,2273134842,3281911079,4080962846,172450625,2569994100,980381355,4109958455,2819808352,2716589560,2568741196,3681446669,3329971472,1835478071,660984891,3704678404,4045999559,3422617507,3040415634,1762651403,1719377915,3470491036,2693910283,3642056355,3138596744,1364962596,2073328063,1983633131,926494387,3423689081,2150032023,4096667949,1749200295,3328846651,309677260,2016342300,1779581495,3079819751,111262694,1274766160,443224088,298511866,1025883608,3806446537,1145181785,168956806,3641502830,3584813610,1689216846,3666258015,3200248200,1692713982,2646376535,4042768518,1618508792,1610833997,3523052358,4130873264,2001055236,3610705100,2202168115,4028541809,2961195399,1006657119,2006996926,3186142756,1430667929,3210227297,1314452623,4074634658,4101304120,2273951170,1399257539,3367210612,3027628629,1190975929,2062231137,2333990788,2221543033,2438960610,1181637006,548689776,2362791313,3372408396,3104550113,3145860560,296247880,1970579870,3078560182,3769228297,1714227617,3291629107,3898220290,166772364,1251581989,493813264,448347421,195405023,2709975567,677966185,3703036547,1463355134,2715995803,1338867538,1343315457,2802222074,2684532164,233230375,2599980071,2000651841,3277868038,1638401717,4028070440,3237316320,6314154,819756386,300326615,590932579,1405279636,3267499572,3150704214,2428286686,3959192993,3461946742,1862657033,1266418056,963775037,2089974820,2263052895,1917689273,448879540,3550394620,3981727096,150775221,3627908307,1303187396,508620638,2975983352,2726630617,1817252668,1876281319,1457606340,908771278,3720792119,3617206836,2455994898,1729034894,1080033504],[976866871,3556439503,2881648439,1522871579,1555064734,1336096578,3548522304,2579274686,3574697629,3205460757,3593280638,3338716283,3079412587,564236357,2993598910,1781952180,1464380207,3163844217,3332601554,1699332808,1393555694,1183702653,3581086237,1288719814,691649499,2847557200,2895455976,3193889540,2717570544,1781354906,1676643554,2592534050,3230253752,1126444790,2770207658,2633158820,2210423226,2615765581,2414155088,3127139286,673620729,2805611233,1269405062,4015350505,3341807571,4149409754,1057255273,2012875353,2162469141,2276492801,2601117357,993977747,3918593370,2654263191,753973209,36408145,2530585658,25011837,3520020182,2088578344,530523599,2918365339,1524020338,1518925132,3760827505,3759777254,1202760957,3985898139,3906192525,674977740,4174734889,2031300136,2019492241,3983892565,4153806404,3822280332,352677332,2297720250,60907813,90501309,3286998549,1016092578,2535922412,2839152426,457141659,509813237,4120667899,652014361,1966332200,2975202805,55981186,2327461051,676427537,3255491064,2882294119,3433927263,1307055953,942726286,933058658,2468411793,3933900994,4215176142,1361170020,2001714738,2830558078,3274259782,1222529897,1679025792,2729314320,3714953764,1770335741,151462246,3013232138,1682292957,1483529935,471910574,1539241949,458788160,3436315007,1807016891,3718408830,978976581,1043663428,3165965781,1927990952,4200891579,2372276910,3208408903,3533431907,1412390302,2931980059,4132332400,1947078029,3881505623,4168226417,2941484381,1077988104,1320477388,886195818,18198404,3786409e3,2509781533,112762804,3463356488,1866414978,891333506,18488651,661792760,1628790961,3885187036,3141171499,876946877,2693282273,1372485963,791857591,2686433993,3759982718,3167212022,3472953795,2716379847,445679433,3561995674,3504004811,3574258232,54117162,3331405415,2381918588,3769707343,4154350007,1140177722,4074052095,668550556,3214352940,367459370,261225585,2610173221,4209349473,3468074219,3265815641,314222801,3066103646,3808782860,282218597,3406013506,3773591054,379116347,1285071038,846784868,2669647154,3771962079,3550491691,2305946142,453669953,1268987020,3317592352,3279303384,3744833421,2610507566,3859509063,266596637,3847019092,517658769,3462560207,3443424879,370717030,4247526661,2224018117,4143653529,4112773975,2788324899,2477274417,1456262402,2901442914,1517677493,1846949527,2295493580,3734397586,2176403920,1280348187,1908823572,3871786941,846861322,1172426758,3287448474,3383383037,1655181056,3139813346,901632758,1897031941,2986607138,3066810236,3447102507,1393639104,373351379,950779232,625454576,3124240540,4148612726,2007998917,544563296,2244738638,2330496472,2058025392,1291430526,424198748,50039436,29584100,3605783033,2429876329,2791104160,1057563949,3255363231,3075367218,3463963227,1469046755,985887462]],Fe.prototype.PARRAY=[608135816,2242054355,320440878,57701188,2752067618,698298832,137296536,3964562569,1160258022,953160567,3193202383,887688300,3232508343,3380367581,1065670069,3041331479,2450970073,2306472731],Fe.prototype.NN=16,Fe.prototype._clean=function(e){if(e<0){e=(2147483647&e)+2147483648;}return e},Fe.prototype._F=function(e){let t;const r=255&e,i=255&(e>>>=8),n=255&(e>>>=8),a=255&(e>>>=8);return t=this.sboxes[0][a]+this.sboxes[1][n],t^=this.sboxes[2][i],t+=this.sboxes[3][r],t},Fe.prototype._encryptBlock=function(e){let t,r=e[0],i=e[1];for(t=0;t<this.NN;++t){r^=this.parray[t],i=this._F(r)^i;const e=r;r=i,i=e;}r^=this.parray[this.NN+0],i^=this.parray[this.NN+1],e[0]=this._clean(i),e[1]=this._clean(r);},Fe.prototype.encryptBlock=function(e){let t;const r=[0,0],i=this.BLOCKSIZE/2;for(t=0;t<this.BLOCKSIZE/2;++t)r[0]=r[0]<<8|255&e[t+0],r[1]=r[1]<<8|255&e[t+i];this._encryptBlock(r);const n=[];for(t=0;t<this.BLOCKSIZE/2;++t)n[t+0]=r[0]>>>24-8*t&255,n[t+i]=r[1]>>>24-8*t&255;return n},Fe.prototype._decryptBlock=function(e){let t,r=e[0],i=e[1];for(t=this.NN+1;t>1;--t){r^=this.parray[t],i=this._F(r)^i;const e=r;r=i,i=e;}r^=this.parray[1],i^=this.parray[0],e[0]=this._clean(i),e[1]=this._clean(r);},Fe.prototype.init=function(e){let t,r=0;for(this.parray=[],t=0;t<this.NN+2;++t){let i=0;for(let t=0;t<4;++t)i=i<<8|255&e[r],++r>=e.length&&(r=0);this.parray[t]=this.PARRAY[t]^i;}for(this.sboxes=[],t=0;t<4;++t)for(this.sboxes[t]=[],r=0;r<256;++r)this.sboxes[t][r]=this.SBOXES[t][r];const i=[0,0];for(t=0;t<this.NN+2;t+=2)this._encryptBlock(i),this.parray[t+0]=i[0],this.parray[t+1]=i[1];for(t=0;t<4;++t)for(r=0;r<256;r+=2)this._encryptBlock(i),this.sboxes[t][r+0]=i[0],this.sboxes[t][r+1]=i[1];},Oe.keySize=Oe.prototype.keySize=16,Oe.blockSize=Oe.prototype.blockSize=8;const Le=xe(128),Ne=xe(192),je=xe(256),He=function(e){this.key=e,this.encrypt=function(e,t){return Me(Ke(this.key),e,!0,0,null,t)},this.decrypt=function(e,t){return Me(Ke(this.key),e,!1,0,null,t)};};var We=/*#__PURE__*/Object.freeze({__proto__:null,aes128:Le,aes192:Ne,aes256:je,des:He,tripledes:Ce,cast5:Ue,twofish:qe,blowfish:Oe,idea:function(){throw Error("IDEA symmetric-key algorithm not implemented")}}),Ge=function(e,t,r){"use asm";var i=0,n=0,a=0,s=0,o=0,c=0,u=0;var h=0,d=0,f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0;var v=new e.Uint8Array(r);function _(e,t,r,c,u,h,d,f,l,p,y,b,m,g,w,v){e=e|0;t=t|0;r=r|0;c=c|0;u=u|0;h=h|0;d=d|0;f=f|0;l=l|0;p=p|0;y=y|0;b=b|0;m=m|0;g=g|0;w=w|0;v=v|0;var _=0,k=0,A=0,S=0,E=0,P=0,x=0,M=0,K=0,C=0,D=0,U=0,R=0,I=0,B=0,T=0,z=0,q=0,F=0,O=0,L=0,N=0,j=0,H=0,W=0,G=0,V=0,$=0,Z=0,X=0,Y=0,Q=0,J=0,ee=0,te=0,re=0,ie=0,ne=0,ae=0,se=0,oe=0,ce=0,ue=0,he=0,de=0,fe=0,le=0,pe=0,ye=0,be=0,me=0,ge=0,we=0,ve=0,_e=0,ke=0,Ae=0,Se=0,Ee=0,Pe=0,xe=0,Me=0,Ke=0,Ce=0,De=0,Ue=0,Re=0,Ie=0,Be=0,Te=0,ze=0;_=i;k=n;A=a;S=s;E=o;x=e+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=t+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=r+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=c+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=u+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=h+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=d+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=f+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=l+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=p+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=y+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=b+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=m+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=g+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=w+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;x=v+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=g^l^r^e;M=P<<1|P>>>31;x=M+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=w^p^c^t;K=P<<1|P>>>31;x=K+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=v^y^u^r;C=P<<1|P>>>31;x=C+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=M^b^h^c;D=P<<1|P>>>31;x=D+(_<<5|_>>>27)+E+(k&A|~k&S)+0x5a827999|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=K^m^d^u;U=P<<1|P>>>31;x=U+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=C^g^f^h;R=P<<1|P>>>31;x=R+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=D^w^l^d;I=P<<1|P>>>31;x=I+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=U^v^p^f;B=P<<1|P>>>31;x=B+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=R^M^y^l;T=P<<1|P>>>31;x=T+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=I^K^b^p;z=P<<1|P>>>31;x=z+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=B^C^m^y;q=P<<1|P>>>31;x=q+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=T^D^g^b;F=P<<1|P>>>31;x=F+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=z^U^w^m;O=P<<1|P>>>31;x=O+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=q^R^v^g;L=P<<1|P>>>31;x=L+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=F^I^M^w;N=P<<1|P>>>31;x=N+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=O^B^K^v;j=P<<1|P>>>31;x=j+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=L^T^C^M;H=P<<1|P>>>31;x=H+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=N^z^D^K;W=P<<1|P>>>31;x=W+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=j^q^U^C;G=P<<1|P>>>31;x=G+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=H^F^R^D;V=P<<1|P>>>31;x=V+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=W^O^I^U;$=P<<1|P>>>31;x=$+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=G^L^B^R;Z=P<<1|P>>>31;x=Z+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=V^N^T^I;X=P<<1|P>>>31;x=X+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=$^j^z^B;Y=P<<1|P>>>31;x=Y+(_<<5|_>>>27)+E+(k^A^S)+0x6ed9eba1|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Z^H^q^T;Q=P<<1|P>>>31;x=Q+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=X^W^F^z;J=P<<1|P>>>31;x=J+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Y^G^O^q;ee=P<<1|P>>>31;x=ee+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Q^V^L^F;te=P<<1|P>>>31;x=te+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=J^$^N^O;re=P<<1|P>>>31;x=re+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ee^Z^j^L;ie=P<<1|P>>>31;x=ie+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=te^X^H^N;ne=P<<1|P>>>31;x=ne+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=re^Y^W^j;ae=P<<1|P>>>31;x=ae+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ie^Q^G^H;se=P<<1|P>>>31;x=se+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ne^J^V^W;oe=P<<1|P>>>31;x=oe+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ae^ee^$^G;ce=P<<1|P>>>31;x=ce+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=se^te^Z^V;ue=P<<1|P>>>31;x=ue+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=oe^re^X^$;he=P<<1|P>>>31;x=he+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ce^ie^Y^Z;de=P<<1|P>>>31;x=de+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ue^ne^Q^X;fe=P<<1|P>>>31;x=fe+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=he^ae^J^Y;le=P<<1|P>>>31;x=le+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=de^se^ee^Q;pe=P<<1|P>>>31;x=pe+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=fe^oe^te^J;ye=P<<1|P>>>31;x=ye+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=le^ce^re^ee;be=P<<1|P>>>31;x=be+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=pe^ue^ie^te;me=P<<1|P>>>31;x=me+(_<<5|_>>>27)+E+(k&A|k&S|A&S)-0x70e44324|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ye^he^ne^re;ge=P<<1|P>>>31;x=ge+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=be^de^ae^ie;we=P<<1|P>>>31;x=we+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=me^fe^se^ne;ve=P<<1|P>>>31;x=ve+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ge^le^oe^ae;_e=P<<1|P>>>31;x=_e+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=we^pe^ce^se;ke=P<<1|P>>>31;x=ke+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ve^ye^ue^oe;Ae=P<<1|P>>>31;x=Ae+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=_e^be^he^ce;Se=P<<1|P>>>31;x=Se+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=ke^me^de^ue;Ee=P<<1|P>>>31;x=Ee+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Ae^ge^fe^he;Pe=P<<1|P>>>31;x=Pe+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Se^we^le^de;xe=P<<1|P>>>31;x=xe+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Ee^ve^pe^fe;Me=P<<1|P>>>31;x=Me+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Pe^_e^ye^le;Ke=P<<1|P>>>31;x=Ke+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=xe^ke^be^pe;Ce=P<<1|P>>>31;x=Ce+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Me^Ae^me^ye;De=P<<1|P>>>31;x=De+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Ke^Se^ge^be;Ue=P<<1|P>>>31;x=Ue+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Ce^Ee^we^me;Re=P<<1|P>>>31;x=Re+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=De^Pe^ve^ge;Ie=P<<1|P>>>31;x=Ie+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Ue^xe^_e^we;Be=P<<1|P>>>31;x=Be+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Re^Me^ke^ve;Te=P<<1|P>>>31;x=Te+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;P=Ie^Ke^Ae^_e;ze=P<<1|P>>>31;x=ze+(_<<5|_>>>27)+E+(k^A^S)-0x359d3e2a|0;E=S;S=A;A=k<<30|k>>>2;k=_;_=x;i=i+_|0;n=n+k|0;a=a+A|0;s=s+S|0;o=o+E|0;}function k(e){e=e|0;_(v[e|0]<<24|v[e|1]<<16|v[e|2]<<8|v[e|3],v[e|4]<<24|v[e|5]<<16|v[e|6]<<8|v[e|7],v[e|8]<<24|v[e|9]<<16|v[e|10]<<8|v[e|11],v[e|12]<<24|v[e|13]<<16|v[e|14]<<8|v[e|15],v[e|16]<<24|v[e|17]<<16|v[e|18]<<8|v[e|19],v[e|20]<<24|v[e|21]<<16|v[e|22]<<8|v[e|23],v[e|24]<<24|v[e|25]<<16|v[e|26]<<8|v[e|27],v[e|28]<<24|v[e|29]<<16|v[e|30]<<8|v[e|31],v[e|32]<<24|v[e|33]<<16|v[e|34]<<8|v[e|35],v[e|36]<<24|v[e|37]<<16|v[e|38]<<8|v[e|39],v[e|40]<<24|v[e|41]<<16|v[e|42]<<8|v[e|43],v[e|44]<<24|v[e|45]<<16|v[e|46]<<8|v[e|47],v[e|48]<<24|v[e|49]<<16|v[e|50]<<8|v[e|51],v[e|52]<<24|v[e|53]<<16|v[e|54]<<8|v[e|55],v[e|56]<<24|v[e|57]<<16|v[e|58]<<8|v[e|59],v[e|60]<<24|v[e|61]<<16|v[e|62]<<8|v[e|63]);}function A(e){e=e|0;v[e|0]=i>>>24;v[e|1]=i>>>16&255;v[e|2]=i>>>8&255;v[e|3]=i&255;v[e|4]=n>>>24;v[e|5]=n>>>16&255;v[e|6]=n>>>8&255;v[e|7]=n&255;v[e|8]=a>>>24;v[e|9]=a>>>16&255;v[e|10]=a>>>8&255;v[e|11]=a&255;v[e|12]=s>>>24;v[e|13]=s>>>16&255;v[e|14]=s>>>8&255;v[e|15]=s&255;v[e|16]=o>>>24;v[e|17]=o>>>16&255;v[e|18]=o>>>8&255;v[e|19]=o&255;}function S(){i=0x67452301;n=0xefcdab89;a=0x98badcfe;s=0x10325476;o=0xc3d2e1f0;c=u=0;}function E(e,t,r,h,d,f,l){e=e|0;t=t|0;r=r|0;h=h|0;d=d|0;f=f|0;l=l|0;i=e;n=t;a=r;s=h;o=d;c=f;u=l;}function P(e,t){e=e|0;t=t|0;var r=0;if(e&63)return -1;while((t|0)>=64){k(e);e=e+64|0;t=t-64|0;r=r+64|0;}c=c+r|0;if(c>>>0<r>>>0)u=u+1|0;return r|0}function x(e,t,r){e=e|0;t=t|0;r=r|0;var i=0,n=0;if(e&63)return -1;if(~r)if(r&31)return -1;if((t|0)>=64){i=P(e,t)|0;if((i|0)==-1)return -1;e=e+i|0;t=t-i|0;}i=i+t|0;c=c+t|0;if(c>>>0<t>>>0)u=u+1|0;v[e|t]=0x80;if((t|0)>=56){for(n=t+1|0;(n|0)<64;n=n+1|0)v[e|n]=0x00;k(e);t=0;v[e|0]=0;}for(n=t+1|0;(n|0)<59;n=n+1|0)v[e|n]=0;v[e|56]=u>>>21&255;v[e|57]=u>>>13&255;v[e|58]=u>>>5&255;v[e|59]=u<<3&255|c>>>29;v[e|60]=c>>>21&255;v[e|61]=c>>>13&255;v[e|62]=c>>>5&255;v[e|63]=c<<3&255;k(e);if(~r)A(r);return i|0}function M(){i=h;n=d;a=f;s=l;o=p;c=64;u=0;}function K(){i=y;n=b;a=m;s=g;o=w;c=64;u=0;}function C(e,t,r,v,k,A,E,P,x,M,K,C,D,U,R,I){e=e|0;t=t|0;r=r|0;v=v|0;k=k|0;A=A|0;E=E|0;P=P|0;x=x|0;M=M|0;K=K|0;C=C|0;D=D|0;U=U|0;R=R|0;I=I|0;S();_(e^0x5c5c5c5c,t^0x5c5c5c5c,r^0x5c5c5c5c,v^0x5c5c5c5c,k^0x5c5c5c5c,A^0x5c5c5c5c,E^0x5c5c5c5c,P^0x5c5c5c5c,x^0x5c5c5c5c,M^0x5c5c5c5c,K^0x5c5c5c5c,C^0x5c5c5c5c,D^0x5c5c5c5c,U^0x5c5c5c5c,R^0x5c5c5c5c,I^0x5c5c5c5c);y=i;b=n;m=a;g=s;w=o;S();_(e^0x36363636,t^0x36363636,r^0x36363636,v^0x36363636,k^0x36363636,A^0x36363636,E^0x36363636,P^0x36363636,x^0x36363636,M^0x36363636,K^0x36363636,C^0x36363636,D^0x36363636,U^0x36363636,R^0x36363636,I^0x36363636);h=i;d=n;f=a;l=s;p=o;c=64;u=0;}function D(e,t,r){e=e|0;t=t|0;r=r|0;var c=0,u=0,h=0,d=0,f=0,l=0;if(e&63)return -1;if(~r)if(r&31)return -1;l=x(e,t,-1)|0;c=i,u=n,h=a,d=s,f=o;K();_(c,u,h,d,f,0x80000000,0,0,0,0,0,0,0,0,0,672);if(~r)A(r);return l|0}function U(e,t,r,c,u){e=e|0;t=t|0;r=r|0;c=c|0;u=u|0;var h=0,d=0,f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0;if(e&63)return -1;if(~u)if(u&31)return -1;v[e+t|0]=r>>>24;v[e+t+1|0]=r>>>16&255;v[e+t+2|0]=r>>>8&255;v[e+t+3|0]=r&255;D(e,t+4|0,-1)|0;h=y=i,d=b=n,f=m=a,l=g=s,p=w=o;c=c-1|0;while((c|0)>0){M();_(y,b,m,g,w,0x80000000,0,0,0,0,0,0,0,0,0,672);y=i,b=n,m=a,g=s,w=o;K();_(y,b,m,g,w,0x80000000,0,0,0,0,0,0,0,0,0,672);y=i,b=n,m=a,g=s,w=o;h=h^i;d=d^n;f=f^a;l=l^s;p=p^o;c=c-1|0;}i=h;n=d;a=f;s=l;o=p;if(~u)A(u);return 0}return {reset:S,init:E,process:P,finish:x,hmac_reset:M,hmac_init:C,hmac_finish:D,pbkdf2_generate_block:U}};class Ve{constructor(){this.pos=0,this.len=0;}reset(){const{asm:e}=this.acquire_asm();return this.result=null,this.pos=0,this.len=0,e.reset(),this}process(e){if(null!==this.result)throw new ve("state must be reset before processing new data");const{asm:t,heap:r}=this.acquire_asm();let i=this.pos,n=this.len,a=0,s=e.length,o=0;for(;s>0;)o=ge(r,i+n,e,a,s),n+=o,a+=o,s-=o,o=t.process(i,n),i+=o,n-=o,n||(i=0);return this.pos=i,this.len=n,this}finish(){if(null!==this.result)throw new ve("state must be reset before processing new data");const{asm:e,heap:t}=this.acquire_asm();return e.finish(this.pos,this.len,0),this.result=new Uint8Array(this.HASH_SIZE),this.result.set(t.subarray(0,this.HASH_SIZE)),this.pos=0,this.len=0,this.release_asm(),this}}const $e=[],Ze=[];class Xe extends Ve{constructor(){super(),this.NAME="sha1",this.BLOCK_SIZE=64,this.HASH_SIZE=20,this.acquire_asm();}acquire_asm(){return void 0!==this.heap&&void 0!==this.asm||(this.heap=$e.pop()||me(),this.asm=Ze.pop()||Ge({Uint8Array},null,this.heap.buffer),this.reset()),{heap:this.heap,asm:this.asm}}release_asm(){void 0!==this.heap&&void 0!==this.asm&&($e.push(this.heap),Ze.push(this.asm)),this.heap=void 0,this.asm=void 0;}static bytes(e){return (new Xe).process(e).finish().result}}Xe.NAME="sha1",Xe.heap_pool=[],Xe.asm_pool=[],Xe.asm_function=Ge;const Ye=[],Qe=[];class Je extends Ve{constructor(){super(),this.NAME="sha256",this.BLOCK_SIZE=64,this.HASH_SIZE=32,this.acquire_asm();}acquire_asm(){return void 0!==this.heap&&void 0!==this.asm||(this.heap=Ye.pop()||me(),this.asm=Qe.pop()||function(e,t,r){"use asm";var i=0,n=0,a=0,s=0,o=0,c=0,u=0,h=0,d=0,f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0,v=0,_=0,k=0,A=0,S=0,E=0,P=0,x=0,M=0,K=new e.Uint8Array(r);function C(e,t,r,d,f,l,p,y,b,m,g,w,v,_,k,A){e=e|0;t=t|0;r=r|0;d=d|0;f=f|0;l=l|0;p=p|0;y=y|0;b=b|0;m=m|0;g=g|0;w=w|0;v=v|0;_=_|0;k=k|0;A=A|0;var S=0,E=0,P=0,x=0,M=0,K=0,C=0,D=0;S=i;E=n;P=a;x=s;M=o;K=c;C=u;D=h;D=e+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0x428a2f98|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;C=t+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0x71374491|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;K=r+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0xb5c0fbcf|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;M=d+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0xe9b5dba5|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;x=f+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0x3956c25b|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;P=l+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0x59f111f1|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;E=p+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0x923f82a4|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;S=y+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0xab1c5ed5|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;D=b+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0xd807aa98|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;C=m+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0x12835b01|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;K=g+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0x243185be|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;M=w+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0x550c7dc3|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;x=v+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0x72be5d74|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;P=_+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0x80deb1fe|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;E=k+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0x9bdc06a7|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;S=A+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0xc19bf174|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;e=(t>>>7^t>>>18^t>>>3^t<<25^t<<14)+(k>>>17^k>>>19^k>>>10^k<<15^k<<13)+e+m|0;D=e+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0xe49b69c1|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;t=(r>>>7^r>>>18^r>>>3^r<<25^r<<14)+(A>>>17^A>>>19^A>>>10^A<<15^A<<13)+t+g|0;C=t+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0xefbe4786|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;r=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+r+w|0;K=r+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0x0fc19dc6|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;d=(f>>>7^f>>>18^f>>>3^f<<25^f<<14)+(t>>>17^t>>>19^t>>>10^t<<15^t<<13)+d+v|0;M=d+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0x240ca1cc|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;f=(l>>>7^l>>>18^l>>>3^l<<25^l<<14)+(r>>>17^r>>>19^r>>>10^r<<15^r<<13)+f+_|0;x=f+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0x2de92c6f|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;l=(p>>>7^p>>>18^p>>>3^p<<25^p<<14)+(d>>>17^d>>>19^d>>>10^d<<15^d<<13)+l+k|0;P=l+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0x4a7484aa|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;p=(y>>>7^y>>>18^y>>>3^y<<25^y<<14)+(f>>>17^f>>>19^f>>>10^f<<15^f<<13)+p+A|0;E=p+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0x5cb0a9dc|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;y=(b>>>7^b>>>18^b>>>3^b<<25^b<<14)+(l>>>17^l>>>19^l>>>10^l<<15^l<<13)+y+e|0;S=y+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0x76f988da|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;b=(m>>>7^m>>>18^m>>>3^m<<25^m<<14)+(p>>>17^p>>>19^p>>>10^p<<15^p<<13)+b+t|0;D=b+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0x983e5152|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;m=(g>>>7^g>>>18^g>>>3^g<<25^g<<14)+(y>>>17^y>>>19^y>>>10^y<<15^y<<13)+m+r|0;C=m+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0xa831c66d|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;g=(w>>>7^w>>>18^w>>>3^w<<25^w<<14)+(b>>>17^b>>>19^b>>>10^b<<15^b<<13)+g+d|0;K=g+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0xb00327c8|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;w=(v>>>7^v>>>18^v>>>3^v<<25^v<<14)+(m>>>17^m>>>19^m>>>10^m<<15^m<<13)+w+f|0;M=w+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0xbf597fc7|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;v=(_>>>7^_>>>18^_>>>3^_<<25^_<<14)+(g>>>17^g>>>19^g>>>10^g<<15^g<<13)+v+l|0;x=v+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0xc6e00bf3|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;_=(k>>>7^k>>>18^k>>>3^k<<25^k<<14)+(w>>>17^w>>>19^w>>>10^w<<15^w<<13)+_+p|0;P=_+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0xd5a79147|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;k=(A>>>7^A>>>18^A>>>3^A<<25^A<<14)+(v>>>17^v>>>19^v>>>10^v<<15^v<<13)+k+y|0;E=k+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0x06ca6351|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;A=(e>>>7^e>>>18^e>>>3^e<<25^e<<14)+(_>>>17^_>>>19^_>>>10^_<<15^_<<13)+A+b|0;S=A+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0x14292967|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;e=(t>>>7^t>>>18^t>>>3^t<<25^t<<14)+(k>>>17^k>>>19^k>>>10^k<<15^k<<13)+e+m|0;D=e+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0x27b70a85|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;t=(r>>>7^r>>>18^r>>>3^r<<25^r<<14)+(A>>>17^A>>>19^A>>>10^A<<15^A<<13)+t+g|0;C=t+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0x2e1b2138|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;r=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+r+w|0;K=r+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0x4d2c6dfc|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;d=(f>>>7^f>>>18^f>>>3^f<<25^f<<14)+(t>>>17^t>>>19^t>>>10^t<<15^t<<13)+d+v|0;M=d+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0x53380d13|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;f=(l>>>7^l>>>18^l>>>3^l<<25^l<<14)+(r>>>17^r>>>19^r>>>10^r<<15^r<<13)+f+_|0;x=f+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0x650a7354|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;l=(p>>>7^p>>>18^p>>>3^p<<25^p<<14)+(d>>>17^d>>>19^d>>>10^d<<15^d<<13)+l+k|0;P=l+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0x766a0abb|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;p=(y>>>7^y>>>18^y>>>3^y<<25^y<<14)+(f>>>17^f>>>19^f>>>10^f<<15^f<<13)+p+A|0;E=p+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0x81c2c92e|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;y=(b>>>7^b>>>18^b>>>3^b<<25^b<<14)+(l>>>17^l>>>19^l>>>10^l<<15^l<<13)+y+e|0;S=y+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0x92722c85|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;b=(m>>>7^m>>>18^m>>>3^m<<25^m<<14)+(p>>>17^p>>>19^p>>>10^p<<15^p<<13)+b+t|0;D=b+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0xa2bfe8a1|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;m=(g>>>7^g>>>18^g>>>3^g<<25^g<<14)+(y>>>17^y>>>19^y>>>10^y<<15^y<<13)+m+r|0;C=m+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0xa81a664b|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;g=(w>>>7^w>>>18^w>>>3^w<<25^w<<14)+(b>>>17^b>>>19^b>>>10^b<<15^b<<13)+g+d|0;K=g+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0xc24b8b70|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;w=(v>>>7^v>>>18^v>>>3^v<<25^v<<14)+(m>>>17^m>>>19^m>>>10^m<<15^m<<13)+w+f|0;M=w+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0xc76c51a3|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;v=(_>>>7^_>>>18^_>>>3^_<<25^_<<14)+(g>>>17^g>>>19^g>>>10^g<<15^g<<13)+v+l|0;x=v+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0xd192e819|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;_=(k>>>7^k>>>18^k>>>3^k<<25^k<<14)+(w>>>17^w>>>19^w>>>10^w<<15^w<<13)+_+p|0;P=_+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0xd6990624|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;k=(A>>>7^A>>>18^A>>>3^A<<25^A<<14)+(v>>>17^v>>>19^v>>>10^v<<15^v<<13)+k+y|0;E=k+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0xf40e3585|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;A=(e>>>7^e>>>18^e>>>3^e<<25^e<<14)+(_>>>17^_>>>19^_>>>10^_<<15^_<<13)+A+b|0;S=A+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0x106aa070|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;e=(t>>>7^t>>>18^t>>>3^t<<25^t<<14)+(k>>>17^k>>>19^k>>>10^k<<15^k<<13)+e+m|0;D=e+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0x19a4c116|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;t=(r>>>7^r>>>18^r>>>3^r<<25^r<<14)+(A>>>17^A>>>19^A>>>10^A<<15^A<<13)+t+g|0;C=t+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0x1e376c08|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;r=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+r+w|0;K=r+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0x2748774c|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;d=(f>>>7^f>>>18^f>>>3^f<<25^f<<14)+(t>>>17^t>>>19^t>>>10^t<<15^t<<13)+d+v|0;M=d+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0x34b0bcb5|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;f=(l>>>7^l>>>18^l>>>3^l<<25^l<<14)+(r>>>17^r>>>19^r>>>10^r<<15^r<<13)+f+_|0;x=f+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0x391c0cb3|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;l=(p>>>7^p>>>18^p>>>3^p<<25^p<<14)+(d>>>17^d>>>19^d>>>10^d<<15^d<<13)+l+k|0;P=l+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0x4ed8aa4a|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;p=(y>>>7^y>>>18^y>>>3^y<<25^y<<14)+(f>>>17^f>>>19^f>>>10^f<<15^f<<13)+p+A|0;E=p+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0x5b9cca4f|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;y=(b>>>7^b>>>18^b>>>3^b<<25^b<<14)+(l>>>17^l>>>19^l>>>10^l<<15^l<<13)+y+e|0;S=y+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0x682e6ff3|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;b=(m>>>7^m>>>18^m>>>3^m<<25^m<<14)+(p>>>17^p>>>19^p>>>10^p<<15^p<<13)+b+t|0;D=b+D+(M>>>6^M>>>11^M>>>25^M<<26^M<<21^M<<7)+(C^M&(K^C))+0x748f82ee|0;x=x+D|0;D=D+(S&E^P&(S^E))+(S>>>2^S>>>13^S>>>22^S<<30^S<<19^S<<10)|0;m=(g>>>7^g>>>18^g>>>3^g<<25^g<<14)+(y>>>17^y>>>19^y>>>10^y<<15^y<<13)+m+r|0;C=m+C+(x>>>6^x>>>11^x>>>25^x<<26^x<<21^x<<7)+(K^x&(M^K))+0x78a5636f|0;P=P+C|0;C=C+(D&S^E&(D^S))+(D>>>2^D>>>13^D>>>22^D<<30^D<<19^D<<10)|0;g=(w>>>7^w>>>18^w>>>3^w<<25^w<<14)+(b>>>17^b>>>19^b>>>10^b<<15^b<<13)+g+d|0;K=g+K+(P>>>6^P>>>11^P>>>25^P<<26^P<<21^P<<7)+(M^P&(x^M))+0x84c87814|0;E=E+K|0;K=K+(C&D^S&(C^D))+(C>>>2^C>>>13^C>>>22^C<<30^C<<19^C<<10)|0;w=(v>>>7^v>>>18^v>>>3^v<<25^v<<14)+(m>>>17^m>>>19^m>>>10^m<<15^m<<13)+w+f|0;M=w+M+(E>>>6^E>>>11^E>>>25^E<<26^E<<21^E<<7)+(x^E&(P^x))+0x8cc70208|0;S=S+M|0;M=M+(K&C^D&(K^C))+(K>>>2^K>>>13^K>>>22^K<<30^K<<19^K<<10)|0;v=(_>>>7^_>>>18^_>>>3^_<<25^_<<14)+(g>>>17^g>>>19^g>>>10^g<<15^g<<13)+v+l|0;x=v+x+(S>>>6^S>>>11^S>>>25^S<<26^S<<21^S<<7)+(P^S&(E^P))+0x90befffa|0;D=D+x|0;x=x+(M&K^C&(M^K))+(M>>>2^M>>>13^M>>>22^M<<30^M<<19^M<<10)|0;_=(k>>>7^k>>>18^k>>>3^k<<25^k<<14)+(w>>>17^w>>>19^w>>>10^w<<15^w<<13)+_+p|0;P=_+P+(D>>>6^D>>>11^D>>>25^D<<26^D<<21^D<<7)+(E^D&(S^E))+0xa4506ceb|0;C=C+P|0;P=P+(x&M^K&(x^M))+(x>>>2^x>>>13^x>>>22^x<<30^x<<19^x<<10)|0;k=(A>>>7^A>>>18^A>>>3^A<<25^A<<14)+(v>>>17^v>>>19^v>>>10^v<<15^v<<13)+k+y|0;E=k+E+(C>>>6^C>>>11^C>>>25^C<<26^C<<21^C<<7)+(S^C&(D^S))+0xbef9a3f7|0;K=K+E|0;E=E+(P&x^M&(P^x))+(P>>>2^P>>>13^P>>>22^P<<30^P<<19^P<<10)|0;A=(e>>>7^e>>>18^e>>>3^e<<25^e<<14)+(_>>>17^_>>>19^_>>>10^_<<15^_<<13)+A+b|0;S=A+S+(K>>>6^K>>>11^K>>>25^K<<26^K<<21^K<<7)+(D^K&(C^D))+0xc67178f2|0;M=M+S|0;S=S+(E&P^x&(E^P))+(E>>>2^E>>>13^E>>>22^E<<30^E<<19^E<<10)|0;i=i+S|0;n=n+E|0;a=a+P|0;s=s+x|0;o=o+M|0;c=c+K|0;u=u+C|0;h=h+D|0;}function D(e){e=e|0;C(K[e|0]<<24|K[e|1]<<16|K[e|2]<<8|K[e|3],K[e|4]<<24|K[e|5]<<16|K[e|6]<<8|K[e|7],K[e|8]<<24|K[e|9]<<16|K[e|10]<<8|K[e|11],K[e|12]<<24|K[e|13]<<16|K[e|14]<<8|K[e|15],K[e|16]<<24|K[e|17]<<16|K[e|18]<<8|K[e|19],K[e|20]<<24|K[e|21]<<16|K[e|22]<<8|K[e|23],K[e|24]<<24|K[e|25]<<16|K[e|26]<<8|K[e|27],K[e|28]<<24|K[e|29]<<16|K[e|30]<<8|K[e|31],K[e|32]<<24|K[e|33]<<16|K[e|34]<<8|K[e|35],K[e|36]<<24|K[e|37]<<16|K[e|38]<<8|K[e|39],K[e|40]<<24|K[e|41]<<16|K[e|42]<<8|K[e|43],K[e|44]<<24|K[e|45]<<16|K[e|46]<<8|K[e|47],K[e|48]<<24|K[e|49]<<16|K[e|50]<<8|K[e|51],K[e|52]<<24|K[e|53]<<16|K[e|54]<<8|K[e|55],K[e|56]<<24|K[e|57]<<16|K[e|58]<<8|K[e|59],K[e|60]<<24|K[e|61]<<16|K[e|62]<<8|K[e|63]);}function U(e){e=e|0;K[e|0]=i>>>24;K[e|1]=i>>>16&255;K[e|2]=i>>>8&255;K[e|3]=i&255;K[e|4]=n>>>24;K[e|5]=n>>>16&255;K[e|6]=n>>>8&255;K[e|7]=n&255;K[e|8]=a>>>24;K[e|9]=a>>>16&255;K[e|10]=a>>>8&255;K[e|11]=a&255;K[e|12]=s>>>24;K[e|13]=s>>>16&255;K[e|14]=s>>>8&255;K[e|15]=s&255;K[e|16]=o>>>24;K[e|17]=o>>>16&255;K[e|18]=o>>>8&255;K[e|19]=o&255;K[e|20]=c>>>24;K[e|21]=c>>>16&255;K[e|22]=c>>>8&255;K[e|23]=c&255;K[e|24]=u>>>24;K[e|25]=u>>>16&255;K[e|26]=u>>>8&255;K[e|27]=u&255;K[e|28]=h>>>24;K[e|29]=h>>>16&255;K[e|30]=h>>>8&255;K[e|31]=h&255;}function R(){i=0x6a09e667;n=0xbb67ae85;a=0x3c6ef372;s=0xa54ff53a;o=0x510e527f;c=0x9b05688c;u=0x1f83d9ab;h=0x5be0cd19;d=f=0;}function I(e,t,r,l,p,y,b,m,g,w){e=e|0;t=t|0;r=r|0;l=l|0;p=p|0;y=y|0;b=b|0;m=m|0;g=g|0;w=w|0;i=e;n=t;a=r;s=l;o=p;c=y;u=b;h=m;d=g;f=w;}function B(e,t){e=e|0;t=t|0;var r=0;if(e&63)return -1;while((t|0)>=64){D(e);e=e+64|0;t=t-64|0;r=r+64|0;}d=d+r|0;if(d>>>0<r>>>0)f=f+1|0;return r|0}function T(e,t,r){e=e|0;t=t|0;r=r|0;var i=0,n=0;if(e&63)return -1;if(~r)if(r&31)return -1;if((t|0)>=64){i=B(e,t)|0;if((i|0)==-1)return -1;e=e+i|0;t=t-i|0;}i=i+t|0;d=d+t|0;if(d>>>0<t>>>0)f=f+1|0;K[e|t]=0x80;if((t|0)>=56){for(n=t+1|0;(n|0)<64;n=n+1|0)K[e|n]=0x00;D(e);t=0;K[e|0]=0;}for(n=t+1|0;(n|0)<59;n=n+1|0)K[e|n]=0;K[e|56]=f>>>21&255;K[e|57]=f>>>13&255;K[e|58]=f>>>5&255;K[e|59]=f<<3&255|d>>>29;K[e|60]=d>>>21&255;K[e|61]=d>>>13&255;K[e|62]=d>>>5&255;K[e|63]=d<<3&255;D(e);if(~r)U(r);return i|0}function z(){i=l;n=p;a=y;s=b;o=m;c=g;u=w;h=v;d=64;f=0;}function q(){i=_;n=k;a=A;s=S;o=E;c=P;u=x;h=M;d=64;f=0;}function F(e,t,r,K,D,U,I,B,T,z,q,F,O,L,N,j){e=e|0;t=t|0;r=r|0;K=K|0;D=D|0;U=U|0;I=I|0;B=B|0;T=T|0;z=z|0;q=q|0;F=F|0;O=O|0;L=L|0;N=N|0;j=j|0;R();C(e^0x5c5c5c5c,t^0x5c5c5c5c,r^0x5c5c5c5c,K^0x5c5c5c5c,D^0x5c5c5c5c,U^0x5c5c5c5c,I^0x5c5c5c5c,B^0x5c5c5c5c,T^0x5c5c5c5c,z^0x5c5c5c5c,q^0x5c5c5c5c,F^0x5c5c5c5c,O^0x5c5c5c5c,L^0x5c5c5c5c,N^0x5c5c5c5c,j^0x5c5c5c5c);_=i;k=n;A=a;S=s;E=o;P=c;x=u;M=h;R();C(e^0x36363636,t^0x36363636,r^0x36363636,K^0x36363636,D^0x36363636,U^0x36363636,I^0x36363636,B^0x36363636,T^0x36363636,z^0x36363636,q^0x36363636,F^0x36363636,O^0x36363636,L^0x36363636,N^0x36363636,j^0x36363636);l=i;p=n;y=a;b=s;m=o;g=c;w=u;v=h;d=64;f=0;}function O(e,t,r){e=e|0;t=t|0;r=r|0;var d=0,f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0;if(e&63)return -1;if(~r)if(r&31)return -1;w=T(e,t,-1)|0;d=i,f=n,l=a,p=s,y=o,b=c,m=u,g=h;q();C(d,f,l,p,y,b,m,g,0x80000000,0,0,0,0,0,0,768);if(~r)U(r);return w|0}function L(e,t,r,d,f){e=e|0;t=t|0;r=r|0;d=d|0;f=f|0;var l=0,p=0,y=0,b=0,m=0,g=0,w=0,v=0,_=0,k=0,A=0,S=0,E=0,P=0,x=0,M=0;if(e&63)return -1;if(~f)if(f&31)return -1;K[e+t|0]=r>>>24;K[e+t+1|0]=r>>>16&255;K[e+t+2|0]=r>>>8&255;K[e+t+3|0]=r&255;O(e,t+4|0,-1)|0;l=_=i,p=k=n,y=A=a,b=S=s,m=E=o,g=P=c,w=x=u,v=M=h;d=d-1|0;while((d|0)>0){z();C(_,k,A,S,E,P,x,M,0x80000000,0,0,0,0,0,0,768);_=i,k=n,A=a,S=s,E=o,P=c,x=u,M=h;q();C(_,k,A,S,E,P,x,M,0x80000000,0,0,0,0,0,0,768);_=i,k=n,A=a,S=s,E=o,P=c,x=u,M=h;l=l^i;p=p^n;y=y^a;b=b^s;m=m^o;g=g^c;w=w^u;v=v^h;d=d-1|0;}i=l;n=p;a=y;s=b;o=m;c=g;u=w;h=v;if(~f)U(f);return 0}return {reset:R,init:I,process:B,finish:T,hmac_reset:z,hmac_init:F,hmac_finish:O,pbkdf2_generate_block:L}}({Uint8Array},null,this.heap.buffer),this.reset()),{heap:this.heap,asm:this.asm}}release_asm(){void 0!==this.heap&&void 0!==this.asm&&(Ye.push(this.heap),Qe.push(this.asm)),this.heap=void 0,this.asm=void 0;}static bytes(e){return (new Je).process(e).finish().result}}Je.NAME="sha256";var et=tt;function tt(e,t){if(!e)throw Error(t||"Assertion failed")}tt.equal=function(e,t,r){if(e!=t)throw Error(r||"Assertion failed: "+e+" != "+t)};var rt=void 0!==e?e:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function it(e,t){return e(t={exports:{}},t.exports),t.exports}function nt(){throw Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var at=it((function(e){e.exports="function"==typeof Object.create?function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}});}:function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e;};}));var st=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return [];var r=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),i=0;i<e.length;i+=2)r.push(parseInt(e[i]+e[i+1],16));}else for(var i=0;i<e.length;i++){var n=e.charCodeAt(i),a=n>>8,s=255&n;a?r.push(a,s):r.push(s);}else for(i=0;i<e.length;i++)r[i]=0|e[i];return r};var ot=function(e){for(var t="",r=0;r<e.length;r++)t+=ht(e[r].toString(16));return t};function ct(e){return (e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}var ut=function(e,t){for(var r="",i=0;i<e.length;i++){var n=e[i];"little"===t&&(n=ct(n)),r+=dt(n.toString(16));}return r};function ht(e){return 1===e.length?"0"+e:e}function dt(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}var ft=function(e,t,r,i){var n=r-t;et(n%4==0);for(var a=Array(n/4),s=0,o=t;s<a.length;s++,o+=4){var c;c="big"===i?e[o]<<24|e[o+1]<<16|e[o+2]<<8|e[o+3]:e[o+3]<<24|e[o+2]<<16|e[o+1]<<8|e[o],a[s]=c>>>0;}return a};var lt=function(e,t){for(var r=Array(4*e.length),i=0,n=0;i<e.length;i++,n+=4){var a=e[i];"big"===t?(r[n]=a>>>24,r[n+1]=a>>>16&255,r[n+2]=a>>>8&255,r[n+3]=255&a):(r[n+3]=a>>>24,r[n+2]=a>>>16&255,r[n+1]=a>>>8&255,r[n]=255&a);}return r};var pt={inherits:at,toArray:st,toHex:ot,htonl:ct,toHex32:ut,zero2:ht,zero8:dt,join32:ft,split32:lt,rotr32:function(e,t){return e>>>t|e<<32-t},rotl32:function(e,t){return e<<t|e>>>32-t},sum32:function(e,t){return e+t>>>0},sum32_3:function(e,t,r){return e+t+r>>>0},sum32_4:function(e,t,r,i){return e+t+r+i>>>0},sum32_5:function(e,t,r,i,n){return e+t+r+i+n>>>0},sum64:function(e,t,r,i){var n=e[t],a=i+e[t+1]>>>0,s=(a<i?1:0)+r+n;e[t]=s>>>0,e[t+1]=a;},sum64_hi:function(e,t,r,i){return (t+i>>>0<t?1:0)+e+r>>>0},sum64_lo:function(e,t,r,i){return t+i>>>0},sum64_4_hi:function(e,t,r,i,n,a,s,o){var c=0,u=t;return c+=(u=u+i>>>0)<t?1:0,c+=(u=u+a>>>0)<a?1:0,e+r+n+s+(c+=(u=u+o>>>0)<o?1:0)>>>0},sum64_4_lo:function(e,t,r,i,n,a,s,o){return t+i+a+o>>>0},sum64_5_hi:function(e,t,r,i,n,a,s,o,c,u){var h=0,d=t;return h+=(d=d+i>>>0)<t?1:0,h+=(d=d+a>>>0)<a?1:0,h+=(d=d+o>>>0)<o?1:0,e+r+n+s+c+(h+=(d=d+u>>>0)<u?1:0)>>>0},sum64_5_lo:function(e,t,r,i,n,a,s,o,c,u){return t+i+a+o+u>>>0},rotr64_hi:function(e,t,r){return (t<<32-r|e>>>r)>>>0},rotr64_lo:function(e,t,r){return (e<<32-r|t>>>r)>>>0},shr64_hi:function(e,t,r){return e>>>r},shr64_lo:function(e,t,r){return (e<<32-r|t>>>r)>>>0}};function yt(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32;}var bt=yt;yt.prototype.update=function(e,t){if(e=pt.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var r=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-r,e.length),0===this.pending.length&&(this.pending=null),e=pt.join32(e,0,e.length-r,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32);}return this},yt.prototype.digest=function(e){return this.update(this._pad()),et(null===this.pending),this._digest(e)},yt.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,r=t-(e+this.padLength)%t,i=Array(r+this.padLength);i[0]=128;for(var n=1;n<r;n++)i[n]=0;if(e<<=3,"big"===this.endian){for(var a=8;a<this.padLength;a++)i[n++]=0;i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=e>>>24&255,i[n++]=e>>>16&255,i[n++]=e>>>8&255,i[n++]=255&e;}else for(i[n++]=255&e,i[n++]=e>>>8&255,i[n++]=e>>>16&255,i[n++]=e>>>24&255,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,a=8;a<this.padLength;a++)i[n++]=0;return i};var mt={BlockHash:bt},gt=pt.rotr32;var wt=function(e,t,r,i){return 0===e?vt(t,r,i):1===e||3===e?kt(t,r,i):2===e?_t(t,r,i):void 0};function vt(e,t,r){return e&t^~e&r}function _t(e,t,r){return e&t^e&r^t&r}function kt(e,t,r){return e^t^r}var At={ft_1:wt,ch32:vt,maj32:_t,p32:kt,s0_256:function(e){return gt(e,2)^gt(e,13)^gt(e,22)},s1_256:function(e){return gt(e,6)^gt(e,11)^gt(e,25)},g0_256:function(e){return gt(e,7)^gt(e,18)^e>>>3},g1_256:function(e){return gt(e,17)^gt(e,19)^e>>>10}},St=pt.sum32,Et=pt.sum32_4,Pt=pt.sum32_5,xt=At.ch32,Mt=At.maj32,Kt=At.s0_256,Ct=At.s1_256,Dt=At.g0_256,Ut=At.g1_256,Rt=mt.BlockHash,It=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function Bt(){if(!(this instanceof Bt))return new Bt;Rt.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=It,this.W=Array(64);}pt.inherits(Bt,Rt);var Tt=Bt;function zt(){if(!(this instanceof zt))return new zt;Tt.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428];}Bt.blockSize=512,Bt.outSize=256,Bt.hmacStrength=192,Bt.padLength=64,Bt.prototype._update=function(e,t){for(var r=this.W,i=0;i<16;i++)r[i]=e[t+i];for(;i<r.length;i++)r[i]=Et(Ut(r[i-2]),r[i-7],Dt(r[i-15]),r[i-16]);var n=this.h[0],a=this.h[1],s=this.h[2],o=this.h[3],c=this.h[4],u=this.h[5],h=this.h[6],d=this.h[7];for(et(this.k.length===r.length),i=0;i<r.length;i++){var f=Pt(d,Ct(c),xt(c,u,h),this.k[i],r[i]),l=St(Kt(n),Mt(n,a,s));d=h,h=u,u=c,c=St(o,f),o=s,s=a,a=n,n=St(f,l);}this.h[0]=St(this.h[0],n),this.h[1]=St(this.h[1],a),this.h[2]=St(this.h[2],s),this.h[3]=St(this.h[3],o),this.h[4]=St(this.h[4],c),this.h[5]=St(this.h[5],u),this.h[6]=St(this.h[6],h),this.h[7]=St(this.h[7],d);},Bt.prototype._digest=function(e){return "hex"===e?pt.toHex32(this.h,"big"):pt.split32(this.h,"big")},pt.inherits(zt,Tt);var qt=zt;zt.blockSize=512,zt.outSize=224,zt.hmacStrength=192,zt.padLength=64,zt.prototype._digest=function(e){return "hex"===e?pt.toHex32(this.h.slice(0,7),"big"):pt.split32(this.h.slice(0,7),"big")};var Ft=pt.rotr64_hi,Ot=pt.rotr64_lo,Lt=pt.shr64_hi,Nt=pt.shr64_lo,jt=pt.sum64,Ht=pt.sum64_hi,Wt=pt.sum64_lo,Gt=pt.sum64_4_hi,Vt=pt.sum64_4_lo,$t=pt.sum64_5_hi,Zt=pt.sum64_5_lo,Xt=mt.BlockHash,Yt=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function Qt(){if(!(this instanceof Qt))return new Qt;Xt.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=Yt,this.W=Array(160);}pt.inherits(Qt,Xt);var Jt=Qt;function er(e,t,r,i,n){var a=e&r^~e&n;return a<0&&(a+=4294967296),a}function tr(e,t,r,i,n,a){var s=t&i^~t&a;return s<0&&(s+=4294967296),s}function rr(e,t,r,i,n){var a=e&r^e&n^r&n;return a<0&&(a+=4294967296),a}function ir(e,t,r,i,n,a){var s=t&i^t&a^i&a;return s<0&&(s+=4294967296),s}function nr(e,t){var r=Ft(e,t,28)^Ft(t,e,2)^Ft(t,e,7);return r<0&&(r+=4294967296),r}function ar(e,t){var r=Ot(e,t,28)^Ot(t,e,2)^Ot(t,e,7);return r<0&&(r+=4294967296),r}function sr(e,t){var r=Ft(e,t,14)^Ft(e,t,18)^Ft(t,e,9);return r<0&&(r+=4294967296),r}function or(e,t){var r=Ot(e,t,14)^Ot(e,t,18)^Ot(t,e,9);return r<0&&(r+=4294967296),r}function cr(e,t){var r=Ft(e,t,1)^Ft(e,t,8)^Lt(e,t,7);return r<0&&(r+=4294967296),r}function ur(e,t){var r=Ot(e,t,1)^Ot(e,t,8)^Nt(e,t,7);return r<0&&(r+=4294967296),r}function hr(e,t){var r=Ft(e,t,19)^Ft(t,e,29)^Lt(e,t,6);return r<0&&(r+=4294967296),r}function dr(e,t){var r=Ot(e,t,19)^Ot(t,e,29)^Nt(e,t,6);return r<0&&(r+=4294967296),r}function fr(){if(!(this instanceof fr))return new fr;Jt.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428];}Qt.blockSize=1024,Qt.outSize=512,Qt.hmacStrength=192,Qt.padLength=128,Qt.prototype._prepareBlock=function(e,t){for(var r=this.W,i=0;i<32;i++)r[i]=e[t+i];for(;i<r.length;i+=2){var n=hr(r[i-4],r[i-3]),a=dr(r[i-4],r[i-3]),s=r[i-14],o=r[i-13],c=cr(r[i-30],r[i-29]),u=ur(r[i-30],r[i-29]),h=r[i-32],d=r[i-31];r[i]=Gt(n,a,s,o,c,u,h,d),r[i+1]=Vt(n,a,s,o,c,u,h,d);}},Qt.prototype._update=function(e,t){this._prepareBlock(e,t);var r=this.W,i=this.h[0],n=this.h[1],a=this.h[2],s=this.h[3],o=this.h[4],c=this.h[5],u=this.h[6],h=this.h[7],d=this.h[8],f=this.h[9],l=this.h[10],p=this.h[11],y=this.h[12],b=this.h[13],m=this.h[14],g=this.h[15];et(this.k.length===r.length);for(var w=0;w<r.length;w+=2){var v=m,_=g,k=sr(d,f),A=or(d,f),S=er(d,f,l,p,y),E=tr(d,f,l,p,y,b),P=this.k[w],x=this.k[w+1],M=r[w],K=r[w+1],C=$t(v,_,k,A,S,E,P,x,M,K),D=Zt(v,_,k,A,S,E,P,x,M,K);v=nr(i,n),_=ar(i,n),k=rr(i,n,a,s,o),A=ir(i,n,a,s,o,c);var U=Ht(v,_,k,A),R=Wt(v,_,k,A);m=y,g=b,y=l,b=p,l=d,p=f,d=Ht(u,h,C,D),f=Wt(h,h,C,D),u=o,h=c,o=a,c=s,a=i,s=n,i=Ht(C,D,U,R),n=Wt(C,D,U,R);}jt(this.h,0,i,n),jt(this.h,2,a,s),jt(this.h,4,o,c),jt(this.h,6,u,h),jt(this.h,8,d,f),jt(this.h,10,l,p),jt(this.h,12,y,b),jt(this.h,14,m,g);},Qt.prototype._digest=function(e){return "hex"===e?pt.toHex32(this.h,"big"):pt.split32(this.h,"big")},pt.inherits(fr,Jt);var lr=fr;fr.blockSize=1024,fr.outSize=384,fr.hmacStrength=192,fr.padLength=128,fr.prototype._digest=function(e){return "hex"===e?pt.toHex32(this.h.slice(0,12),"big"):pt.split32(this.h.slice(0,12),"big")};var pr=pt.rotl32,yr=pt.sum32,br=pt.sum32_3,mr=pt.sum32_4,gr=mt.BlockHash;function wr(){if(!(this instanceof wr))return new wr;gr.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little";}pt.inherits(wr,gr);var vr=wr;function _r(e,t,r,i){return e<=15?t^r^i:e<=31?t&r|~t&i:e<=47?(t|~r)^i:e<=63?t&i|r&~i:t^(r|~i)}function kr(e){return e<=15?0:e<=31?1518500249:e<=47?1859775393:e<=63?2400959708:2840853838}function Ar(e){return e<=15?1352829926:e<=31?1548603684:e<=47?1836072691:e<=63?2053994217:0}wr.blockSize=512,wr.outSize=160,wr.hmacStrength=192,wr.padLength=64,wr.prototype._update=function(e,t){for(var r=this.h[0],i=this.h[1],n=this.h[2],a=this.h[3],s=this.h[4],o=r,c=i,u=n,h=a,d=s,f=0;f<80;f++){var l=yr(pr(mr(r,_r(f,i,n,a),e[Sr[f]+t],kr(f)),Pr[f]),s);r=s,s=a,a=pr(n,10),n=i,i=l,l=yr(pr(mr(o,_r(79-f,c,u,h),e[Er[f]+t],Ar(f)),xr[f]),d),o=d,d=h,h=pr(u,10),u=c,c=l;}l=br(this.h[1],n,h),this.h[1]=br(this.h[2],a,d),this.h[2]=br(this.h[3],s,o),this.h[3]=br(this.h[4],r,c),this.h[4]=br(this.h[0],i,u),this.h[0]=l;},wr.prototype._digest=function(e){return "hex"===e?pt.toHex32(this.h,"little"):pt.split32(this.h,"little")};var Sr=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],Er=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],Pr=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],xr=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11],Mr={ripemd160:vr};function Kr(e,t){let r=e[0],i=e[1],n=e[2],a=e[3];r=Dr(r,i,n,a,t[0],7,-680876936),a=Dr(a,r,i,n,t[1],12,-389564586),n=Dr(n,a,r,i,t[2],17,606105819),i=Dr(i,n,a,r,t[3],22,-1044525330),r=Dr(r,i,n,a,t[4],7,-176418897),a=Dr(a,r,i,n,t[5],12,1200080426),n=Dr(n,a,r,i,t[6],17,-1473231341),i=Dr(i,n,a,r,t[7],22,-45705983),r=Dr(r,i,n,a,t[8],7,1770035416),a=Dr(a,r,i,n,t[9],12,-1958414417),n=Dr(n,a,r,i,t[10],17,-42063),i=Dr(i,n,a,r,t[11],22,-1990404162),r=Dr(r,i,n,a,t[12],7,1804603682),a=Dr(a,r,i,n,t[13],12,-40341101),n=Dr(n,a,r,i,t[14],17,-1502002290),i=Dr(i,n,a,r,t[15],22,1236535329),r=Ur(r,i,n,a,t[1],5,-165796510),a=Ur(a,r,i,n,t[6],9,-1069501632),n=Ur(n,a,r,i,t[11],14,643717713),i=Ur(i,n,a,r,t[0],20,-373897302),r=Ur(r,i,n,a,t[5],5,-701558691),a=Ur(a,r,i,n,t[10],9,38016083),n=Ur(n,a,r,i,t[15],14,-660478335),i=Ur(i,n,a,r,t[4],20,-405537848),r=Ur(r,i,n,a,t[9],5,568446438),a=Ur(a,r,i,n,t[14],9,-1019803690),n=Ur(n,a,r,i,t[3],14,-187363961),i=Ur(i,n,a,r,t[8],20,1163531501),r=Ur(r,i,n,a,t[13],5,-1444681467),a=Ur(a,r,i,n,t[2],9,-51403784),n=Ur(n,a,r,i,t[7],14,1735328473),i=Ur(i,n,a,r,t[12],20,-1926607734),r=Rr(r,i,n,a,t[5],4,-378558),a=Rr(a,r,i,n,t[8],11,-2022574463),n=Rr(n,a,r,i,t[11],16,1839030562),i=Rr(i,n,a,r,t[14],23,-35309556),r=Rr(r,i,n,a,t[1],4,-1530992060),a=Rr(a,r,i,n,t[4],11,1272893353),n=Rr(n,a,r,i,t[7],16,-155497632),i=Rr(i,n,a,r,t[10],23,-1094730640),r=Rr(r,i,n,a,t[13],4,681279174),a=Rr(a,r,i,n,t[0],11,-358537222),n=Rr(n,a,r,i,t[3],16,-722521979),i=Rr(i,n,a,r,t[6],23,76029189),r=Rr(r,i,n,a,t[9],4,-640364487),a=Rr(a,r,i,n,t[12],11,-421815835),n=Rr(n,a,r,i,t[15],16,530742520),i=Rr(i,n,a,r,t[2],23,-995338651),r=Ir(r,i,n,a,t[0],6,-198630844),a=Ir(a,r,i,n,t[7],10,1126891415),n=Ir(n,a,r,i,t[14],15,-1416354905),i=Ir(i,n,a,r,t[5],21,-57434055),r=Ir(r,i,n,a,t[12],6,1700485571),a=Ir(a,r,i,n,t[3],10,-1894986606),n=Ir(n,a,r,i,t[10],15,-1051523),i=Ir(i,n,a,r,t[1],21,-2054922799),r=Ir(r,i,n,a,t[8],6,1873313359),a=Ir(a,r,i,n,t[15],10,-30611744),n=Ir(n,a,r,i,t[6],15,-1560198380),i=Ir(i,n,a,r,t[13],21,1309151649),r=Ir(r,i,n,a,t[4],6,-145523070),a=Ir(a,r,i,n,t[11],10,-1120210379),n=Ir(n,a,r,i,t[2],15,718787259),i=Ir(i,n,a,r,t[9],21,-343485551),e[0]=qr(r,e[0]),e[1]=qr(i,e[1]),e[2]=qr(n,e[2]),e[3]=qr(a,e[3]);}function Cr(e,t,r,i,n,a){return t=qr(qr(t,e),qr(i,a)),qr(t<<n|t>>>32-n,r)}function Dr(e,t,r,i,n,a,s){return Cr(t&r|~t&i,e,t,n,a,s)}function Ur(e,t,r,i,n,a,s){return Cr(t&i|r&~i,e,t,n,a,s)}function Rr(e,t,r,i,n,a,s){return Cr(t^r^i,e,t,n,a,s)}function Ir(e,t,r,i,n,a,s){return Cr(r^(t|~i),e,t,n,a,s)}function Br(e){const t=[];let r;for(r=0;r<64;r+=4)t[r>>2]=e.charCodeAt(r)+(e.charCodeAt(r+1)<<8)+(e.charCodeAt(r+2)<<16)+(e.charCodeAt(r+3)<<24);return t}const Tr="0123456789abcdef".split("");function zr(e){let t="",r=0;for(;r<4;r++)t+=Tr[e>>8*r+4&15]+Tr[e>>8*r&15];return t}function qr(e,t){return e+t&4294967295}const Fr=X.getWebCrypto(),Or=X.getNodeCrypto(),Lr=Or&&Or.getHashes();function Nr(e){if(Or&&Lr.includes(e))return async function(t){const r=Or.createHash(e);return B(t,(e=>{r.update(e);}),(()=>new Uint8Array(r.digest())))}}function jr(e,t){return async function(r,i=ne){if(s(r)&&(r=await N(r)),!X.isStream(r)&&Fr&&t&&r.length>=i.minBytesForWebCrypto)return new Uint8Array(await Fr.digest(t,r));const n=e();return B(r,(e=>{n.update(e);}),(()=>new Uint8Array(n.digest())))}}function Hr(e,t){return async function(r,i=ne){if(s(r)&&(r=await N(r)),X.isStream(r)){const t=new e;return B(r,(e=>{t.process(e);}),(()=>t.finish().result))}return Fr&&t&&r.length>=i.minBytesForWebCrypto?new Uint8Array(await Fr.digest(t,r)):e.bytes(r)}}const Wr={md5:Nr("md5")||async function(e){const t=function(e){const t=e.length,r=[1732584193,-271733879,-1732584194,271733878];let i;for(i=64;i<=e.length;i+=64)Kr(r,Br(e.substring(i-64,i)));e=e.substring(i-64);const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(i=0;i<e.length;i++)n[i>>2]|=e.charCodeAt(i)<<(i%4<<3);if(n[i>>2]|=128<<(i%4<<3),i>55)for(Kr(r,n),i=0;i<16;i++)n[i]=0;return n[14]=8*t,Kr(r,n),r}(X.uint8ArrayToString(e));return X.hexToUint8Array(function(e){for(let t=0;t<e.length;t++)e[t]=zr(e[t]);return e.join("")}(t))},sha1:Nr("sha1")||Hr(Xe,"SHA-1"),sha224:Nr("sha224")||jr(qt),sha256:Nr("sha256")||Hr(Je,"SHA-256"),sha384:Nr("sha384")||jr(lr,"SHA-384"),sha512:Nr("sha512")||jr(Jt,"SHA-512"),ripemd:Nr("ripemd160")||jr(vr)};var Gr={md5:Wr.md5,sha1:Wr.sha1,sha224:Wr.sha224,sha256:Wr.sha256,sha384:Wr.sha384,sha512:Wr.sha512,ripemd:Wr.ripemd,digest:function(e,t){switch(e){case $.hash.md5:return this.md5(t);case $.hash.sha1:return this.sha1(t);case $.hash.ripemd:return this.ripemd(t);case $.hash.sha256:return this.sha256(t);case $.hash.sha384:return this.sha384(t);case $.hash.sha512:return this.sha512(t);case $.hash.sha224:return this.sha224(t);default:throw Error("Invalid hash function.")}},getHashByteLength:function(e){switch(e){case $.hash.md5:return 16;case $.hash.sha1:case $.hash.ripemd:return 20;case $.hash.sha256:return 32;case $.hash.sha384:return 48;case $.hash.sha512:return 64;case $.hash.sha224:return 28;default:throw Error("Invalid hash algorithm.")}}};class Vr{static encrypt(e,t,r){return new Vr(t,r).encrypt(e)}static decrypt(e,t,r){return new Vr(t,r).decrypt(e)}constructor(e,t,r){this.aes=r||new Ee(e,t,!0,"CFB"),delete this.aes.padding;}encrypt(e){return we(this.aes.AES_Encrypt_process(e),this.aes.AES_Encrypt_finish())}decrypt(e){return we(this.aes.AES_Decrypt_process(e),this.aes.AES_Decrypt_finish())}}function $r(e){const t=$.read($.symmetric,e);return We[t]}const Zr=X.getWebCrypto(),Xr=X.getNodeCrypto(),Yr=Xr?Xr.getCiphers():[],Qr={idea:Yr.includes("idea-cfb")?"idea-cfb":void 0,tripledes:Yr.includes("des-ede3-cfb")?"des-ede3-cfb":void 0,cast5:Yr.includes("cast5-cfb")?"cast5-cfb":void 0,blowfish:Yr.includes("bf-cfb")?"bf-cfb":void 0,aes128:Yr.includes("aes-128-cfb")?"aes-128-cfb":void 0,aes192:Yr.includes("aes-192-cfb")?"aes-192-cfb":void 0,aes256:Yr.includes("aes-256-cfb")?"aes-256-cfb":void 0};var Jr=/*#__PURE__*/Object.freeze({__proto__:null,encrypt:async function(e,t,r,i,n){const a=$.read($.symmetric,e);if(X.getNodeCrypto()&&Qr[a])return function(e,t,r,i){const n=$.read($.symmetric,e),a=new Xr.createCipheriv(Qr[n],t,i);return B(r,(e=>new Uint8Array(a.update(e))))}(e,t,r,i);if(X.isAES(e))return function(e,t,r,i,n){if(X.getWebCrypto()&&24!==t.length&&!X.isStream(r)&&r.length>=3e3*n.minBytesForWebCrypto)return async function(e,t,r,i){const n="AES-CBC",a=await Zr.importKey("raw",t,{name:n},!1,["encrypt"]),{blockSize:s}=$r(e),o=X.concatUint8Array([new Uint8Array(s),r]),c=new Uint8Array(await Zr.encrypt({name:n,iv:i},a,o)).subarray(0,r.length);return function(e,t){for(let r=0;r<e.length;r++)e[r]=e[r]^t[r];}(c,r),c}(e,t,r,i);const a=new Vr(t,i);return B(r,(e=>a.aes.AES_Encrypt_process(e)),(()=>a.aes.AES_Encrypt_finish()))}(e,t,r,i,n);const s=new($r(e))(t),o=s.blockSize,c=i.slice();let u=new Uint8Array;const h=e=>{e&&(u=X.concatUint8Array([u,e]));const t=new Uint8Array(u.length);let r,i=0;for(;e?u.length>=o:u.length;){const e=s.encrypt(c);for(r=0;r<o;r++)c[r]=u[r]^e[r],t[i++]=c[r];u=u.subarray(o);}return t.subarray(0,i)};return B(r,h,h)},decrypt:async function(e,t,r,i){const n=$.read($.symmetric,e);if(X.getNodeCrypto()&&Qr[n])return function(e,t,r,i){const n=$.read($.symmetric,e),a=new Xr.createDecipheriv(Qr[n],t,i);return B(r,(e=>new Uint8Array(a.update(e))))}(e,t,r,i);if(X.isAES(e))return function(e,t,r,i){if(X.isStream(r)){const e=new Vr(t,i);return B(r,(t=>e.aes.AES_Decrypt_process(t)),(()=>e.aes.AES_Decrypt_finish()))}return Vr.decrypt(r,t,i)}(0,t,r,i);const a=new($r(e))(t),s=a.blockSize;let o=i,c=new Uint8Array;const u=e=>{e&&(c=X.concatUint8Array([c,e]));const t=new Uint8Array(c.length);let r,i=0;for(;e?c.length>=s:c.length;){const e=a.encrypt(o);for(o=c.subarray(0,s),r=0;r<s;r++)t[i++]=o[r]^e[r];c=c.subarray(s);}return t.subarray(0,i)};return B(r,u,u)}});class ei{static encrypt(e,t,r){return new ei(t,r).encrypt(e)}static decrypt(e,t,r){return new ei(t,r).encrypt(e)}constructor(e,t,r){this.aes=r||new Ee(e,void 0,!1,"CTR"),delete this.aes.padding,this.AES_CTR_set_options(t);}encrypt(e){return we(this.aes.AES_Encrypt_process(e),this.aes.AES_Encrypt_finish())}decrypt(e){return we(this.aes.AES_Encrypt_process(e),this.aes.AES_Encrypt_finish())}AES_CTR_set_options(e,t,r){let{asm:i}=this.aes.acquire_asm();if(void 0!==r){if(r<8||r>48)throw new _e("illegal counter size");let e=Math.pow(2,r)-1;i.set_mask(0,0,e/4294967296|0,0|e);}else r=48,i.set_mask(0,0,65535,4294967295);if(void 0===e)throw Error("nonce is required");{let t=e.length;if(!t||t>16)throw new _e("illegal nonce size");let r=new DataView(new ArrayBuffer(16));new Uint8Array(r.buffer).set(e),i.set_nonce(r.getUint32(0),r.getUint32(4),r.getUint32(8),r.getUint32(12));}if(void 0!==t){if(t<0||t>=Math.pow(2,r))throw new _e("illegal counter value");i.set_counter(0,0,t/4294967296|0,0|t);}}}class ti{static encrypt(e,t,r=!0,i){return new ti(t,i,r).encrypt(e)}static decrypt(e,t,r=!0,i){return new ti(t,i,r).decrypt(e)}constructor(e,t,r=!0,i){this.aes=i||new Ee(e,t,r,"CBC");}encrypt(e){return we(this.aes.AES_Encrypt_process(e),this.aes.AES_Encrypt_finish())}decrypt(e){return we(this.aes.AES_Decrypt_process(e),this.aes.AES_Decrypt_finish())}}const ri=X.getWebCrypto(),ii=X.getNodeCrypto(),ni=16;function ai(e,t){const r=e.length-ni;for(let i=0;i<ni;i++)e[i+r]^=t[i];return e}const si=new Uint8Array(ni);async function oi(e){const t=await async function(e){if(X.getWebCrypto()&&24!==e.length)return e=await ri.importKey("raw",e,{name:"AES-CBC",length:8*e.length},!1,["encrypt"]),async function(t){const r=await ri.encrypt({name:"AES-CBC",iv:si,length:8*ni},e,t);return new Uint8Array(r).subarray(0,r.byteLength-ni)};if(X.getNodeCrypto())return async function(t){const r=new ii.createCipheriv("aes-"+8*e.length+"-cbc",e,si).update(t);return new Uint8Array(r)};return async function(t){return ti.encrypt(t,e,!1,si)}}(e),r=X.double(await t(si)),i=X.double(r);return async function(e){return (await t(function(e,t,r){if(e.length&&e.length%ni==0)return ai(e,t);const i=new Uint8Array(e.length+(ni-e.length%ni));return i.set(e),i[e.length]=128,ai(i,r)}(e,r,i))).subarray(-ni)}}const ci=X.getWebCrypto(),ui=X.getNodeCrypto(),hi=X.getNodeBuffer(),di=16,fi=di,li=di,pi=new Uint8Array(di),yi=new Uint8Array(di);yi[di-1]=1;const bi=new Uint8Array(di);async function mi(e){const t=await oi(e);return function(e,r){return t(X.concatUint8Array([e,r]))}}async function gi(e){return X.getWebCrypto()&&24!==e.length?(e=await ci.importKey("raw",e,{name:"AES-CTR",length:8*e.length},!1,["encrypt"]),async function(t,r){const i=await ci.encrypt({name:"AES-CTR",counter:r,length:8*di},e,t);return new Uint8Array(i)}):X.getNodeCrypto()?async function(t,r){const i=new ui.createCipheriv("aes-"+8*e.length+"-ctr",e,r),n=hi.concat([i.update(t),i.final()]);return new Uint8Array(n)}:async function(t,r){return ei.encrypt(t,e,r)}}async function wi(e,t){if(e!==$.symmetric.aes128&&e!==$.symmetric.aes192&&e!==$.symmetric.aes256)throw Error("EAX mode supports only AES cipher");const[r,i]=await Promise.all([mi(t),gi(t)]);return {encrypt:async function(e,t,n){const[a,s]=await Promise.all([r(pi,t),r(yi,n)]),o=await i(e,a),c=await r(bi,o);for(let e=0;e<li;e++)c[e]^=s[e]^a[e];return X.concatUint8Array([o,c])},decrypt:async function(e,t,n){if(e.length<li)throw Error("Invalid EAX ciphertext");const a=e.subarray(0,-li),s=e.subarray(-li),[o,c,u]=await Promise.all([r(pi,t),r(yi,n),r(bi,a)]),h=u;for(let e=0;e<li;e++)h[e]^=c[e]^o[e];if(!X.equalsUint8Array(s,h))throw Error("Authentication tag mismatch");return await i(a,o)}}}bi[di-1]=2,wi.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[8+e]^=t[e];return r},wi.blockLength=di,wi.ivLength=fi,wi.tagLength=li;const vi=16,_i=15,ki=16;function Ai(e){let t=0;for(let r=1;0==(e&r);r<<=1)t++;return t}function Si(e,t){for(let r=0;r<e.length;r++)e[r]^=t[r];return e}function Ei(e,t){return Si(e.slice(),t)}const Pi=new Uint8Array(vi),xi=new Uint8Array([1]);async function Mi(e,t){let r,i,n,a=0;function s(e,t,i,s){const o=t.length/vi|0;!function(e,t){const r=X.nbits(Math.max(e.length,t.length)/vi|0)-1;for(let e=a+1;e<=r;e++)n[e]=X.double(n[e-1]);a=r;}(t,s);const c=X.concatUint8Array([Pi.subarray(0,_i-i.length),xi,i]),u=63&c[vi-1];c[vi-1]&=192;const h=r(c),d=X.concatUint8Array([h,Ei(h.subarray(0,8),h.subarray(1,9))]),f=X.shiftRight(d.subarray(0+(u>>3),17+(u>>3)),8-(7&u)).subarray(1),l=new Uint8Array(vi),p=new Uint8Array(t.length+ki);let y,b=0;for(y=0;y<o;y++)Si(f,n[Ai(y+1)]),p.set(Si(e(Ei(f,t)),f),b),Si(l,e===r?t:p.subarray(b)),t=t.subarray(vi),b+=vi;if(t.length){Si(f,n.x);const i=r(f);p.set(Ei(t,i),b);const a=new Uint8Array(vi);a.set(e===r?t:p.subarray(b,-ki),0),a[t.length]=128,Si(l,a),b+=t.length;}const m=Si(r(Si(Si(l,f),n.$)),function(e){if(!e.length)return Pi;const t=e.length/vi|0,i=new Uint8Array(vi),a=new Uint8Array(vi);for(let s=0;s<t;s++)Si(i,n[Ai(s+1)]),Si(a,r(Ei(i,e))),e=e.subarray(vi);if(e.length){Si(i,n.x);const t=new Uint8Array(vi);t.set(e,0),t[e.length]=128,Si(t,i),Si(a,r(t));}return a}(s));return p.set(m,b),p}return function(e,t){const a=$.read($.symmetric,e),s=new We[a](t);r=s.encrypt.bind(s),i=s.decrypt.bind(s);const o=r(Pi),c=X.double(o);n=[],n[0]=X.double(c),n.x=o,n.$=c;}(e,t),{encrypt:async function(e,t,i){return s(r,e,t,i)},decrypt:async function(e,t,r){if(e.length<ki)throw Error("Invalid OCB ciphertext");const n=e.subarray(-ki);e=e.subarray(0,-ki);const a=s(i,e,t,r);if(X.equalsUint8Array(n,a.subarray(-ki)))return a.subarray(0,-ki);throw Error("Authentication tag mismatch")}}}Mi.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[7+e]^=t[e];return r},Mi.blockLength=vi,Mi.ivLength=_i,Mi.tagLength=ki;const Ki=68719476704;class Ci{constructor(e,t,r,i=16,n){this.tagSize=i,this.gamma0=0,this.counter=1,this.aes=n||new Ee(e,void 0,!1,"CTR");let{asm:a,heap:s}=this.aes.acquire_asm();if(a.gcm_init(),this.tagSize<4||this.tagSize>16)throw new _e("illegal tagSize value");const o=t.length||0,c=new Uint8Array(16);12!==o?(this._gcm_mac_process(t),s[0]=0,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=0,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=0,s[11]=o>>>29,s[12]=o>>>21&255,s[13]=o>>>13&255,s[14]=o>>>5&255,s[15]=o<<3&255,a.mac(ye.MAC.GCM,ye.HEAP_DATA,16),a.get_iv(ye.HEAP_DATA),a.set_iv(0,0,0,0),c.set(s.subarray(0,16))):(c.set(t),c[15]=1);const u=new DataView(c.buffer);if(this.gamma0=u.getUint32(12),a.set_nonce(u.getUint32(0),u.getUint32(4),u.getUint32(8),0),a.set_mask(0,0,0,4294967295),void 0!==r){if(r.length>Ki)throw new _e("illegal adata length");r.length?(this.adata=r,this._gcm_mac_process(r)):this.adata=void 0;}else this.adata=void 0;if(this.counter<1||this.counter>4294967295)throw new RangeError("counter must be a positive 32-bit integer");a.set_counter(0,0,0,this.gamma0+this.counter|0);}static encrypt(e,t,r,i,n){return new Ci(t,r,i,n).encrypt(e)}static decrypt(e,t,r,i,n){return new Ci(t,r,i,n).decrypt(e)}encrypt(e){return this.AES_GCM_encrypt(e)}decrypt(e){return this.AES_GCM_decrypt(e)}AES_GCM_Encrypt_process(e){let t=0,r=e.length||0,{asm:i,heap:n}=this.aes.acquire_asm(),a=this.counter,s=this.aes.pos,o=this.aes.len,c=0,u=o+r&-16,h=0;if((a-1<<4)+o+r>Ki)throw new RangeError("counter overflow");const d=new Uint8Array(u);for(;r>0;)h=ge(n,s+o,e,t,r),o+=h,t+=h,r-=h,h=i.cipher(ye.ENC.CTR,ye.HEAP_DATA+s,o),h=i.mac(ye.MAC.GCM,ye.HEAP_DATA+s,h),h&&d.set(n.subarray(s,s+h),c),a+=h>>>4,c+=h,h<o?(s+=h,o-=h):(s=0,o=0);return this.counter=a,this.aes.pos=s,this.aes.len=o,d}AES_GCM_Encrypt_finish(){let{asm:e,heap:t}=this.aes.acquire_asm(),r=this.counter,i=this.tagSize,n=this.adata,a=this.aes.pos,s=this.aes.len;const o=new Uint8Array(s+i);e.cipher(ye.ENC.CTR,ye.HEAP_DATA+a,s+15&-16),s&&o.set(t.subarray(a,a+s));let c=s;for(;15&c;c++)t[a+c]=0;e.mac(ye.MAC.GCM,ye.HEAP_DATA+a,c);const u=void 0!==n?n.length:0,h=(r-1<<4)+s;return t[0]=0,t[1]=0,t[2]=0,t[3]=u>>>29,t[4]=u>>>21,t[5]=u>>>13&255,t[6]=u>>>5&255,t[7]=u<<3&255,t[8]=t[9]=t[10]=0,t[11]=h>>>29,t[12]=h>>>21&255,t[13]=h>>>13&255,t[14]=h>>>5&255,t[15]=h<<3&255,e.mac(ye.MAC.GCM,ye.HEAP_DATA,16),e.get_iv(ye.HEAP_DATA),e.set_counter(0,0,0,this.gamma0),e.cipher(ye.ENC.CTR,ye.HEAP_DATA,16),o.set(t.subarray(0,i),s),this.counter=1,this.aes.pos=0,this.aes.len=0,o}AES_GCM_Decrypt_process(e){let t=0,r=e.length||0,{asm:i,heap:n}=this.aes.acquire_asm(),a=this.counter,s=this.tagSize,o=this.aes.pos,c=this.aes.len,u=0,h=c+r>s?c+r-s&-16:0,d=c+r-h,f=0;if((a-1<<4)+c+r>Ki)throw new RangeError("counter overflow");const l=new Uint8Array(h);for(;r>d;)f=ge(n,o+c,e,t,r-d),c+=f,t+=f,r-=f,f=i.mac(ye.MAC.GCM,ye.HEAP_DATA+o,f),f=i.cipher(ye.DEC.CTR,ye.HEAP_DATA+o,f),f&&l.set(n.subarray(o,o+f),u),a+=f>>>4,u+=f,o=0,c=0;return r>0&&(c+=ge(n,0,e,t,r)),this.counter=a,this.aes.pos=o,this.aes.len=c,l}AES_GCM_Decrypt_finish(){let{asm:e,heap:t}=this.aes.acquire_asm(),r=this.tagSize,i=this.adata,n=this.counter,a=this.aes.pos,s=this.aes.len,o=s-r;if(s<r)throw new ve("authentication tag not found");const c=new Uint8Array(o),u=new Uint8Array(t.subarray(a+o,a+s));let h=o;for(;15&h;h++)t[a+h]=0;e.mac(ye.MAC.GCM,ye.HEAP_DATA+a,h),e.cipher(ye.DEC.CTR,ye.HEAP_DATA+a,h),o&&c.set(t.subarray(a,a+o));const d=void 0!==i?i.length:0,f=(n-1<<4)+s-r;t[0]=0,t[1]=0,t[2]=0,t[3]=d>>>29,t[4]=d>>>21,t[5]=d>>>13&255,t[6]=d>>>5&255,t[7]=d<<3&255,t[8]=t[9]=t[10]=0,t[11]=f>>>29,t[12]=f>>>21&255,t[13]=f>>>13&255,t[14]=f>>>5&255,t[15]=f<<3&255,e.mac(ye.MAC.GCM,ye.HEAP_DATA,16),e.get_iv(ye.HEAP_DATA),e.set_counter(0,0,0,this.gamma0),e.cipher(ye.ENC.CTR,ye.HEAP_DATA,16);let l=0;for(let e=0;e<r;++e)l|=u[e]^t[e];if(l)throw new ke("data integrity check failed");return this.counter=1,this.aes.pos=0,this.aes.len=0,c}AES_GCM_decrypt(e){const t=this.AES_GCM_Decrypt_process(e),r=this.AES_GCM_Decrypt_finish(),i=new Uint8Array(t.length+r.length);return t.length&&i.set(t),r.length&&i.set(r,t.length),i}AES_GCM_encrypt(e){const t=this.AES_GCM_Encrypt_process(e),r=this.AES_GCM_Encrypt_finish(),i=new Uint8Array(t.length+r.length);return t.length&&i.set(t),r.length&&i.set(r,t.length),i}_gcm_mac_process(e){let{asm:t,heap:r}=this.aes.acquire_asm(),i=0,n=e.length||0,a=0;for(;n>0;){for(a=ge(r,0,e,i,n),i+=a,n-=a;15&a;)r[a++]=0;t.mac(ye.MAC.GCM,ye.HEAP_DATA,a);}}}const Di=X.getWebCrypto(),Ui=X.getNodeCrypto(),Ri=X.getNodeBuffer(),Ii=16,Bi="AES-GCM";async function Ti(e,t){if(e!==$.symmetric.aes128&&e!==$.symmetric.aes192&&e!==$.symmetric.aes256)throw Error("GCM mode supports only AES cipher");if(X.getNodeCrypto())return {encrypt:async function(e,r,i=new Uint8Array){const n=new Ui.createCipheriv("aes-"+8*t.length+"-gcm",t,r);n.setAAD(i);const a=Ri.concat([n.update(e),n.final(),n.getAuthTag()]);return new Uint8Array(a)},decrypt:async function(e,r,i=new Uint8Array){const n=new Ui.createDecipheriv("aes-"+8*t.length+"-gcm",t,r);n.setAAD(i),n.setAuthTag(e.slice(e.length-Ii,e.length));const a=Ri.concat([n.update(e.slice(0,e.length-Ii)),n.final()]);return new Uint8Array(a)}};if(X.getWebCrypto()&&24!==t.length){const e=await Di.importKey("raw",t,{name:Bi},!1,["encrypt","decrypt"]);return {encrypt:async function(r,i,n=new Uint8Array){if(!r.length)return Ci.encrypt(r,t,i,n);const a=await Di.encrypt({name:Bi,iv:i,additionalData:n,tagLength:8*Ii},e,r);return new Uint8Array(a)},decrypt:async function(r,i,n=new Uint8Array){if(r.length===Ii)return Ci.decrypt(r,t,i,n);const a=await Di.decrypt({name:Bi,iv:i,additionalData:n,tagLength:8*Ii},e,r);return new Uint8Array(a)}}}return {encrypt:async function(e,r,i){return Ci.encrypt(e,t,r,i)},decrypt:async function(e,r,i){return Ci.decrypt(e,t,r,i)}}}Ti.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[4+e]^=t[e];return r},Ti.blockLength=16,Ti.ivLength=12,Ti.tagLength=Ii;var zi={cfb:Jr,gcm:Ti,experimentalGCM:Ti,eax:wi,ocb:Mi},qi=it((function(e){!function(e){var t=function(e){var t,r=new Float64Array(16);if(e)for(t=0;t<e.length;t++)r[t]=e[t];return r},r=function(){throw Error("no PRNG")},i=new Uint8Array(32);i[0]=9;var n=t(),a=t([1]),s=t([56129,1]),o=t([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),c=t([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),u=t([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),h=t([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),d=t([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function f(e,t,r,i){return function(e,t,r,i,n){var a,s=0;for(a=0;a<n;a++)s|=e[t+a]^r[i+a];return (1&s-1>>>8)-1}(e,t,r,i,32)}function l(e,t){var r;for(r=0;r<16;r++)e[r]=0|t[r];}function p(e){var t,r,i=1;for(t=0;t<16;t++)r=e[t]+i+65535,i=Math.floor(r/65536),e[t]=r-65536*i;e[0]+=i-1+37*(i-1);}function y(e,t,r){for(var i,n=~(r-1),a=0;a<16;a++)i=n&(e[a]^t[a]),e[a]^=i,t[a]^=i;}function b(e,r){var i,n,a,s=t(),o=t();for(i=0;i<16;i++)o[i]=r[i];for(p(o),p(o),p(o),n=0;n<2;n++){for(s[0]=o[0]-65517,i=1;i<15;i++)s[i]=o[i]-65535-(s[i-1]>>16&1),s[i-1]&=65535;s[15]=o[15]-32767-(s[14]>>16&1),a=s[15]>>16&1,s[14]&=65535,y(o,s,1-a);}for(i=0;i<16;i++)e[2*i]=255&o[i],e[2*i+1]=o[i]>>8;}function m(e,t){var r=new Uint8Array(32),i=new Uint8Array(32);return b(r,e),b(i,t),f(r,0,i,0)}function g(e){var t=new Uint8Array(32);return b(t,e),1&t[0]}function w(e,t){var r;for(r=0;r<16;r++)e[r]=t[2*r]+(t[2*r+1]<<8);e[15]&=32767;}function v(e,t,r){for(var i=0;i<16;i++)e[i]=t[i]+r[i];}function _(e,t,r){for(var i=0;i<16;i++)e[i]=t[i]-r[i];}function k(e,t,r){var i,n,a=0,s=0,o=0,c=0,u=0,h=0,d=0,f=0,l=0,p=0,y=0,b=0,m=0,g=0,w=0,v=0,_=0,k=0,A=0,S=0,E=0,P=0,x=0,M=0,K=0,C=0,D=0,U=0,R=0,I=0,B=0,T=r[0],z=r[1],q=r[2],F=r[3],O=r[4],L=r[5],N=r[6],j=r[7],H=r[8],W=r[9],G=r[10],V=r[11],$=r[12],Z=r[13],X=r[14],Y=r[15];a+=(i=t[0])*T,s+=i*z,o+=i*q,c+=i*F,u+=i*O,h+=i*L,d+=i*N,f+=i*j,l+=i*H,p+=i*W,y+=i*G,b+=i*V,m+=i*$,g+=i*Z,w+=i*X,v+=i*Y,s+=(i=t[1])*T,o+=i*z,c+=i*q,u+=i*F,h+=i*O,d+=i*L,f+=i*N,l+=i*j,p+=i*H,y+=i*W,b+=i*G,m+=i*V,g+=i*$,w+=i*Z,v+=i*X,_+=i*Y,o+=(i=t[2])*T,c+=i*z,u+=i*q,h+=i*F,d+=i*O,f+=i*L,l+=i*N,p+=i*j,y+=i*H,b+=i*W,m+=i*G,g+=i*V,w+=i*$,v+=i*Z,_+=i*X,k+=i*Y,c+=(i=t[3])*T,u+=i*z,h+=i*q,d+=i*F,f+=i*O,l+=i*L,p+=i*N,y+=i*j,b+=i*H,m+=i*W,g+=i*G,w+=i*V,v+=i*$,_+=i*Z,k+=i*X,A+=i*Y,u+=(i=t[4])*T,h+=i*z,d+=i*q,f+=i*F,l+=i*O,p+=i*L,y+=i*N,b+=i*j,m+=i*H,g+=i*W,w+=i*G,v+=i*V,_+=i*$,k+=i*Z,A+=i*X,S+=i*Y,h+=(i=t[5])*T,d+=i*z,f+=i*q,l+=i*F,p+=i*O,y+=i*L,b+=i*N,m+=i*j,g+=i*H,w+=i*W,v+=i*G,_+=i*V,k+=i*$,A+=i*Z,S+=i*X,E+=i*Y,d+=(i=t[6])*T,f+=i*z,l+=i*q,p+=i*F,y+=i*O,b+=i*L,m+=i*N,g+=i*j,w+=i*H,v+=i*W,_+=i*G,k+=i*V,A+=i*$,S+=i*Z,E+=i*X,P+=i*Y,f+=(i=t[7])*T,l+=i*z,p+=i*q,y+=i*F,b+=i*O,m+=i*L,g+=i*N,w+=i*j,v+=i*H,_+=i*W,k+=i*G,A+=i*V,S+=i*$,E+=i*Z,P+=i*X,x+=i*Y,l+=(i=t[8])*T,p+=i*z,y+=i*q,b+=i*F,m+=i*O,g+=i*L,w+=i*N,v+=i*j,_+=i*H,k+=i*W,A+=i*G,S+=i*V,E+=i*$,P+=i*Z,x+=i*X,M+=i*Y,p+=(i=t[9])*T,y+=i*z,b+=i*q,m+=i*F,g+=i*O,w+=i*L,v+=i*N,_+=i*j,k+=i*H,A+=i*W,S+=i*G,E+=i*V,P+=i*$,x+=i*Z,M+=i*X,K+=i*Y,y+=(i=t[10])*T,b+=i*z,m+=i*q,g+=i*F,w+=i*O,v+=i*L,_+=i*N,k+=i*j,A+=i*H,S+=i*W,E+=i*G,P+=i*V,x+=i*$,M+=i*Z,K+=i*X,C+=i*Y,b+=(i=t[11])*T,m+=i*z,g+=i*q,w+=i*F,v+=i*O,_+=i*L,k+=i*N,A+=i*j,S+=i*H,E+=i*W,P+=i*G,x+=i*V,M+=i*$,K+=i*Z,C+=i*X,D+=i*Y,m+=(i=t[12])*T,g+=i*z,w+=i*q,v+=i*F,_+=i*O,k+=i*L,A+=i*N,S+=i*j,E+=i*H,P+=i*W,x+=i*G,M+=i*V,K+=i*$,C+=i*Z,D+=i*X,U+=i*Y,g+=(i=t[13])*T,w+=i*z,v+=i*q,_+=i*F,k+=i*O,A+=i*L,S+=i*N,E+=i*j,P+=i*H,x+=i*W,M+=i*G,K+=i*V,C+=i*$,D+=i*Z,U+=i*X,R+=i*Y,w+=(i=t[14])*T,v+=i*z,_+=i*q,k+=i*F,A+=i*O,S+=i*L,E+=i*N,P+=i*j,x+=i*H,M+=i*W,K+=i*G,C+=i*V,D+=i*$,U+=i*Z,R+=i*X,I+=i*Y,v+=(i=t[15])*T,s+=38*(k+=i*q),o+=38*(A+=i*F),c+=38*(S+=i*O),u+=38*(E+=i*L),h+=38*(P+=i*N),d+=38*(x+=i*j),f+=38*(M+=i*H),l+=38*(K+=i*W),p+=38*(C+=i*G),y+=38*(D+=i*V),b+=38*(U+=i*$),m+=38*(R+=i*Z),g+=38*(I+=i*X),w+=38*(B+=i*Y),a=(i=(a+=38*(_+=i*z))+(n=1)+65535)-65536*(n=Math.floor(i/65536)),s=(i=s+n+65535)-65536*(n=Math.floor(i/65536)),o=(i=o+n+65535)-65536*(n=Math.floor(i/65536)),c=(i=c+n+65535)-65536*(n=Math.floor(i/65536)),u=(i=u+n+65535)-65536*(n=Math.floor(i/65536)),h=(i=h+n+65535)-65536*(n=Math.floor(i/65536)),d=(i=d+n+65535)-65536*(n=Math.floor(i/65536)),f=(i=f+n+65535)-65536*(n=Math.floor(i/65536)),l=(i=l+n+65535)-65536*(n=Math.floor(i/65536)),p=(i=p+n+65535)-65536*(n=Math.floor(i/65536)),y=(i=y+n+65535)-65536*(n=Math.floor(i/65536)),b=(i=b+n+65535)-65536*(n=Math.floor(i/65536)),m=(i=m+n+65535)-65536*(n=Math.floor(i/65536)),g=(i=g+n+65535)-65536*(n=Math.floor(i/65536)),w=(i=w+n+65535)-65536*(n=Math.floor(i/65536)),v=(i=v+n+65535)-65536*(n=Math.floor(i/65536)),a=(i=(a+=n-1+37*(n-1))+(n=1)+65535)-65536*(n=Math.floor(i/65536)),s=(i=s+n+65535)-65536*(n=Math.floor(i/65536)),o=(i=o+n+65535)-65536*(n=Math.floor(i/65536)),c=(i=c+n+65535)-65536*(n=Math.floor(i/65536)),u=(i=u+n+65535)-65536*(n=Math.floor(i/65536)),h=(i=h+n+65535)-65536*(n=Math.floor(i/65536)),d=(i=d+n+65535)-65536*(n=Math.floor(i/65536)),f=(i=f+n+65535)-65536*(n=Math.floor(i/65536)),l=(i=l+n+65535)-65536*(n=Math.floor(i/65536)),p=(i=p+n+65535)-65536*(n=Math.floor(i/65536)),y=(i=y+n+65535)-65536*(n=Math.floor(i/65536)),b=(i=b+n+65535)-65536*(n=Math.floor(i/65536)),m=(i=m+n+65535)-65536*(n=Math.floor(i/65536)),g=(i=g+n+65535)-65536*(n=Math.floor(i/65536)),w=(i=w+n+65535)-65536*(n=Math.floor(i/65536)),v=(i=v+n+65535)-65536*(n=Math.floor(i/65536)),a+=n-1+37*(n-1),e[0]=a,e[1]=s,e[2]=o,e[3]=c,e[4]=u,e[5]=h,e[6]=d,e[7]=f,e[8]=l,e[9]=p,e[10]=y,e[11]=b,e[12]=m,e[13]=g,e[14]=w,e[15]=v;}function A(e,t){k(e,t,t);}function S(e,r){var i,n=t();for(i=0;i<16;i++)n[i]=r[i];for(i=253;i>=0;i--)A(n,n),2!==i&&4!==i&&k(n,n,r);for(i=0;i<16;i++)e[i]=n[i];}function E(e,r,i){var n,a,o=new Uint8Array(32),c=new Float64Array(80),u=t(),h=t(),d=t(),f=t(),l=t(),p=t();for(a=0;a<31;a++)o[a]=r[a];for(o[31]=127&r[31]|64,o[0]&=248,w(c,i),a=0;a<16;a++)h[a]=c[a],f[a]=u[a]=d[a]=0;for(u[0]=f[0]=1,a=254;a>=0;--a)y(u,h,n=o[a>>>3]>>>(7&a)&1),y(d,f,n),v(l,u,d),_(u,u,d),v(d,h,f),_(h,h,f),A(f,l),A(p,u),k(u,d,u),k(d,h,l),v(l,u,d),_(u,u,d),A(h,u),_(d,f,p),k(u,d,s),v(u,u,f),k(d,d,u),k(u,f,p),k(f,h,c),A(h,l),y(u,h,n),y(d,f,n);for(a=0;a<16;a++)c[a+16]=u[a],c[a+32]=d[a],c[a+48]=h[a],c[a+64]=f[a];var m=c.subarray(32),g=c.subarray(16);return S(m,m),k(g,g,m),b(e,g),0}function P(e,t){return E(e,t,i)}function x(e,r){var i=t(),n=t(),a=t(),s=t(),o=t(),u=t(),h=t(),d=t(),f=t();_(i,e[1],e[0]),_(f,r[1],r[0]),k(i,i,f),v(n,e[0],e[1]),v(f,r[0],r[1]),k(n,n,f),k(a,e[3],r[3]),k(a,a,c),k(s,e[2],r[2]),v(s,s,s),_(o,n,i),_(u,s,a),v(h,s,a),v(d,n,i),k(e[0],o,u),k(e[1],d,h),k(e[2],h,u),k(e[3],o,d);}function M(e,t,r){var i;for(i=0;i<4;i++)y(e[i],t[i],r);}function K(e,r){var i=t(),n=t(),a=t();S(a,r[2]),k(i,r[0],a),k(n,r[1],a),b(e,n),e[31]^=g(i)<<7;}function C(e,t,r){var i,s;for(l(e[0],n),l(e[1],a),l(e[2],a),l(e[3],n),s=255;s>=0;--s)M(e,t,i=r[s/8|0]>>(7&s)&1),x(t,e),x(e,e),M(e,t,i);}function D(e,r){var i=[t(),t(),t(),t()];l(i[0],u),l(i[1],h),l(i[2],a),k(i[3],u,h),C(e,i,r);}function U(i,n,a){var s,o,c=[t(),t(),t(),t()];for(a||r(n,32),(s=e.hash(n.subarray(0,32)))[0]&=248,s[31]&=127,s[31]|=64,D(c,s),K(i,c),o=0;o<32;o++)n[o+32]=i[o];return 0}var R=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function I(e,t){var r,i,n,a;for(i=63;i>=32;--i){for(r=0,n=i-32,a=i-12;n<a;++n)t[n]+=r-16*t[i]*R[n-(i-32)],r=Math.floor((t[n]+128)/256),t[n]-=256*r;t[n]+=r,t[i]=0;}for(r=0,n=0;n<32;n++)t[n]+=r-(t[31]>>4)*R[n],r=t[n]>>8,t[n]&=255;for(n=0;n<32;n++)t[n]-=r*R[n];for(i=0;i<32;i++)t[i+1]+=t[i]>>8,e[i]=255&t[i];}function B(e){var t,r=new Float64Array(64);for(t=0;t<64;t++)r[t]=e[t];for(t=0;t<64;t++)e[t]=0;I(e,r);}function T(e,r){var i=t(),s=t(),c=t(),u=t(),h=t(),f=t(),p=t();return l(e[2],a),w(e[1],r),A(c,e[1]),k(u,c,o),_(c,c,e[2]),v(u,e[2],u),A(h,u),A(f,h),k(p,f,h),k(i,p,c),k(i,i,u),function(e,r){var i,n=t();for(i=0;i<16;i++)n[i]=r[i];for(i=250;i>=0;i--)A(n,n),1!==i&&k(n,n,r);for(i=0;i<16;i++)e[i]=n[i];}(i,i),k(i,i,c),k(i,i,u),k(i,i,u),k(e[0],i,u),A(s,e[0]),k(s,s,u),m(s,c)&&k(e[0],e[0],d),A(s,e[0]),k(s,s,u),m(s,c)?-1:(g(e[0])===r[31]>>7&&_(e[0],n,e[0]),k(e[3],e[0],e[1]),0)}var z=64;function q(){for(var e=0;e<arguments.length;e++)if(!(arguments[e]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}function F(e){for(var t=0;t<e.length;t++)e[t]=0;}e.scalarMult=function(e,t){if(q(e,t),32!==e.length)throw Error("bad n size");if(32!==t.length)throw Error("bad p size");var r=new Uint8Array(32);return E(r,e,t),r},e.box={},e.box.keyPair=function(){var e,t,i=new Uint8Array(32),n=new Uint8Array(32);return e=i,r(t=n,32),P(e,t),{publicKey:i,secretKey:n}},e.box.keyPair.fromSecretKey=function(e){if(q(e),32!==e.length)throw Error("bad secret key size");var t=new Uint8Array(32);return P(t,e),{publicKey:t,secretKey:new Uint8Array(e)}},e.sign=function(r,i){if(q(r,i),64!==i.length)throw Error("bad secret key size");var n=new Uint8Array(z+r.length);return function(r,i,n,a){var s,o,c,u,h,d=new Float64Array(64),f=[t(),t(),t(),t()];(s=e.hash(a.subarray(0,32)))[0]&=248,s[31]&=127,s[31]|=64;var l=n+64;for(u=0;u<n;u++)r[64+u]=i[u];for(u=0;u<32;u++)r[32+u]=s[32+u];for(B(c=e.hash(r.subarray(32,l))),D(f,c),K(r,f),u=32;u<64;u++)r[u]=a[u];for(B(o=e.hash(r.subarray(0,l))),u=0;u<64;u++)d[u]=0;for(u=0;u<32;u++)d[u]=c[u];for(u=0;u<32;u++)for(h=0;h<32;h++)d[u+h]+=o[u]*s[h];I(r.subarray(32),d);}(n,r,r.length,i),n},e.sign.detached=function(t,r){for(var i=e.sign(t,r),n=new Uint8Array(z),a=0;a<n.length;a++)n[a]=i[a];return n},e.sign.detached.verify=function(r,i,n){if(q(r,i,n),i.length!==z)throw Error("bad signature size");if(32!==n.length)throw Error("bad public key size");var a,s=new Uint8Array(z+r.length),o=new Uint8Array(z+r.length);for(a=0;a<z;a++)s[a]=i[a];for(a=0;a<r.length;a++)s[a+z]=r[a];return function(r,i,n,a){var s,o,c=new Uint8Array(32),u=[t(),t(),t(),t()],h=[t(),t(),t(),t()];if(n<64)return -1;if(T(h,a))return -1;for(s=0;s<n;s++)r[s]=i[s];for(s=0;s<32;s++)r[s+32]=a[s];if(B(o=e.hash(r.subarray(0,n))),C(u,h,o),D(h,i.subarray(32)),x(u,h),K(c,u),n-=64,f(i,0,c,0)){for(s=0;s<n;s++)r[s]=0;return -1}for(s=0;s<n;s++)r[s]=i[s+64];return n}(o,s,s.length,n)>=0},e.sign.keyPair=function(){var e=new Uint8Array(32),t=new Uint8Array(64);return U(e,t),{publicKey:e,secretKey:t}},e.sign.keyPair.fromSecretKey=function(e){if(q(e),64!==e.length)throw Error("bad secret key size");for(var t=new Uint8Array(32),r=0;r<t.length;r++)t[r]=e[32+r];return {publicKey:t,secretKey:new Uint8Array(e)}},e.sign.keyPair.fromSeed=function(e){if(q(e),32!==e.length)throw Error("bad seed size");for(var t=new Uint8Array(32),r=new Uint8Array(64),i=0;i<32;i++)r[i]=e[i];return U(t,r,!0),{publicKey:t,secretKey:r}},e.setPRNG=function(e){r=e;},function(){var t="undefined"!=typeof self?self.crypto||self.msCrypto:null;if(t&&t.getRandomValues){e.setPRNG((function(e,r){var i,n=new Uint8Array(r);for(i=0;i<r;i+=65536)t.getRandomValues(n.subarray(i,i+Math.min(r-i,65536)));for(i=0;i<r;i++)e[i]=n[i];F(n);}));}else void 0!==nt&&(t=void 0)&&t.randomBytes&&e.setPRNG((function(e,r){var i,n=t.randomBytes(r);for(i=0;i<r;i++)e[i]=n[i];F(n);}));}();}(e.exports?e.exports:self.nacl=self.nacl||{});}));const Fi=X.getNodeCrypto();function Oi(e){const t=new Uint8Array(e);if(Fi){const e=Fi.randomBytes(t.length);t.set(e);}else {if("undefined"==typeof crypto||!crypto.getRandomValues)throw Error("No secure random number generator available.");crypto.getRandomValues(t);}return t}async function Li(e,t){const r=await X.getBigInteger();if(t.lt(e))throw Error("Illegal parameter value: max <= min");const i=t.sub(e),n=i.byteLength();return new r(await Oi(n+8)).mod(i).add(e)}var Ni=/*#__PURE__*/Object.freeze({__proto__:null,getRandomBytes:Oi,getRandomBigInteger:Li});async function ji(e,t,r){const i=await X.getBigInteger(),n=new i(1),a=n.leftShift(new i(e-1)),s=new i(30),o=[1,6,5,4,3,2,1,4,3,2,1,2,1,4,3,2,1,2,1,4,3,2,1,6,5,4,3,2,1,2],c=await Li(a,a.leftShift(n));let u=c.mod(s).toNumber();do{c.iadd(new i(o[u])),u=(u+o[u])%o.length,c.bitLength()>e&&(c.imod(a.leftShift(n)).iadd(a),u=c.mod(s).toNumber());}while(!await Hi(c,t,r));return c}async function Hi(e,t,r){return !(t&&!e.dec().gcd(t).isOne())&&(!!await async function(e){const t=await X.getBigInteger();return Wi.every((r=>0!==e.mod(new t(r))))}(e)&&(!!await async function(e,t){const r=await X.getBigInteger();return t=t||new r(2),t.modExp(e.dec(),e).isOne()}(e)&&!!await async function(e,t,r){const i=await X.getBigInteger(),n=e.bitLength();t||(t=Math.max(1,n/48|0));const a=e.dec();let s=0;for(;!a.getBit(s);)s++;const o=e.rightShift(new i(s));for(;t>0;t--){let t,n=(r?r():await Li(new i(2),a)).modExp(o,e);if(!n.isOne()&&!n.equal(a)){for(t=1;t<s;t++){if(n=n.mul(n).mod(e),n.isOne())return !1;if(n.equal(a))break}if(t===s)return !1}}return !0}(e,r)))}const Wi=[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999];const Gi=[];function Vi(e,t){const r=e.length;if(r>t-11)throw Error("Message too long");const i=function(e){const t=new Uint8Array(e);let r=0;for(;r<e;){const i=Oi(e-r);for(let e=0;e<i.length;e++)0!==i[e]&&(t[r++]=i[e]);}return t}(t-r-3),n=new Uint8Array(t);return n[1]=2,n.set(i,2),n.set(e,t-r),n}function $i(e,t){let r=2,i=1;for(let t=r;t<e.length;t++)i&=0!==e[t],r+=i;const n=r-2,a=e.subarray(r+1),s=0===e[0]&2===e[1]&n>=8&!i;if(t)return X.selectUint8Array(s,a,t);if(s)return a;throw Error("Decryption error")}async function Zi(e,t,r){let i;if(t.length!==Gr.getHashByteLength(e))throw Error("Invalid hash length");const n=new Uint8Array(Gi[e].length);for(i=0;i<Gi[e].length;i++)n[i]=Gi[e][i];const a=n.length+t.length;if(r<a+11)throw Error("Intended encoded message length too short");const s=new Uint8Array(r-a-3).fill(255),o=new Uint8Array(r);return o[1]=1,o.set(s,2),o.set(n,r-a),o.set(t,r-t.length),o}Gi[1]=[48,32,48,12,6,8,42,134,72,134,247,13,2,5,5,0,4,16],Gi[2]=[48,33,48,9,6,5,43,14,3,2,26,5,0,4,20],Gi[3]=[48,33,48,9,6,5,43,36,3,2,1,5,0,4,20],Gi[8]=[48,49,48,13,6,9,96,134,72,1,101,3,4,2,1,5,0,4,32],Gi[9]=[48,65,48,13,6,9,96,134,72,1,101,3,4,2,2,5,0,4,48],Gi[10]=[48,81,48,13,6,9,96,134,72,1,101,3,4,2,3,5,0,4,64],Gi[11]=[48,45,48,13,6,9,96,134,72,1,101,3,4,2,4,5,0,4,28];var Xi=/*#__PURE__*/Object.freeze({__proto__:null,emeEncode:Vi,emeDecode:$i,emsaEncode:Zi});const Yi=X.getWebCrypto(),Qi=X.getNodeCrypto(),Ji=void 0,en=Qi?Ji.define("RSAPrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("modulus").int(),this.key("publicExponent").int(),this.key("privateExponent").int(),this.key("prime1").int(),this.key("prime2").int(),this.key("exponent1").int(),this.key("exponent2").int(),this.key("coefficient").int());})):void 0,tn=Qi?Ji.define("RSAPubliceKey",(function(){this.seq().obj(this.key("modulus").int(),this.key("publicExponent").int());})):void 0;var rn=/*#__PURE__*/Object.freeze({__proto__:null,sign:async function(e,t,r,i,n,a,s,o,c){if(t&&!X.isStream(t))if(X.getWebCrypto())try{return await async function(e,t,r,i,n,a,s,o){const c=await async function(e,t,r,i,n,a){const s=await X.getBigInteger(),o=new s(i),c=new s(n),u=new s(r);let h=u.mod(c.dec()),d=u.mod(o.dec());return d=d.toUint8Array(),h=h.toUint8Array(),{kty:"RSA",n:ie(e,!0),e:ie(t,!0),d:ie(r,!0),p:ie(n,!0),q:ie(i,!0),dp:ie(h,!0),dq:ie(d,!0),qi:ie(a,!0),ext:!0}}(r,i,n,a,s,o),u={name:"RSASSA-PKCS1-v1_5",hash:{name:e}},h=await Yi.importKey("jwk",c,u,!1,["sign"]);return new Uint8Array(await Yi.sign("RSASSA-PKCS1-v1_5",h,t))}($.read($.webHash,e),t,r,i,n,a,s,o)}catch(e){X.printDebugError(e);}else if(X.getNodeCrypto())return async function(e,t,r,i,n,a,s,o){const{default:c}=await Promise.resolve().then((function(){return sy})),u=new c(a),h=new c(s),d=new c(n),f=d.mod(h.subn(1)),l=d.mod(u.subn(1)),p=Qi.createSign($.read($.hash,e));p.write(t),p.end();const y={version:0,modulus:new c(r),publicExponent:new c(i),privateExponent:new c(n),prime1:new c(s),prime2:new c(a),exponent1:f,exponent2:l,coefficient:new c(o)};if(void 0!==Qi.createPrivateKey){const e=en.encode(y,"der");return new Uint8Array(p.sign({key:e,format:"der",type:"pkcs1"}))}const b=en.encode(y,"pem",{label:"RSA PRIVATE KEY"});return new Uint8Array(p.sign(b))}(e,t,r,i,n,a,s,o);return async function(e,t,r,i){const n=await X.getBigInteger();t=new n(t);const a=new n(await Zi(e,i,t.byteLength()));if(r=new n(r),a.gte(t))throw Error("Message size cannot exceed modulus size");return a.modExp(r,t).toUint8Array("be",t.byteLength())}(e,r,n,c)},verify:async function(e,t,r,i,n,a){if(t&&!X.isStream(t))if(X.getWebCrypto())try{return await async function(e,t,r,i,n){const a=function(e,t){return {kty:"RSA",n:ie(e,!0),e:ie(t,!0),ext:!0}}(i,n),s=await Yi.importKey("jwk",a,{name:"RSASSA-PKCS1-v1_5",hash:{name:e}},!1,["verify"]);return Yi.verify("RSASSA-PKCS1-v1_5",s,r,t)}($.read($.webHash,e),t,r,i,n)}catch(e){X.printDebugError(e);}else if(X.getNodeCrypto())return async function(e,t,r,i,n){const{default:a}=await Promise.resolve().then((function(){return sy})),s=Qi.createVerify($.read($.hash,e));s.write(t),s.end();const o={modulus:new a(i),publicExponent:new a(n)};let c;if(void 0!==Qi.createPrivateKey){c={key:tn.encode(o,"der"),format:"der",type:"pkcs1"};}else c=tn.encode(o,"pem",{label:"RSA PUBLIC KEY"});try{return await s.verify(c,r)}catch(e){return !1}}(e,t,r,i,n);return async function(e,t,r,i,n){const a=await X.getBigInteger();if(r=new a(r),t=new a(t),i=new a(i),t.gte(r))throw Error("Signature size cannot exceed modulus size");const s=t.modExp(i,r).toUint8Array("be",r.byteLength()),o=await Zi(e,n,r.byteLength());return X.equalsUint8Array(s,o)}(e,r,i,n,a)},encrypt:async function(e,t,r){return X.getNodeCrypto()?async function(e,t,r){const{default:i}=await Promise.resolve().then((function(){return sy})),n={modulus:new i(t),publicExponent:new i(r)};let a;if(void 0!==Qi.createPrivateKey){a={key:tn.encode(n,"der"),format:"der",type:"pkcs1",padding:Qi.constants.RSA_PKCS1_PADDING};}else {a={key:tn.encode(n,"pem",{label:"RSA PUBLIC KEY"}),padding:Qi.constants.RSA_PKCS1_PADDING};}return new Uint8Array(Qi.publicEncrypt(a,e))}(e,t,r):async function(e,t,r){const i=await X.getBigInteger();if(t=new i(t),e=new i(Vi(e,t.byteLength())),r=new i(r),e.gte(t))throw Error("Message size cannot exceed modulus size");return e.modExp(r,t).toUint8Array("be",t.byteLength())}(e,t,r)},decrypt:async function(e,t,r,i,n,a,s,o){return X.getNodeCrypto()?async function(e,t,r,i,n,a,s,o){const{default:c}=await Promise.resolve().then((function(){return sy})),u=new c(n),h=new c(a),d=new c(i),f=d.mod(h.subn(1)),l=d.mod(u.subn(1)),p={version:0,modulus:new c(t),publicExponent:new c(r),privateExponent:new c(i),prime1:new c(a),prime2:new c(n),exponent1:f,exponent2:l,coefficient:new c(s)};let y;if(void 0!==Qi.createPrivateKey){y={key:en.encode(p,"der"),format:"der",type:"pkcs1",padding:Qi.constants.RSA_PKCS1_PADDING};}else {y={key:en.encode(p,"pem",{label:"RSA PRIVATE KEY"}),padding:Qi.constants.RSA_PKCS1_PADDING};}try{return new Uint8Array(Qi.privateDecrypt(y,e))}catch(e){if(o)return o;throw Error("Decryption error")}}(e,t,r,i,n,a,s,o):async function(e,t,r,i,n,a,s,o){const c=await X.getBigInteger();if(e=new c(e),t=new c(t),r=new c(r),i=new c(i),n=new c(n),a=new c(a),s=new c(s),e.gte(t))throw Error("Data too large.");const u=i.mod(a.dec()),h=i.mod(n.dec()),d=(await Li(new c(2),t)).mod(t),f=d.modInv(t).modExp(r,t);e=e.mul(f).mod(t);const l=e.modExp(h,n),p=e.modExp(u,a),y=s.mul(p.sub(l)).mod(a);let b=y.mul(n).add(l);return b=b.mul(d).mod(t),$i(b.toUint8Array("be",t.byteLength()),o)}(e,t,r,i,n,a,s,o)},generate:async function(e,t){if(t=new(await X.getBigInteger())(t),X.getWebCrypto()){const r={name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:t.toUint8Array(),hash:{name:"SHA-1"}},i=await Yi.generateKey(r,!0,["sign","verify"]),n=await Yi.exportKey("jwk",i.privateKey);return {n:re(n.n),e:t.toUint8Array(),d:re(n.d),p:re(n.q),q:re(n.p),u:re(n.qi)}}if(X.getNodeCrypto()&&Qi.generateKeyPair&&en){const r={modulusLength:e,publicExponent:t.toNumber(),publicKeyEncoding:{type:"pkcs1",format:"der"},privateKeyEncoding:{type:"pkcs1",format:"der"}},i=await new Promise(((e,t)=>{Qi.generateKeyPair("rsa",r,((r,i,n)=>{r?t(r):e(en.decode(n,"der"));}));}));return {n:i.modulus.toArrayLike(Uint8Array),e:i.publicExponent.toArrayLike(Uint8Array),d:i.privateExponent.toArrayLike(Uint8Array),p:i.prime2.toArrayLike(Uint8Array),q:i.prime1.toArrayLike(Uint8Array),u:i.coefficient.toArrayLike(Uint8Array)}}let r,i,n;do{i=await ji(e-(e>>1),t,40),r=await ji(e>>1,t,40),n=r.mul(i);}while(n.bitLength()!==e);const a=r.dec().imul(i.dec());return i.lt(r)&&([r,i]=[i,r]),{n:n.toUint8Array(),e:t.toUint8Array(),d:t.modInv(a).toUint8Array(),p:r.toUint8Array(),q:i.toUint8Array(),u:r.modInv(i).toUint8Array()}},validateParams:async function(e,t,r,i,n,a){const s=await X.getBigInteger();if(e=new s(e),i=new s(i),n=new s(n),!i.mul(n).equal(e))return !1;const o=new s(2);if(a=new s(a),!i.mul(a).mod(n).isOne())return !1;t=new s(t),r=new s(r);const c=new s(Math.floor(e.bitLength()/3)),u=await Li(o,o.leftShift(c)),h=u.mul(r).mul(t);return !(!h.mod(i.dec()).equal(u)||!h.mod(n.dec()).equal(u))}});var nn=/*#__PURE__*/Object.freeze({__proto__:null,encrypt:async function(e,t,r,i){const n=await X.getBigInteger();t=new n(t),r=new n(r),i=new n(i);const a=new n(Vi(e,t.byteLength())),s=await Li(new n(1),t.dec());return {c1:r.modExp(s,t).toUint8Array(),c2:i.modExp(s,t).imul(a).imod(t).toUint8Array()}},decrypt:async function(e,t,r,i,n){const a=await X.getBigInteger();return e=new a(e),t=new a(t),r=new a(r),i=new a(i),$i(e.modExp(i,r).modInv(r).imul(t).imod(r).toUint8Array("be",r.byteLength()),n)},validateParams:async function(e,t,r,i){const n=await X.getBigInteger();e=new n(e),t=new n(t),r=new n(r);const a=new n(1);if(t.lte(a)||t.gte(e))return !1;const s=new n(e.bitLength()),o=new n(1023);if(s.lt(o))return !1;if(!t.modExp(e.dec(),e).isOne())return !1;let c=t;const u=new n(1),h=new n(2).leftShift(new n(17));for(;u.lt(h);){if(c=c.mul(t).imod(e),c.isOne())return !1;u.iinc();}i=new n(i);const d=new n(2),f=await Li(d.leftShift(s.dec()),d.leftShift(s)),l=e.dec().imul(f).iadd(i);return !!r.equal(t.modExp(l,e))}});class an{constructor(e){if(e instanceof an)this.oid=e.oid;else if(X.isArray(e)||X.isUint8Array(e)){if(6===(e=new Uint8Array(e))[0]){if(e[1]!==e.length-2)throw Error("Length mismatch in DER encoded oid");e=e.subarray(2);}this.oid=e;}else this.oid="";}read(e){if(e.length>=1){const t=e[0];if(e.length>=1+t)return this.oid=e.subarray(1,1+t),1+this.oid.length}throw Error("Invalid oid")}write(){return X.concatUint8Array([new Uint8Array([this.oid.length]),this.oid])}toHex(){return X.uint8ArrayToHex(this.oid)}getName(){const e=this.toHex();if($.curve[e])return $.write($.curve,e);throw Error("Unknown curve object identifier.")}}function sn(e,t){return e.keyPair({priv:t})}function on(e,t){const r=e.keyPair({pub:t});if(!0!==r.validate().result)throw Error("Invalid elliptic public key");return r}async function cn(e){if(!ne.useIndutnyElliptic)throw Error("This curve is only supported in the full build of OpenPGP.js");const{default:t}=await Promise.resolve().then((function(){return Eb}));return new t.ec(e)}function un(e){let t,r=0;const i=e[0];return i<192?([r]=e,t=1):i<255?(r=(e[0]-192<<8)+e[1]+192,t=2):255===i&&(r=X.readNumber(e.subarray(1,5)),t=5),{len:r,offset:t}}function hn(e){return e<192?new Uint8Array([e]):e>191&&e<8384?new Uint8Array([192+(e-192>>8),e-192&255]):X.concatUint8Array([new Uint8Array([255]),X.writeNumber(e,4)])}function dn(e){if(e<0||e>30)throw Error("Partial Length power must be between 1 and 30");return new Uint8Array([224+e])}function fn$9(e){return new Uint8Array([192|e])}function ln(e,t){return X.concatUint8Array([fn$9(e),hn(t)])}function pn(e){return [$.packet.literalData,$.packet.compressedData,$.packet.symmetricallyEncryptedData,$.packet.symEncryptedIntegrityProtectedData,$.packet.aeadEncryptedData].includes(e)}async function yn(e,t){const r=C(e);let i,n;try{const s=await r.peekBytes(2);if(!s||s.length<2||0==(128&s[0]))throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");const o=await r.readByte();let c,u,h=-1,d=-1;d=0,0!=(64&o)&&(d=1),d?h=63&o:(h=(63&o)>>2,u=3&o);const f=pn(h);let l,p=null;if(f){if("array"===X.isStream(e)){const e=new a;i=D(e),p=e;}else {const e=new S;i=D(e.writable),p=e.readable;}n=t({tag:h,packet:p});}else p=[];do{if(d){const e=await r.readByte();if(l=!1,e<192)c=e;else if(e>=192&&e<224)c=(e-192<<8)+await r.readByte()+192;else if(e>223&&e<255){if(c=1<<(31&e),l=!0,!f)throw new TypeError("This packet type does not support partial lengths.")}else c=await r.readByte()<<24|await r.readByte()<<16|await r.readByte()<<8|await r.readByte();}else switch(u){case 0:c=await r.readByte();break;case 1:c=await r.readByte()<<8|await r.readByte();break;case 2:c=await r.readByte()<<24|await r.readByte()<<16|await r.readByte()<<8|await r.readByte();break;default:c=1/0;}if(c>0){let e=0;for(;;){i&&await i.ready;const{done:t,value:n}=await r.read();if(t){if(c===1/0)break;throw Error("Unexpected end of packet")}const a=c===1/0?n:n.subarray(0,c-e);if(i?await i.write(a):p.push(a),e+=n.length,e>=c){r.unshift(n.subarray(c-e+n.length));break}}}}while(l);const y=await r.peekBytes(f?1/0:2);return i?(await i.ready,await i.close()):(p=X.concatUint8Array(p),await t({tag:h,packet:p})),!y||!y.length}catch(e){if(i)return await i.abort(e),!0;throw e}finally{i&&await n,r.releaseLock();}}class bn extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,bn),this.name="UnsupportedError";}}class mn{constructor(e,t){this.tag=e,this.rawContent=t;}write(){return this.rawContent}}const gn=X.getWebCrypto(),wn=X.getNodeCrypto(),vn={p256:"P-256",p384:"P-384",p521:"P-521"},_n=wn?wn.getCurves():[],kn=wn?{secp256k1:_n.includes("secp256k1")?"secp256k1":void 0,p256:_n.includes("prime256v1")?"prime256v1":void 0,p384:_n.includes("secp384r1")?"secp384r1":void 0,p521:_n.includes("secp521r1")?"secp521r1":void 0,ed25519:_n.includes("ED25519")?"ED25519":void 0,curve25519:_n.includes("X25519")?"X25519":void 0,brainpoolP256r1:_n.includes("brainpoolP256r1")?"brainpoolP256r1":void 0,brainpoolP384r1:_n.includes("brainpoolP384r1")?"brainpoolP384r1":void 0,brainpoolP512r1:_n.includes("brainpoolP512r1")?"brainpoolP512r1":void 0}:{},An={p256:{oid:[6,8,42,134,72,206,61,3,1,7],keyType:$.publicKey.ecdsa,hash:$.hash.sha256,cipher:$.symmetric.aes128,node:kn.p256,web:vn.p256,payloadSize:32,sharedSize:256},p384:{oid:[6,5,43,129,4,0,34],keyType:$.publicKey.ecdsa,hash:$.hash.sha384,cipher:$.symmetric.aes192,node:kn.p384,web:vn.p384,payloadSize:48,sharedSize:384},p521:{oid:[6,5,43,129,4,0,35],keyType:$.publicKey.ecdsa,hash:$.hash.sha512,cipher:$.symmetric.aes256,node:kn.p521,web:vn.p521,payloadSize:66,sharedSize:528},secp256k1:{oid:[6,5,43,129,4,0,10],keyType:$.publicKey.ecdsa,hash:$.hash.sha256,cipher:$.symmetric.aes128,node:kn.secp256k1,payloadSize:32},ed25519:{oid:[6,9,43,6,1,4,1,218,71,15,1],keyType:$.publicKey.eddsaLegacy,hash:$.hash.sha512,node:!1,payloadSize:32},curve25519:{oid:[6,10,43,6,1,4,1,151,85,1,5,1],keyType:$.publicKey.ecdh,hash:$.hash.sha256,cipher:$.symmetric.aes128,node:!1,payloadSize:32},brainpoolP256r1:{oid:[6,9,43,36,3,3,2,8,1,1,7],keyType:$.publicKey.ecdsa,hash:$.hash.sha256,cipher:$.symmetric.aes128,node:kn.brainpoolP256r1,payloadSize:32},brainpoolP384r1:{oid:[6,9,43,36,3,3,2,8,1,1,11],keyType:$.publicKey.ecdsa,hash:$.hash.sha384,cipher:$.symmetric.aes192,node:kn.brainpoolP384r1,payloadSize:48},brainpoolP512r1:{oid:[6,9,43,36,3,3,2,8,1,1,13],keyType:$.publicKey.ecdsa,hash:$.hash.sha512,cipher:$.symmetric.aes256,node:kn.brainpoolP512r1,payloadSize:64}};class Sn{constructor(e,t){try{(X.isArray(e)||X.isUint8Array(e))&&(e=new an(e)),e instanceof an&&(e=e.getName()),this.name=$.write($.curve,e);}catch(e){throw new bn("Unknown curve")}t=t||An[this.name],this.keyType=t.keyType,this.oid=t.oid,this.hash=t.hash,this.cipher=t.cipher,this.node=t.node&&An[this.name],this.web=t.web&&An[this.name],this.payloadSize=t.payloadSize,this.web&&X.getWebCrypto()?this.type="web":this.node&&X.getNodeCrypto()?this.type="node":"curve25519"===this.name?this.type="curve25519":"ed25519"===this.name&&(this.type="ed25519");}async genKeyPair(){let e;switch(this.type){case"web":try{return await async function(e){const t=await gn.generateKey({name:"ECDSA",namedCurve:vn[e]},!0,["sign","verify"]),r=await gn.exportKey("jwk",t.privateKey),i=await gn.exportKey("jwk",t.publicKey);return {publicKey:Pn(i),privateKey:re(r.d)}}(this.name)}catch(e){X.printDebugError("Browser did not support generating ec key "+e.message);break}case"node":return async function(e){const t=wn.createECDH(kn[e]);return await t.generateKeys(),{publicKey:new Uint8Array(t.getPublicKey()),privateKey:new Uint8Array(t.getPrivateKey())}}(this.name);case"curve25519":{const t=Oi(32);t[0]=127&t[0]|64,t[31]&=248;const r=t.slice().reverse();e=qi.box.keyPair.fromSecretKey(r);return {publicKey:X.concatUint8Array([new Uint8Array([64]),e.publicKey]),privateKey:t}}case"ed25519":{const e=Oi(32),t=qi.sign.keyPair.fromSeed(e);return {publicKey:X.concatUint8Array([new Uint8Array([64]),t.publicKey]),privateKey:e}}}const t=await cn(this.name);return e=await t.genKeyPair({entropy:X.uint8ArrayToString(Oi(32))}),{publicKey:new Uint8Array(e.getPublic("array",!1)),privateKey:e.getPrivate().toArrayLike(Uint8Array)}}}async function En(e,t,r,i){const n={p256:!0,p384:!0,p521:!0,secp256k1:!0,curve25519:e===$.publicKey.ecdh,brainpoolP256r1:!0,brainpoolP384r1:!0,brainpoolP512r1:!0},a=t.getName();if(!n[a])return !1;if("curve25519"===a){i=i.slice().reverse();const{publicKey:e}=qi.box.keyPair.fromSecretKey(i);r=new Uint8Array(r);const t=new Uint8Array([64,...e]);return !!X.equalsUint8Array(t,r)}const s=await cn(a);try{r=on(s,r).getPublic();}catch(e){return !1}return !!sn(s,i).getPublic().eq(r)}function Pn(e){const t=re(e.x),r=re(e.y),i=new Uint8Array(t.length+r.length+1);return i[0]=4,i.set(t,1),i.set(r,t.length+1),i}function xn(e,t,r){const i=e,n=r.slice(1,i+1),a=r.slice(i+1,2*i+1);return {kty:"EC",crv:t,x:ie(n,!0),y:ie(a,!0),ext:!0}}function Mn(e,t,r,i){const n=xn(e,t,r);return n.d=ie(i,!0),n}const Kn=X.getWebCrypto(),Cn=X.getNodeCrypto();async function Dn(e,t,r,i,n,a){const s=new Sn(e);if(r&&!X.isStream(r)){const e={publicKey:i,privateKey:n};switch(s.type){case"web":try{return await async function(e,t,r,i){const n=e.payloadSize,a=Mn(e.payloadSize,vn[e.name],i.publicKey,i.privateKey),s=await Kn.importKey("jwk",a,{name:"ECDSA",namedCurve:vn[e.name],hash:{name:$.read($.webHash,e.hash)}},!1,["sign"]),o=new Uint8Array(await Kn.sign({name:"ECDSA",namedCurve:vn[e.name],hash:{name:$.read($.webHash,t)}},s,r));return {r:o.slice(0,n),s:o.slice(n,n<<1)}}(s,t,r,e)}catch(e){if("p521"!==s.name&&("DataError"===e.name||"OperationError"===e.name))throw e;X.printDebugError("Browser did not support signing: "+e.message);}break;case"node":{const i=await async function(e,t,r,i){const n=Cn.createSign($.read($.hash,t));n.write(r),n.end();const a=Bn.encode({version:1,parameters:e.oid,privateKey:Array.from(i.privateKey),publicKey:{unused:0,data:Array.from(i.publicKey)}},"pem",{label:"EC PRIVATE KEY"});return In.decode(n.sign(a),"der")}(s,t,r,e);return {r:i.r.toArrayLike(Uint8Array),s:i.s.toArrayLike(Uint8Array)}}}}return async function(e,t,r){const i=await cn(e.name),n=sn(i,r),a=n.sign(t);return {r:a.r.toArrayLike(Uint8Array),s:a.s.toArrayLike(Uint8Array)}}(s,a,n)}async function Un(e,t,r,i,n,a){const s=new Sn(e);if(i&&!X.isStream(i))switch(s.type){case"web":try{return await async function(e,t,{r,s:i},n,a){const s=xn(e.payloadSize,vn[e.name],a),o=await Kn.importKey("jwk",s,{name:"ECDSA",namedCurve:vn[e.name],hash:{name:$.read($.webHash,e.hash)}},!1,["verify"]),c=X.concatUint8Array([r,i]).buffer;return Kn.verify({name:"ECDSA",namedCurve:vn[e.name],hash:{name:$.read($.webHash,t)}},o,c,n)}(s,t,r,i,n)}catch(e){if("p521"!==s.name&&("DataError"===e.name||"OperationError"===e.name))throw e;X.printDebugError("Browser did not support verifying: "+e.message);}break;case"node":return async function(e,t,{r,s:i},n,a){const{default:s}=await Promise.resolve().then((function(){return sy})),o=Cn.createVerify($.read($.hash,t));o.write(n),o.end();const c=zn.encode({algorithm:{algorithm:[1,2,840,10045,2,1],parameters:e.oid},subjectPublicKey:{unused:0,data:Array.from(a)}},"pem",{label:"PUBLIC KEY"}),u=In.encode({r:new s(r),s:new s(i)},"der");try{return o.verify(c,u)}catch(e){return !1}}(s,t,r,i,n)}return async function(e,t,r,i){const n=await cn(e.name),a=on(n,i);return a.verify(r,t)}(s,r,void 0===t?i:a,n)}const Rn=void 0,In=Cn?Rn.define("ECDSASignature",(function(){this.seq().obj(this.key("r").int(),this.key("s").int());})):void 0,Bn=Cn?Rn.define("ECPrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("privateKey").octstr(),this.key("parameters").explicit(0).optional().any(),this.key("publicKey").explicit(1).optional().bitstr());})):void 0,Tn=Cn?Rn.define("AlgorithmIdentifier",(function(){this.seq().obj(this.key("algorithm").objid(),this.key("parameters").optional().any());})):void 0,zn=Cn?Rn.define("SubjectPublicKeyInfo",(function(){this.seq().obj(this.key("algorithm").use(Tn),this.key("subjectPublicKey").bitstr());})):void 0;var qn=/*#__PURE__*/Object.freeze({__proto__:null,sign:Dn,verify:Un,validateParams:async function(e,t,r){const i=new Sn(e);if(i.keyType!==$.publicKey.ecdsa)return !1;switch(i.type){case"web":case"node":{const i=Oi(8),n=$.hash.sha256,a=await Gr.digest(n,i);try{const s=await Dn(e,n,i,t,r,a);return await Un(e,n,s,i,t,a)}catch(e){return !1}}default:return En($.publicKey.ecdsa,e,t,r)}}});qi.hash=e=>new Uint8Array(Jt().update(e).digest());var Fn=/*#__PURE__*/Object.freeze({__proto__:null,sign:async function(e,t,r,i,n,a){if(Gr.getHashByteLength(t)<Gr.getHashByteLength($.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const s=X.concatUint8Array([n,i.subarray(1)]),o=qi.sign.detached(a,s);return {r:o.subarray(0,32),s:o.subarray(32)}},verify:async function(e,t,{r,s:i},n,a,s){if(Gr.getHashByteLength(t)<Gr.getHashByteLength($.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const o=X.concatUint8Array([r,i]);return qi.sign.detached.verify(s,o,a.subarray(1))},validateParams:async function(e,t,r){if("ed25519"!==e.getName())return !1;const{publicKey:i}=qi.sign.keyPair.fromSeed(r),n=new Uint8Array([64,...i]);return X.equalsUint8Array(t,n)}});function On(e){if(e===$.publicKey.ed25519)return $.hash.sha256;throw Error("Unknown EdDSA algo")}qi.hash=e=>new Uint8Array(Jt().update(e).digest());var Ln=/*#__PURE__*/Object.freeze({__proto__:null,generate:async function(e){if(e===$.publicKey.ed25519){const e=Oi(32),{publicKey:t}=qi.sign.keyPair.fromSeed(e);return {A:t,seed:e}}throw Error("Unsupported EdDSA algorithm")},sign:async function(e,t,r,i,n,a){if(Gr.getHashByteLength(t)<Gr.getHashByteLength(On(e)))throw Error("Hash algorithm too weak for EdDSA.");switch(e){case $.publicKey.ed25519:{const e=X.concatUint8Array([n,i]);return {RS:qi.sign.detached(a,e)}}case $.publicKey.ed448:default:throw Error("Unsupported EdDSA algorithm")}},verify:async function(e,t,{RS:r},i,n,a){if(Gr.getHashByteLength(t)<Gr.getHashByteLength(On(e)))throw Error("Hash algorithm too weak for EdDSA.");switch(e){case $.publicKey.ed25519:return qi.sign.detached.verify(a,r,n);case $.publicKey.ed448:default:throw Error("Unsupported EdDSA algorithm")}},validateParams:async function(e,t,r){switch(e){case $.publicKey.ed25519:{const{publicKey:e}=qi.sign.keyPair.fromSeed(r);return X.equalsUint8Array(t,e)}case $.publicKey.ed448:default:return !1}},getPreferredHashAlgo:On});function Nn(e,t){const r=new We["aes"+8*e.length](e),i=new Uint32Array([2795939494,2795939494]),n=Hn(t);let a=i;const s=n,o=n.length/2,c=new Uint32Array([0,0]);let u=new Uint32Array(4);for(let e=0;e<=5;++e)for(let t=0;t<o;++t)c[1]=o*e+(1+t),u[0]=a[0],u[1]=a[1],u[2]=s[2*t],u[3]=s[2*t+1],u=Hn(r.encrypt(Wn(u))),a=u.subarray(0,2),a[0]^=c[0],a[1]^=c[1],s[2*t]=u[2],s[2*t+1]=u[3];return Wn(a,s)}function jn(e,t){const r=new We["aes"+8*e.length](e),i=new Uint32Array([2795939494,2795939494]),n=Hn(t);let a=n.subarray(0,2);const s=n.subarray(2),o=n.length/2-1,c=new Uint32Array([0,0]);let u=new Uint32Array(4);for(let e=5;e>=0;--e)for(let t=o-1;t>=0;--t)c[1]=o*e+(t+1),u[0]=a[0]^c[0],u[1]=a[1]^c[1],u[2]=s[2*t],u[3]=s[2*t+1],u=Hn(r.decrypt(Wn(u))),a=u.subarray(0,2),s[2*t]=u[2],s[2*t+1]=u[3];if(a[0]===i[0]&&a[1]===i[1])return Wn(s);throw Error("Key Data Integrity failed")}function Hn(e){const{length:t}=e,r=function(e){if(X.isString(e)){const{length:t}=e,r=new ArrayBuffer(t),i=new Uint8Array(r);for(let r=0;r<t;++r)i[r]=e.charCodeAt(r);return r}return new Uint8Array(e).buffer}(e),i=new DataView(r),n=new Uint32Array(t/4);for(let e=0;e<t/4;++e)n[e]=i.getUint32(4*e);return n}function Wn(){let e=0;for(let t=0;t<arguments.length;++t)e+=4*arguments[t].length;const t=new ArrayBuffer(e),r=new DataView(t);let i=0;for(let e=0;e<arguments.length;++e){for(let t=0;t<arguments[e].length;++t)r.setUint32(i+4*t,arguments[e][t]);i+=4*arguments[e].length;}return new Uint8Array(t)}var Gn=/*#__PURE__*/Object.freeze({__proto__:null,wrap:Nn,unwrap:jn});function Vn(e){const t=8-e.length%8,r=new Uint8Array(e.length+t).fill(t);return r.set(e),r}function $n(e){const t=e.length;if(t>0){const r=e[t-1];if(r>=1){const i=e.subarray(t-r),n=new Uint8Array(r).fill(r);if(X.equalsUint8Array(i,n))return e.subarray(0,t-r)}}throw Error("Invalid padding")}var Zn=/*#__PURE__*/Object.freeze({__proto__:null,encode:Vn,decode:$n});const Xn=X.getWebCrypto(),Yn=X.getNodeCrypto();function Qn(e,t,r,i){return X.concatUint8Array([t.write(),new Uint8Array([e]),r.write(),X.stringToUint8Array("Anonymous Sender    "),i.subarray(0,20)])}async function Jn(e,t,r,i,n=!1,a=!1){let s;if(n){for(s=0;s<t.length&&0===t[s];s++);t=t.subarray(s);}if(a){for(s=t.length-1;s>=0&&0===t[s];s--);t=t.subarray(0,s+1);}return (await Gr.digest(e,X.concatUint8Array([new Uint8Array([0,0,0,1]),t,i]))).subarray(0,r)}async function ea(e,t){switch(e.type){case"curve25519":{const r=Oi(32),{secretKey:i,sharedKey:n}=await ta(e,t,null,r);let{publicKey:a}=qi.box.keyPair.fromSecretKey(i);return a=X.concatUint8Array([new Uint8Array([64]),a]),{publicKey:a,sharedKey:n}}case"web":if(e.web&&X.getWebCrypto())try{return await async function(e,t){const r=xn(e.payloadSize,e.web.web,t);let i=Xn.generateKey({name:"ECDH",namedCurve:e.web.web},!0,["deriveKey","deriveBits"]),n=Xn.importKey("jwk",r,{name:"ECDH",namedCurve:e.web.web},!1,[]);[i,n]=await Promise.all([i,n]);let a=Xn.deriveBits({name:"ECDH",namedCurve:e.web.web,public:n},i.privateKey,e.web.sharedSize),s=Xn.exportKey("jwk",i.publicKey);[a,s]=await Promise.all([a,s]);const o=new Uint8Array(a),c=new Uint8Array(Pn(s));return {publicKey:c,sharedKey:o}}(e,t)}catch(e){X.printDebugError(e);}break;case"node":return async function(e,t){const r=Yn.createECDH(e.node.node);r.generateKeys();const i=new Uint8Array(r.computeSecret(t)),n=new Uint8Array(r.getPublicKey());return {publicKey:n,sharedKey:i}}(e,t)}return async function(e,t){const r=await cn(e.name),i=await e.genKeyPair();t=on(r,t);const n=sn(r,i.privateKey),a=i.publicKey,s=n.derive(t.getPublic()),o=r.curve.p.byteLength(),c=s.toArrayLike(Uint8Array,"be",o);return {publicKey:a,sharedKey:c}}(e,t)}async function ta(e,t,r,i){if(i.length!==e.payloadSize){const t=new Uint8Array(e.payloadSize);t.set(i,e.payloadSize-i.length),i=t;}switch(e.type){case"curve25519":{const e=i.slice().reverse();return {secretKey:e,sharedKey:qi.scalarMult(e,t.subarray(1))}}case"web":if(e.web&&X.getWebCrypto())try{return await async function(e,t,r,i){const n=Mn(e.payloadSize,e.web.web,r,i);let a=Xn.importKey("jwk",n,{name:"ECDH",namedCurve:e.web.web},!0,["deriveKey","deriveBits"]);const s=xn(e.payloadSize,e.web.web,t);let o=Xn.importKey("jwk",s,{name:"ECDH",namedCurve:e.web.web},!0,[]);[a,o]=await Promise.all([a,o]);let c=Xn.deriveBits({name:"ECDH",namedCurve:e.web.web,public:o},a,e.web.sharedSize),u=Xn.exportKey("jwk",a);[c,u]=await Promise.all([c,u]);const h=new Uint8Array(c);return {secretKey:re(u.d),sharedKey:h}}(e,t,r,i)}catch(e){X.printDebugError(e);}break;case"node":return async function(e,t,r){const i=Yn.createECDH(e.node.node);i.setPrivateKey(r);const n=new Uint8Array(i.computeSecret(t));return {secretKey:new Uint8Array(i.getPrivateKey()),sharedKey:n}}(e,t,i)}return async function(e,t,r){const i=await cn(e.name);t=on(i,t),r=sn(i,r);const n=new Uint8Array(r.getPrivate()),a=r.derive(t.getPublic()),s=i.curve.p.byteLength(),o=a.toArrayLike(Uint8Array,"be",s);return {secretKey:n,sharedKey:o}}(e,t,i)}var ra=/*#__PURE__*/Object.freeze({__proto__:null,validateParams:async function(e,t,r){return En($.publicKey.ecdh,e,t,r)},encrypt:async function(e,t,r,i,n){const a=Vn(r),s=new Sn(e),{publicKey:o,sharedKey:c}=await ea(s,i),u=Qn($.publicKey.ecdh,e,t,n),{keySize:h}=$r(t.cipher);return {publicKey:o,wrappedKey:Nn(await Jn(t.hash,c,h,u),a)}},decrypt:async function(e,t,r,i,n,a,s){const o=new Sn(e),{sharedKey:c}=await ta(o,r,n,a),u=Qn($.publicKey.ecdh,e,t,s),{keySize:h}=$r(t.cipher);let d;for(let e=0;e<3;e++)try{return $n(jn(await Jn(t.hash,c,h,u,1===e,2===e),i))}catch(e){d=e;}throw d}});const ia=X.getWebCrypto(),na=X.getNodeCrypto(),aa=na&&na.webcrypto&&na.webcrypto.subtle;async function sa(e,t,r,i,n){const a=$.read($.webHash,e);if(!a)throw Error("Hash algo not supported with HKDF");if(ia||aa){const e=ia||aa,s=await e.importKey("raw",t,"HKDF",!1,["deriveBits"]),o=await e.deriveBits({name:"HKDF",hash:a,salt:r,info:i},s,8*n);return new Uint8Array(o)}if(na){const a=$.read($.hash,e),s=(e,t)=>na.createHmac(a,e).update(t).digest(),o=s(r,t),c=o.length,u=Math.ceil(n/c),h=new Uint8Array(u*c),d=new Uint8Array(c+i.length+1);d.set(i,c);for(let e=0;e<u;e++){d[d.length-1]=e+1;const t=s(o,e>0?d:d.subarray(c));d.set(t,0),h.set(t,e*c);}return h.subarray(0,n)}throw Error("No HKDF implementation available")}const oa={x25519:X.encodeUTF8("OpenPGP X25519")};var ca=/*#__PURE__*/Object.freeze({__proto__:null,generate:async function(e){if(e===$.publicKey.x25519){const e=Oi(32),{publicKey:t}=qi.box.keyPair.fromSecretKey(e);return {A:t,k:e}}throw Error("Unsupported ECDH algorithm")},validateParams:async function(e,t,r){if(e===$.publicKey.x25519){const{publicKey:e}=qi.box.keyPair.fromSecretKey(r);return X.equalsUint8Array(t,e)}return !1},encrypt:async function(e,t,r){if(e===$.publicKey.x25519){const e=Oi(32),i=qi.scalarMult(e,r),{publicKey:n}=qi.box.keyPair.fromSecretKey(e),a=X.concatUint8Array([n,r,i]),{keySize:s}=$r($.symmetric.aes128);return {ephemeralPublicKey:n,wrappedKey:Nn(await sa($.hash.sha256,a,new Uint8Array,oa.x25519,s),t)}}throw Error("Unsupported ECDH algorithm")},decrypt:async function(e,t,r,i,n){if(e===$.publicKey.x25519){const e=qi.scalarMult(n,t),a=X.concatUint8Array([t,i,e]),{keySize:s}=$r($.symmetric.aes128);return jn(await sa($.hash.sha256,a,new Uint8Array,oa.x25519,s),r)}throw Error("Unsupported ECDH algorithm")}}),ua=/*#__PURE__*/Object.freeze({__proto__:null,CurveWithOID:Sn,ecdh:ra,ecdhX:ca,ecdsa:qn,eddsaLegacy:Fn,eddsa:Ln,generate:async function(e){const t=await X.getBigInteger();e=new Sn(e);const r=await e.genKeyPair(),i=new t(r.publicKey).toUint8Array(),n=new t(r.privateKey).toUint8Array("be",e.payloadSize);return {oid:e.oid,Q:i,secret:n,hash:e.hash,cipher:e.cipher}},getPreferredHashAlgo:function(e){return An[$.write($.curve,e.toHex())].hash}});var ha=/*#__PURE__*/Object.freeze({__proto__:null,sign:async function(e,t,r,i,n,a){const s=await X.getBigInteger(),o=new s(1);let c,u,h,d;i=new s(i),n=new s(n),r=new s(r),a=new s(a),r=r.mod(i),a=a.mod(n);const f=new s(t.subarray(0,n.byteLength())).mod(n);for(;;){if(c=await Li(o,n),u=r.modExp(c,i).imod(n),u.isZero())continue;const e=a.mul(u).imod(n);if(d=f.add(e).imod(n),h=c.modInv(n).imul(d).imod(n),!h.isZero())break}return {r:u.toUint8Array("be",n.byteLength()),s:h.toUint8Array("be",n.byteLength())}},verify:async function(e,t,r,i,n,a,s,o){const c=await X.getBigInteger(),u=new c(0);if(t=new c(t),r=new c(r),a=new c(a),s=new c(s),n=new c(n),o=new c(o),t.lte(u)||t.gte(s)||r.lte(u)||r.gte(s))return X.printDebug("invalid DSA Signature"),!1;const h=new c(i.subarray(0,s.byteLength())).imod(s),d=r.modInv(s);if(d.isZero())return X.printDebug("invalid DSA Signature"),!1;n=n.mod(a),o=o.mod(a);const f=h.mul(d).imod(s),l=t.mul(d).imod(s),p=n.modExp(f,a),y=o.modExp(l,a);return p.mul(y).imod(a).imod(s).equal(t)},validateParams:async function(e,t,r,i,n){const a=await X.getBigInteger();e=new a(e),t=new a(t),r=new a(r),i=new a(i);const s=new a(1);if(r.lte(s)||r.gte(e))return !1;if(!e.dec().mod(t).isZero())return !1;if(!r.modExp(t,e).isOne())return !1;const o=new a(t.bitLength()),c=new a(150);if(o.lt(c)||!await Hi(t,null,32))return !1;n=new a(n);const u=new a(2),h=await Li(u.leftShift(o.dec()),u.leftShift(o)),d=t.mul(h).add(n);return !!i.equal(r.modExp(d,e))}}),da={rsa:rn,elgamal:nn,elliptic:ua,dsa:ha,nacl:qi};var fa=/*#__PURE__*/Object.freeze({__proto__:null,parseSignatureParams:function(e,t){let r=0;switch(e){case $.publicKey.rsaEncryptSign:case $.publicKey.rsaEncrypt:case $.publicKey.rsaSign:return {s:X.readMPI(t.subarray(r))};case $.publicKey.dsa:case $.publicKey.ecdsa:{const e=X.readMPI(t.subarray(r));r+=e.length+2;return {r:e,s:X.readMPI(t.subarray(r))}}case $.publicKey.eddsaLegacy:{let e=X.readMPI(t.subarray(r));r+=e.length+2,e=X.leftPad(e,32);let i=X.readMPI(t.subarray(r));return i=X.leftPad(i,32),{r:e,s:i}}case $.publicKey.ed25519:{const e=t.subarray(r,r+64);return r+=e.length,{RS:e}}default:throw new bn("Unknown signature algorithm.")}},verify:async function(e,t,r,i,n,a){switch(e){case $.publicKey.rsaEncryptSign:case $.publicKey.rsaEncrypt:case $.publicKey.rsaSign:{const{n:e,e:s}=i,o=X.leftPad(r.s,e.length);return da.rsa.verify(t,n,o,e,s,a)}case $.publicKey.dsa:{const{g:e,p:n,q:s,y:o}=i,{r:c,s:u}=r;return da.dsa.verify(t,c,u,a,e,n,s,o)}case $.publicKey.ecdsa:{const{oid:e,Q:s}=i,o=new da.elliptic.CurveWithOID(e).payloadSize,c=X.leftPad(r.r,o),u=X.leftPad(r.s,o);return da.elliptic.ecdsa.verify(e,t,{r:c,s:u},n,s,a)}case $.publicKey.eddsaLegacy:{const{oid:e,Q:s}=i;return da.elliptic.eddsaLegacy.verify(e,t,r,n,s,a)}case $.publicKey.ed25519:{const{A:s}=i;return da.elliptic.eddsa.verify(e,t,r,n,s,a)}default:throw Error("Unknown signature algorithm.")}},sign:async function(e,t,r,i,n,a){if(!r||!i)throw Error("Missing key parameters");switch(e){case $.publicKey.rsaEncryptSign:case $.publicKey.rsaEncrypt:case $.publicKey.rsaSign:{const{n:e,e:s}=r,{d:o,p:c,q:u,u:h}=i;return {s:await da.rsa.sign(t,n,e,s,o,c,u,h,a)}}case $.publicKey.dsa:{const{g:e,p:n,q:s}=r,{x:o}=i;return da.dsa.sign(t,a,e,n,s,o)}case $.publicKey.elgamal:throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");case $.publicKey.ecdsa:{const{oid:e,Q:s}=r,{d:o}=i;return da.elliptic.ecdsa.sign(e,t,n,s,o,a)}case $.publicKey.eddsaLegacy:{const{oid:e,Q:s}=r,{seed:o}=i;return da.elliptic.eddsaLegacy.sign(e,t,n,s,o,a)}case $.publicKey.ed25519:{const{A:s}=r,{seed:o}=i;return da.elliptic.eddsa.sign(e,t,n,s,o,a)}default:throw Error("Unknown signature algorithm.")}}});class la{constructor(e){e&&(this.data=e);}read(e){if(e.length>=1){const t=e[0];if(e.length>=1+t)return this.data=e.subarray(1,1+t),1+this.data.length}throw Error("Invalid symmetric key")}write(){return X.concatUint8Array([new Uint8Array([this.data.length]),this.data])}}class pa{constructor(e){if(e){const{hash:t,cipher:r}=e;this.hash=t,this.cipher=r;}else this.hash=null,this.cipher=null;}read(e){if(e.length<4||3!==e[0]||1!==e[1])throw new bn("Cannot read KDFParams");return this.hash=e[2],this.cipher=e[3],4}write(){return new Uint8Array([3,1,this.hash,this.cipher])}}class ya{static fromObject({wrappedKey:e,algorithm:t}){const r=new ya;return r.wrappedKey=e,r.algorithm=t,r}read(e){let t=0,r=e[t++];this.algorithm=r%2?e[t++]:null,r-=r%2,this.wrappedKey=e.subarray(t,t+r),t+=r;}write(){return X.concatUint8Array([this.algorithm?new Uint8Array([this.wrappedKey.length+1,this.algorithm]):new Uint8Array([this.wrappedKey.length]),this.wrappedKey])}}function ba(e){try{e.getName();}catch(e){throw new bn("Unknown curve OID")}}var ma=/*#__PURE__*/Object.freeze({__proto__:null,publicKeyEncrypt:async function(e,t,r,i,n){switch(e){case $.publicKey.rsaEncrypt:case $.publicKey.rsaEncryptSign:{const{n:e,e:t}=r;return {c:await da.rsa.encrypt(i,e,t)}}case $.publicKey.elgamal:{const{p:e,g:t,y:n}=r;return da.elgamal.encrypt(i,e,t,n)}case $.publicKey.ecdh:{const{oid:e,Q:t,kdfParams:a}=r,{publicKey:s,wrappedKey:o}=await da.elliptic.ecdh.encrypt(e,a,i,t,n);return {V:s,C:new la(o)}}case $.publicKey.x25519:{if(!X.isAES(t))throw Error("X25519 keys can only encrypt AES session keys");const{A:n}=r,{ephemeralPublicKey:a,wrappedKey:s}=await da.elliptic.ecdhX.encrypt(e,i,n);return {ephemeralPublicKey:a,C:ya.fromObject({algorithm:t,wrappedKey:s})}}default:return []}},publicKeyDecrypt:async function(e,t,r,i,n,a){switch(e){case $.publicKey.rsaEncryptSign:case $.publicKey.rsaEncrypt:{const{c:e}=i,{n,e:s}=t,{d:o,p:c,q:u,u:h}=r;return da.rsa.decrypt(e,n,s,o,c,u,h,a)}case $.publicKey.elgamal:{const{c1:e,c2:n}=i,s=t.p,o=r.x;return da.elgamal.decrypt(e,n,s,o,a)}case $.publicKey.ecdh:{const{oid:e,Q:a,kdfParams:s}=t,{d:o}=r,{V:c,C:u}=i;return da.elliptic.ecdh.decrypt(e,s,c,u.data,a,o,n)}case $.publicKey.x25519:{const{A:n}=t,{k:a}=r,{ephemeralPublicKey:s,C:o}=i;if(!X.isAES(o.algorithm))throw Error("AES session key expected");return da.elliptic.ecdhX.decrypt(e,s,o.wrappedKey,n,a)}default:throw Error("Unknown public key encryption algorithm.")}},parsePublicKeyParams:function(e,t){let r=0;switch(e){case $.publicKey.rsaEncrypt:case $.publicKey.rsaEncryptSign:case $.publicKey.rsaSign:{const e=X.readMPI(t.subarray(r));r+=e.length+2;const i=X.readMPI(t.subarray(r));return r+=i.length+2,{read:r,publicParams:{n:e,e:i}}}case $.publicKey.dsa:{const e=X.readMPI(t.subarray(r));r+=e.length+2;const i=X.readMPI(t.subarray(r));r+=i.length+2;const n=X.readMPI(t.subarray(r));r+=n.length+2;const a=X.readMPI(t.subarray(r));return r+=a.length+2,{read:r,publicParams:{p:e,q:i,g:n,y:a}}}case $.publicKey.elgamal:{const e=X.readMPI(t.subarray(r));r+=e.length+2;const i=X.readMPI(t.subarray(r));r+=i.length+2;const n=X.readMPI(t.subarray(r));return r+=n.length+2,{read:r,publicParams:{p:e,g:i,y:n}}}case $.publicKey.ecdsa:{const e=new an;r+=e.read(t),ba(e);const i=X.readMPI(t.subarray(r));return r+=i.length+2,{read:r,publicParams:{oid:e,Q:i}}}case $.publicKey.eddsaLegacy:{const e=new an;r+=e.read(t),ba(e);let i=X.readMPI(t.subarray(r));return r+=i.length+2,i=X.leftPad(i,33),{read:r,publicParams:{oid:e,Q:i}}}case $.publicKey.ecdh:{const e=new an;r+=e.read(t),ba(e);const i=X.readMPI(t.subarray(r));r+=i.length+2;const n=new pa;return r+=n.read(t.subarray(r)),{read:r,publicParams:{oid:e,Q:i,kdfParams:n}}}case $.publicKey.ed25519:case $.publicKey.x25519:{const e=t.subarray(r,r+32);return r+=e.length,{read:r,publicParams:{A:e}}}default:throw new bn("Unknown public key encryption algorithm.")}},parsePrivateKeyParams:function(e,t,r){let i=0;switch(e){case $.publicKey.rsaEncrypt:case $.publicKey.rsaEncryptSign:case $.publicKey.rsaSign:{const e=X.readMPI(t.subarray(i));i+=e.length+2;const r=X.readMPI(t.subarray(i));i+=r.length+2;const n=X.readMPI(t.subarray(i));i+=n.length+2;const a=X.readMPI(t.subarray(i));return i+=a.length+2,{read:i,privateParams:{d:e,p:r,q:n,u:a}}}case $.publicKey.dsa:case $.publicKey.elgamal:{const e=X.readMPI(t.subarray(i));return i+=e.length+2,{read:i,privateParams:{x:e}}}case $.publicKey.ecdsa:case $.publicKey.ecdh:{const e=new Sn(r.oid);let n=X.readMPI(t.subarray(i));return i+=n.length+2,n=X.leftPad(n,e.payloadSize),{read:i,privateParams:{d:n}}}case $.publicKey.eddsaLegacy:{const e=new Sn(r.oid);let n=X.readMPI(t.subarray(i));return i+=n.length+2,n=X.leftPad(n,e.payloadSize),{read:i,privateParams:{seed:n}}}case $.publicKey.ed25519:{const e=t.subarray(i,i+32);return i+=e.length,{read:i,privateParams:{seed:e}}}case $.publicKey.x25519:{const e=t.subarray(i,i+32);return i+=e.length,{read:i,privateParams:{k:e}}}default:throw new bn("Unknown public key encryption algorithm.")}},parseEncSessionKeyParams:function(e,t){let r=0;switch(e){case $.publicKey.rsaEncrypt:case $.publicKey.rsaEncryptSign:return {c:X.readMPI(t.subarray(r))};case $.publicKey.elgamal:{const e=X.readMPI(t.subarray(r));r+=e.length+2;return {c1:e,c2:X.readMPI(t.subarray(r))}}case $.publicKey.ecdh:{const e=X.readMPI(t.subarray(r));r+=e.length+2;const i=new la;return i.read(t.subarray(r)),{V:e,C:i}}case $.publicKey.x25519:{const e=t.subarray(r,r+32);r+=e.length;const i=new ya;return i.read(t.subarray(r)),{ephemeralPublicKey:e,C:i}}default:throw new bn("Unknown public key encryption algorithm.")}},serializeParams:function(e,t){const r=new Set([$.publicKey.ed25519,$.publicKey.x25519]),i=Object.keys(t).map((i=>{const n=t[i];return X.isUint8Array(n)?r.has(e)?n:X.uint8ArrayToMPI(n):n.write()}));return X.concatUint8Array(i)},generateParams:function(e,t,r){switch(e){case $.publicKey.rsaEncrypt:case $.publicKey.rsaEncryptSign:case $.publicKey.rsaSign:return da.rsa.generate(t,65537).then((({n:e,e:t,d:r,p:i,q:n,u:a})=>({privateParams:{d:r,p:i,q:n,u:a},publicParams:{n:e,e:t}})));case $.publicKey.ecdsa:return da.elliptic.generate(r).then((({oid:e,Q:t,secret:r})=>({privateParams:{d:r},publicParams:{oid:new an(e),Q:t}})));case $.publicKey.eddsaLegacy:return da.elliptic.generate(r).then((({oid:e,Q:t,secret:r})=>({privateParams:{seed:r},publicParams:{oid:new an(e),Q:t}})));case $.publicKey.ecdh:return da.elliptic.generate(r).then((({oid:e,Q:t,secret:r,hash:i,cipher:n})=>({privateParams:{d:r},publicParams:{oid:new an(e),Q:t,kdfParams:new pa({hash:i,cipher:n})}})));case $.publicKey.ed25519:return da.elliptic.eddsa.generate(e).then((({A:e,seed:t})=>({privateParams:{seed:t},publicParams:{A:e}})));case $.publicKey.x25519:return da.elliptic.ecdhX.generate(e).then((({A:e,k:t})=>({privateParams:{k:t},publicParams:{A:e}})));case $.publicKey.dsa:case $.publicKey.elgamal:throw Error("Unsupported algorithm for key generation.");default:throw Error("Unknown public key algorithm.")}},validateParams:async function(e,t,r){if(!t||!r)throw Error("Missing key parameters");switch(e){case $.publicKey.rsaEncrypt:case $.publicKey.rsaEncryptSign:case $.publicKey.rsaSign:{const{n:e,e:i}=t,{d:n,p:a,q:s,u:o}=r;return da.rsa.validateParams(e,i,n,a,s,o)}case $.publicKey.dsa:{const{p:e,q:i,g:n,y:a}=t,{x:s}=r;return da.dsa.validateParams(e,i,n,a,s)}case $.publicKey.elgamal:{const{p:e,g:i,y:n}=t,{x:a}=r;return da.elgamal.validateParams(e,i,n,a)}case $.publicKey.ecdsa:case $.publicKey.ecdh:{const i=da.elliptic[$.read($.publicKey,e)],{oid:n,Q:a}=t,{d:s}=r;return i.validateParams(n,a,s)}case $.publicKey.eddsaLegacy:{const{Q:e,oid:i}=t,{seed:n}=r;return da.elliptic.eddsaLegacy.validateParams(i,e,n)}case $.publicKey.ed25519:{const{A:i}=t,{seed:n}=r;return da.elliptic.eddsa.validateParams(e,i,n)}case $.publicKey.x25519:{const{A:i}=t,{k:n}=r;return da.elliptic.ecdhX.validateParams(e,i,n)}default:throw Error("Unknown public key algorithm.")}},getPrefixRandom:async function(e){const{blockSize:t}=$r(e),r=await Oi(t),i=new Uint8Array([r[r.length-2],r[r.length-1]]);return X.concat([r,i])},generateSessionKey:function(e){const{keySize:t}=$r(e);return Oi(t)},getAEADMode:function(e){const t=$.read($.aead,e);return zi[t]},getCipher:$r,getPreferredCurveHashAlgo:function(e,t){switch(e){case $.publicKey.ecdsa:case $.publicKey.eddsaLegacy:return da.elliptic.getPreferredHashAlgo(t);case $.publicKey.ed25519:return da.elliptic.eddsa.getPreferredHashAlgo(e);default:throw Error("Unknown elliptic signing algo")}}});const ga={cipher:We,hash:Gr,mode:zi,publicKey:da,signature:fa,random:Ni,pkcs1:Xi,pkcs5:Zn,aesKW:Gn};Object.assign(ga,ma);var wa="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;function va(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)}const _a$2={arraySet:function(e,t,r,i,n){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+i),n);else for(let a=0;a<i;a++)e[n+a]=t[r+a];},flattenChunks:function(e){let t,r,i,n,a;for(i=0,t=0,r=e.length;t<r;t++)i+=e[t].length;const s=new Uint8Array(i);for(n=0,t=0,r=e.length;t<r;t++)a=e[t],s.set(a,n),n+=a.length;return s}},ka={arraySet:function(e,t,r,i,n){for(let a=0;a<i;a++)e[n+a]=t[r+a];},flattenChunks:function(e){return [].concat.apply([],e)}};let Aa=wa?Uint8Array:Array,Sa=wa?Uint16Array:Array,Ea=wa?Int32Array:Array,Pa=wa?_a$2.flattenChunks:ka.flattenChunks,xa=wa?_a$2.arraySet:ka.arraySet;const Ma=0,Ka=1,Ca=2,Da=3,Ua=4,Ra=5,Ia=6,Ba=0,Ta=1,za=2,qa=-2,Fa=-3,Oa=-5,La=-1,Na=1,ja=2,Ha=3,Wa=4,Ga=0,Va=1,$a=2,Za=8;function Xa(e){let t=e.length;for(;--t>=0;)e[t]=0;}const Ya=0,Qa=1,Ja=2,es=29,ts=256,rs=ts+1+es,is=30,ns=19,as=2*rs+1,ss=15,os=16,cs=7,us=256,hs=16,ds=17,fs=18,ls=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ps=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],ys=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],bs=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],ms=Array(2*(rs+2));Xa(ms);const gs=Array(2*is);Xa(gs);const ws=Array(512);Xa(ws);const vs=Array(256);Xa(vs);const _s=Array(es);Xa(_s);const ks=Array(is);function As(e,t,r,i,n){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=e&&e.length;}let Ss,Es,Ps;function xs(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t;}function Ms(e){return e<256?ws[e]:ws[256+(e>>>7)]}function Ks(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255;}function Cs(e,t,r){e.bi_valid>os-r?(e.bi_buf|=t<<e.bi_valid&65535,Ks(e,e.bi_buf),e.bi_buf=t>>os-e.bi_valid,e.bi_valid+=r-os):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r);}function Ds(e,t,r){Cs(e,r[2*t],r[2*t+1]);}function Us(e,t){let r=0;do{r|=1&e,e>>>=1,r<<=1;}while(--t>0);return r>>>1}function Rs(e,t,r){const i=Array(ss+1);let n,a,s=0;for(n=1;n<=ss;n++)i[n]=s=s+r[n-1]<<1;for(a=0;a<=t;a++){const t=e[2*a+1];0!==t&&(e[2*a]=Us(i[t]++,t));}}function Is(e){let t;for(t=0;t<rs;t++)e.dyn_ltree[2*t]=0;for(t=0;t<is;t++)e.dyn_dtree[2*t]=0;for(t=0;t<ns;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*us]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0;}function Bs(e){e.bi_valid>8?Ks(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0;}function Ts(e,t,r,i){const n=2*t,a=2*r;return e[n]<e[a]||e[n]===e[a]&&i[t]<=i[r]}function zs(e,t,r){const i=e.heap[r];let n=r<<1;for(;n<=e.heap_len&&(n<e.heap_len&&Ts(t,e.heap[n+1],e.heap[n],e.depth)&&n++,!Ts(t,i,e.heap[n],e.depth));)e.heap[r]=e.heap[n],r=n,n<<=1;e.heap[r]=i;}function qs(e,t,r){let i,n,a,s,o=0;if(0!==e.last_lit)do{i=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],n=e.pending_buf[e.l_buf+o],o++,0===i?Ds(e,n,t):(a=vs[n],Ds(e,a+ts+1,t),s=ls[a],0!==s&&(n-=_s[a],Cs(e,n,s)),i--,a=Ms(i),Ds(e,a,r),s=ps[a],0!==s&&(i-=ks[a],Cs(e,i,s)));}while(o<e.last_lit);Ds(e,us,t);}function Fs(e,t){const r=t.dyn_tree,i=t.stat_desc.static_tree,n=t.stat_desc.has_stree,a=t.stat_desc.elems;let s,o,c,u=-1;for(e.heap_len=0,e.heap_max=as,s=0;s<a;s++)0!==r[2*s]?(e.heap[++e.heap_len]=u=s,e.depth[s]=0):r[2*s+1]=0;for(;e.heap_len<2;)c=e.heap[++e.heap_len]=u<2?++u:0,r[2*c]=1,e.depth[c]=0,e.opt_len--,n&&(e.static_len-=i[2*c+1]);for(t.max_code=u,s=e.heap_len>>1;s>=1;s--)zs(e,r,s);c=a;do{s=e.heap[1],e.heap[1]=e.heap[e.heap_len--],zs(e,r,1),o=e.heap[1],e.heap[--e.heap_max]=s,e.heap[--e.heap_max]=o,r[2*c]=r[2*s]+r[2*o],e.depth[c]=(e.depth[s]>=e.depth[o]?e.depth[s]:e.depth[o])+1,r[2*s+1]=r[2*o+1]=c,e.heap[1]=c++,zs(e,r,1);}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],function(e,t){const r=t.dyn_tree,i=t.max_code,n=t.stat_desc.static_tree,a=t.stat_desc.has_stree,s=t.stat_desc.extra_bits,o=t.stat_desc.extra_base,c=t.stat_desc.max_length;let u,h,d,f,l,p,y=0;for(f=0;f<=ss;f++)e.bl_count[f]=0;for(r[2*e.heap[e.heap_max]+1]=0,u=e.heap_max+1;u<as;u++)h=e.heap[u],f=r[2*r[2*h+1]+1]+1,f>c&&(f=c,y++),r[2*h+1]=f,h>i||(e.bl_count[f]++,l=0,h>=o&&(l=s[h-o]),p=r[2*h],e.opt_len+=p*(f+l),a&&(e.static_len+=p*(n[2*h+1]+l)));if(0!==y){do{for(f=c-1;0===e.bl_count[f];)f--;e.bl_count[f]--,e.bl_count[f+1]+=2,e.bl_count[c]--,y-=2;}while(y>0);for(f=c;0!==f;f--)for(h=e.bl_count[f];0!==h;)d=e.heap[--u],d>i||(r[2*d+1]!==f&&(e.opt_len+=(f-r[2*d+1])*r[2*d],r[2*d+1]=f),h--);}}(e,t),Rs(r,u,e.bl_count);}function Os(e,t,r){let i,n,a=-1,s=t[1],o=0,c=7,u=4;for(0===s&&(c=138,u=3),t[2*(r+1)+1]=65535,i=0;i<=r;i++)n=s,s=t[2*(i+1)+1],++o<c&&n===s||(o<u?e.bl_tree[2*n]+=o:0!==n?(n!==a&&e.bl_tree[2*n]++,e.bl_tree[2*hs]++):o<=10?e.bl_tree[2*ds]++:e.bl_tree[2*fs]++,o=0,a=n,0===s?(c=138,u=3):n===s?(c=6,u=3):(c=7,u=4));}function Ls(e,t,r){let i,n,a=-1,s=t[1],o=0,c=7,u=4;for(0===s&&(c=138,u=3),i=0;i<=r;i++)if(n=s,s=t[2*(i+1)+1],!(++o<c&&n===s)){if(o<u)do{Ds(e,n,e.bl_tree);}while(0!=--o);else 0!==n?(n!==a&&(Ds(e,n,e.bl_tree),o--),Ds(e,hs,e.bl_tree),Cs(e,o-3,2)):o<=10?(Ds(e,ds,e.bl_tree),Cs(e,o-3,3)):(Ds(e,fs,e.bl_tree),Cs(e,o-11,7));o=0,a=n,0===s?(c=138,u=3):n===s?(c=6,u=3):(c=7,u=4);}}Xa(ks);let Ns=!1;function js(e){Ns||(!function(){let e,t,r,i,n;const a=Array(ss+1);for(r=0,i=0;i<es-1;i++)for(_s[i]=r,e=0;e<1<<ls[i];e++)vs[r++]=i;for(vs[r-1]=i,n=0,i=0;i<16;i++)for(ks[i]=n,e=0;e<1<<ps[i];e++)ws[n++]=i;for(n>>=7;i<is;i++)for(ks[i]=n<<7,e=0;e<1<<ps[i]-7;e++)ws[256+n++]=i;for(t=0;t<=ss;t++)a[t]=0;for(e=0;e<=143;)ms[2*e+1]=8,e++,a[8]++;for(;e<=255;)ms[2*e+1]=9,e++,a[9]++;for(;e<=279;)ms[2*e+1]=7,e++,a[7]++;for(;e<=287;)ms[2*e+1]=8,e++,a[8]++;for(Rs(ms,rs+1,a),e=0;e<is;e++)gs[2*e+1]=5,gs[2*e]=Us(e,5);Ss=new As(ms,ls,ts+1,rs,ss),Es=new As(gs,ps,0,is,ss),Ps=new As([],ys,0,ns,cs);}(),Ns=!0),e.l_desc=new xs(e.dyn_ltree,Ss),e.d_desc=new xs(e.dyn_dtree,Es),e.bl_desc=new xs(e.bl_tree,Ps),e.bi_buf=0,e.bi_valid=0,Is(e);}function Hs(e,t,r,i){Cs(e,(Ya<<1)+(i?1:0),3),function(e,t,r,i){Bs(e),i&&(Ks(e,r),Ks(e,~r)),xa(e.pending_buf,e.window,t,r,e.pending),e.pending+=r;}(e,t,r,!0);}function Ws(e){Cs(e,Qa<<1,3),Ds(e,us,ms),function(e){16===e.bi_valid?(Ks(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8);}(e);}function Gs(e,t,r,i){let n,a,s=0;e.level>0?(e.strm.data_type===$a&&(e.strm.data_type=function(e){let t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return Ga;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return Va;for(t=32;t<ts;t++)if(0!==e.dyn_ltree[2*t])return Va;return Ga}(e)),Fs(e,e.l_desc),Fs(e,e.d_desc),s=function(e){let t;for(Os(e,e.dyn_ltree,e.l_desc.max_code),Os(e,e.dyn_dtree,e.d_desc.max_code),Fs(e,e.bl_desc),t=ns-1;t>=3&&0===e.bl_tree[2*bs[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),n=e.opt_len+3+7>>>3,a=e.static_len+3+7>>>3,a<=n&&(n=a)):n=a=r+5,r+4<=n&&-1!==t?Hs(e,t,r,i):e.strategy===Wa||a===n?(Cs(e,(Qa<<1)+(i?1:0),3),qs(e,ms,gs)):(Cs(e,(Ja<<1)+(i?1:0),3),function(e,t,r,i){let n;for(Cs(e,t-257,5),Cs(e,r-1,5),Cs(e,i-4,4),n=0;n<i;n++)Cs(e,e.bl_tree[2*bs[n]+1],3);Ls(e,e.dyn_ltree,t-1),Ls(e,e.dyn_dtree,r-1);}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,s+1),qs(e,e.dyn_ltree,e.dyn_dtree)),Is(e),i&&Bs(e);}function Vs(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(vs[r]+ts+1)]++,e.dyn_dtree[2*Ms(t)]++),e.last_lit===e.lit_bufsize-1}function $s(e,t,r,i){let n=65535&e|0,a=e>>>16&65535|0,s=0;for(;0!==r;){s=r>2e3?2e3:r,r-=s;do{n=n+t[i++]|0,a=a+n|0;}while(--s);n%=65521,a%=65521;}return n|a<<16|0}const Zs=function(){let e;const t=[];for(let r=0;r<256;r++){e=r;for(let t=0;t<8;t++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();function Xs(e,t,r,i){const n=Zs,a=i+r;e^=-1;for(let r=i;r<a;r++)e=e>>>8^n[255&(e^t[r])];return -1^e}var Ys={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};const Qs=9,Js=3,eo=258,to=eo+Js+1,ro=32,io=42,no=69,ao=73,so=91,oo=103,co=113,uo=666,ho=1,fo=2,lo=3,po=4,yo=3;function bo(e,t){return e.msg=Ys[t],t}function mo(e){return (e<<1)-(e>4?9:0)}function go(e){let t=e.length;for(;--t>=0;)e[t]=0;}function wo(e){const t=e.state;let r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(xa(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0));}function vo(e,t){Gs(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,wo(e.strm);}function _o(e,t){e.pending_buf[e.pending++]=t;}function ko(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t;}function Ao(e,t,r,i){let n=e.avail_in;return n>i&&(n=i),0===n?0:(e.avail_in-=n,xa(t,e.input,e.next_in,n,r),1===e.state.wrap?e.adler=$s(e.adler,t,n,r):2===e.state.wrap&&(e.adler=Xs(e.adler,t,n,r)),e.next_in+=n,e.total_in+=n,n)}function So(e,t){let r,i,n=e.max_chain_length,a=e.strstart,s=e.prev_length,o=e.nice_match;const c=e.strstart>e.w_size-to?e.strstart-(e.w_size-to):0,u=e.window,h=e.w_mask,d=e.prev,f=e.strstart+eo;let l=u[a+s-1],p=u[a+s];e.prev_length>=e.good_match&&(n>>=2),o>e.lookahead&&(o=e.lookahead);do{if(r=t,u[r+s]===p&&u[r+s-1]===l&&u[r]===u[a]&&u[++r]===u[a+1]){a+=2,r++;do{}while(u[++a]===u[++r]&&u[++a]===u[++r]&&u[++a]===u[++r]&&u[++a]===u[++r]&&u[++a]===u[++r]&&u[++a]===u[++r]&&u[++a]===u[++r]&&u[++a]===u[++r]&&a<f);if(i=eo-(f-a),a=f-eo,i>s){if(e.match_start=t,s=i,i>=o)break;l=u[a+s-1],p=u[a+s];}}}while((t=d[t&h])>c&&0!=--n);return s<=e.lookahead?s:e.lookahead}function Eo(e){const t=e.w_size;let r,i,n,a,s;do{if(a=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-to)){xa(e.window,e.window,t,t,0),e.match_start-=t,e.strstart-=t,e.block_start-=t,i=e.hash_size,r=i;do{n=e.head[--r],e.head[r]=n>=t?n-t:0;}while(--i);i=t,r=i;do{n=e.prev[--r],e.prev[r]=n>=t?n-t:0;}while(--i);a+=t;}if(0===e.strm.avail_in)break;if(i=Ao(e.strm,e.window,e.strstart+e.lookahead,a),e.lookahead+=i,e.lookahead+e.insert>=Js)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+Js-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<Js)););}while(e.lookahead<to&&0!==e.strm.avail_in)}function Po(e,t){let r,i;for(;;){if(e.lookahead<to){if(Eo(e),e.lookahead<to&&t===Ma)return ho;if(0===e.lookahead)break}if(r=0,e.lookahead>=Js&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+Js-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-to&&(e.match_length=So(e,r)),e.match_length>=Js)if(i=Vs(e,e.strstart-e.match_start,e.match_length-Js),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=Js){e.match_length--;do{e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+Js-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart;}while(0!=--e.match_length);e.strstart++;}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else i=Vs(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(i&&(vo(e,!1),0===e.strm.avail_out))return ho}return e.insert=e.strstart<Js-1?e.strstart:Js-1,t===Ua?(vo(e,!0),0===e.strm.avail_out?lo:po):e.last_lit&&(vo(e,!1),0===e.strm.avail_out)?ho:fo}function xo(e,t){let r,i,n;for(;;){if(e.lookahead<to){if(Eo(e),e.lookahead<to&&t===Ma)return ho;if(0===e.lookahead)break}if(r=0,e.lookahead>=Js&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+Js-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=Js-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-to&&(e.match_length=So(e,r),e.match_length<=5&&(e.strategy===Na||e.match_length===Js&&e.strstart-e.match_start>4096)&&(e.match_length=Js-1)),e.prev_length>=Js&&e.match_length<=e.prev_length){n=e.strstart+e.lookahead-Js,i=Vs(e,e.strstart-1-e.prev_match,e.prev_length-Js),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=n&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+Js-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart);}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=Js-1,e.strstart++,i&&(vo(e,!1),0===e.strm.avail_out))return ho}else if(e.match_available){if(i=Vs(e,0,e.window[e.strstart-1]),i&&vo(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return ho}else e.match_available=1,e.strstart++,e.lookahead--;}return e.match_available&&(i=Vs(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<Js-1?e.strstart:Js-1,t===Ua?(vo(e,!0),0===e.strm.avail_out?lo:po):e.last_lit&&(vo(e,!1),0===e.strm.avail_out)?ho:fo}class Mo{constructor(e,t,r,i,n){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=i,this.func=n;}}const Ko=[new Mo(0,0,0,0,(function(e,t){let r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(Eo(e),0===e.lookahead&&t===Ma)return ho;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;const i=e.block_start+r;if((0===e.strstart||e.strstart>=i)&&(e.lookahead=e.strstart-i,e.strstart=i,vo(e,!1),0===e.strm.avail_out))return ho;if(e.strstart-e.block_start>=e.w_size-to&&(vo(e,!1),0===e.strm.avail_out))return ho}return e.insert=0,t===Ua?(vo(e,!0),0===e.strm.avail_out?lo:po):(e.strstart>e.block_start&&(vo(e,!1),e.strm.avail_out),ho)})),new Mo(4,4,8,4,Po),new Mo(4,5,16,8,Po),new Mo(4,6,32,32,Po),new Mo(4,4,16,16,xo),new Mo(8,16,32,32,xo),new Mo(8,16,128,128,xo),new Mo(8,32,128,256,xo),new Mo(32,128,258,1024,xo),new Mo(32,258,258,4096,xo)];class Co{constructor(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Za,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Sa(1146),this.dyn_dtree=new Sa(122),this.bl_tree=new Sa(78),go(this.dyn_ltree),go(this.dyn_dtree),go(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Sa(16),this.heap=new Sa(573),go(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Sa(573),go(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}}function Do(e){const t=function(e){let t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=$a,t=e.state,t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?io:co,e.adler=2===t.wrap?0:1,t.last_flush=Ma,js(t),Ba):bo(e,qa)}(e);return t===Ba&&function(e){e.window_size=2*e.w_size,go(e.head),e.max_lazy_match=Ko[e.level].max_lazy,e.good_match=Ko[e.level].good_length,e.nice_match=Ko[e.level].nice_length,e.max_chain_length=Ko[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=Js-1,e.match_available=0,e.ins_h=0;}(e.state),t}function Uo(e,t){let r,i,n,a;if(!e||!e.state||t>Ra||t<0)return e?bo(e,qa):qa;if(i=e.state,!e.output||!e.input&&0!==e.avail_in||i.status===uo&&t!==Ua)return bo(e,0===e.avail_out?Oa:qa);if(i.strm=e,r=i.last_flush,i.last_flush=t,i.status===io)if(2===i.wrap)e.adler=0,_o(i,31),_o(i,139),_o(i,8),i.gzhead?(_o(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),_o(i,255&i.gzhead.time),_o(i,i.gzhead.time>>8&255),_o(i,i.gzhead.time>>16&255),_o(i,i.gzhead.time>>24&255),_o(i,9===i.level?2:i.strategy>=ja||i.level<2?4:0),_o(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(_o(i,255&i.gzhead.extra.length),_o(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(e.adler=Xs(e.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=no):(_o(i,0),_o(i,0),_o(i,0),_o(i,0),_o(i,0),_o(i,9===i.level?2:i.strategy>=ja||i.level<2?4:0),_o(i,yo),i.status=co);else {let t=Za+(i.w_bits-8<<4)<<8,r=-1;r=i.strategy>=ja||i.level<2?0:i.level<6?1:6===i.level?2:3,t|=r<<6,0!==i.strstart&&(t|=ro),t+=31-t%31,i.status=co,ko(i,t),0!==i.strstart&&(ko(i,e.adler>>>16),ko(i,65535&e.adler)),e.adler=1;}if(i.status===no)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(e.adler=Xs(e.adler,i.pending_buf,i.pending-n,n)),wo(e),n=i.pending,i.pending!==i.pending_buf_size));)_o(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(e.adler=Xs(e.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=ao);}else i.status=ao;if(i.status===ao)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(e.adler=Xs(e.adler,i.pending_buf,i.pending-n,n)),wo(e),n=i.pending,i.pending===i.pending_buf_size)){a=1;break}a=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,_o(i,a);}while(0!==a);i.gzhead.hcrc&&i.pending>n&&(e.adler=Xs(e.adler,i.pending_buf,i.pending-n,n)),0===a&&(i.gzindex=0,i.status=so);}else i.status=so;if(i.status===so)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(e.adler=Xs(e.adler,i.pending_buf,i.pending-n,n)),wo(e),n=i.pending,i.pending===i.pending_buf_size)){a=1;break}a=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,_o(i,a);}while(0!==a);i.gzhead.hcrc&&i.pending>n&&(e.adler=Xs(e.adler,i.pending_buf,i.pending-n,n)),0===a&&(i.status=oo);}else i.status=oo;if(i.status===oo&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&wo(e),i.pending+2<=i.pending_buf_size&&(_o(i,255&e.adler),_o(i,e.adler>>8&255),e.adler=0,i.status=co)):i.status=co),0!==i.pending){if(wo(e),0===e.avail_out)return i.last_flush=-1,Ba}else if(0===e.avail_in&&mo(t)<=mo(r)&&t!==Ua)return bo(e,Oa);if(i.status===uo&&0!==e.avail_in)return bo(e,Oa);if(0!==e.avail_in||0!==i.lookahead||t!==Ma&&i.status!==uo){var s=i.strategy===ja?function(e,t){let r;for(;;){if(0===e.lookahead&&(Eo(e),0===e.lookahead)){if(t===Ma)return ho;break}if(e.match_length=0,r=Vs(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(vo(e,!1),0===e.strm.avail_out))return ho}return e.insert=0,t===Ua?(vo(e,!0),0===e.strm.avail_out?lo:po):e.last_lit&&(vo(e,!1),0===e.strm.avail_out)?ho:fo}(i,t):i.strategy===Ha?function(e,t){let r,i,n,a;const s=e.window;for(;;){if(e.lookahead<=eo){if(Eo(e),e.lookahead<=eo&&t===Ma)return ho;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=Js&&e.strstart>0&&(n=e.strstart-1,i=s[n],i===s[++n]&&i===s[++n]&&i===s[++n])){a=e.strstart+eo;do{}while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<a);e.match_length=eo-(a-n),e.match_length>e.lookahead&&(e.match_length=e.lookahead);}if(e.match_length>=Js?(r=Vs(e,1,e.match_length-Js),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=Vs(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(vo(e,!1),0===e.strm.avail_out))return ho}return e.insert=0,t===Ua?(vo(e,!0),0===e.strm.avail_out?lo:po):e.last_lit&&(vo(e,!1),0===e.strm.avail_out)?ho:fo}(i,t):Ko[i.level].func(i,t);if(s!==lo&&s!==po||(i.status=uo),s===ho||s===lo)return 0===e.avail_out&&(i.last_flush=-1),Ba;if(s===fo&&(t===Ka?Ws(i):t!==Ra&&(Hs(i,0,0,!1),t===Da&&(go(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),wo(e),0===e.avail_out))return i.last_flush=-1,Ba}return t!==Ua?Ba:i.wrap<=0?Ta:(2===i.wrap?(_o(i,255&e.adler),_o(i,e.adler>>8&255),_o(i,e.adler>>16&255),_o(i,e.adler>>24&255),_o(i,255&e.total_in),_o(i,e.total_in>>8&255),_o(i,e.total_in>>16&255),_o(i,e.total_in>>24&255)):(ko(i,e.adler>>>16),ko(i,65535&e.adler)),wo(e),i.wrap>0&&(i.wrap=-i.wrap),0!==i.pending?Ba:Ta)}try{String.fromCharCode.call(null,0);}catch(e){}try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(e){}const Ro=new Aa(256);for(let e=0;e<256;e++)Ro[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;function Io(e){let t,r,i,n,a=0;const s=e.length;for(i=0;i<s;i++)t=e.charCodeAt(i),55296==(64512&t)&&i+1<s&&(r=e.charCodeAt(i+1),56320==(64512&r)&&(t=65536+(t-55296<<10)+(r-56320),i++)),a+=t<128?1:t<2048?2:t<65536?3:4;const o=new Aa(a);for(n=0,i=0;n<a;i++)t=e.charCodeAt(i),55296==(64512&t)&&i+1<s&&(r=e.charCodeAt(i+1),56320==(64512&r)&&(t=65536+(t-55296<<10)+(r-56320),i++)),t<128?o[n++]=t:t<2048?(o[n++]=192|t>>>6,o[n++]=128|63&t):t<65536?(o[n++]=224|t>>>12,o[n++]=128|t>>>6&63,o[n++]=128|63&t):(o[n++]=240|t>>>18,o[n++]=128|t>>>12&63,o[n++]=128|t>>>6&63,o[n++]=128|63&t);return o}Ro[254]=Ro[254]=1;class Bo{constructor(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;}}class To{constructor(e){this.options={level:La,method:Za,chunkSize:16384,windowBits:15,memLevel:8,strategy:0,...e||{}};const t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Bo,this.strm.avail_out=0;var r,i,n=function(e,t,r,i,n,a){if(!e)return qa;let s=1;if(t===La&&(t=6),i<0?(s=0,i=-i):i>15&&(s=2,i-=16),n<1||n>Qs||r!==Za||i<8||i>15||t<0||t>9||a<0||a>Wa)return bo(e,qa);8===i&&(i=9);const o=new Co;return e.state=o,o.strm=e,o.wrap=s,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+Js-1)/Js),o.window=new Aa(2*o.w_size),o.head=new Sa(o.hash_size),o.prev=new Sa(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Aa(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=a,o.method=r,Do(e)}(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(n!==Ba)throw Error(Ys[n]);if(t.header&&(r=this.strm,i=t.header,r&&r.state&&(2!==r.state.wrap||(r.state.gzhead=i))),t.dictionary){let e;if(e="string"==typeof t.dictionary?Io(t.dictionary):t.dictionary instanceof ArrayBuffer?new Uint8Array(t.dictionary):t.dictionary,n=function(e,t){let r,i,n,a,s,o,c,u,h=t.length;if(!e||!e.state)return qa;if(r=e.state,a=r.wrap,2===a||1===a&&r.status!==io||r.lookahead)return qa;for(1===a&&(e.adler=$s(e.adler,t,h,0)),r.wrap=0,h>=r.w_size&&(0===a&&(go(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new Aa(r.w_size),xa(u,t,h-r.w_size,r.w_size,0),t=u,h=r.w_size),s=e.avail_in,o=e.next_in,c=e.input,e.avail_in=h,e.next_in=0,e.input=t,Eo(r);r.lookahead>=Js;){i=r.strstart,n=r.lookahead-(Js-1);do{r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+Js-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++;}while(--n);r.strstart=i,r.lookahead=Js-1,Eo(r);}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=Js-1,r.match_available=0,e.next_in=o,e.input=c,e.avail_in=s,r.wrap=a,Ba}(this.strm,e),n!==Ba)throw Error(Ys[n]);this._dict_set=!0;}}push(e,t){const{strm:r,options:{chunkSize:i}}=this;var n,a;if(this.ended)return !1;a=t===~~t?t:!0===t?Ua:Ma,"string"==typeof e?r.input=Io(e):e instanceof ArrayBuffer?r.input=new Uint8Array(e):r.input=e,r.next_in=0,r.avail_in=r.input.length;do{if(0===r.avail_out&&(r.output=new Aa(i),r.next_out=0,r.avail_out=i),(n=Uo(r,a))!==Ta&&n!==Ba)return this.onEnd(n),this.ended=!0,!1;0!==r.avail_out&&(0!==r.avail_in||a!==Ua&&a!==Ca)||this.onData(va(r.output,r.next_out));}while((r.avail_in>0||0===r.avail_out)&&n!==Ta);return a===Ua?(n=function(e){let t;return e&&e.state?(t=e.state.status,t!==io&&t!==no&&t!==ao&&t!==so&&t!==oo&&t!==co&&t!==uo?bo(e,qa):(e.state=null,t===co?bo(e,Fa):Ba)):qa}(this.strm),this.onEnd(n),this.ended=!0,n===Ba):a!==Ca||(this.onEnd(Ba),r.avail_out=0,!0)}onData(e){this.chunks.push(e);}onEnd(e){e===Ba&&(this.result=Pa(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;}}const zo=30,qo=12;function Fo(e,t){let r,i,n,a,s,o,c,u,h,d;const f=e.state;r=e.next_in;const l=e.input,p=r+(e.avail_in-5);i=e.next_out;const y=e.output,b=i-(t-e.avail_out),m=i+(e.avail_out-257),g=f.dmax,w=f.wsize,v=f.whave,_=f.wnext,k=f.window;n=f.hold,a=f.bits;const A=f.lencode,S=f.distcode,E=(1<<f.lenbits)-1,P=(1<<f.distbits)-1;e:do{a<15&&(n+=l[r++]<<a,a+=8,n+=l[r++]<<a,a+=8),s=A[n&E];t:for(;;){if(o=s>>>24,n>>>=o,a-=o,o=s>>>16&255,0===o)y[i++]=65535&s;else {if(!(16&o)){if(0==(64&o)){s=A[(65535&s)+(n&(1<<o)-1)];continue t}if(32&o){f.mode=qo;break e}e.msg="invalid literal/length code",f.mode=zo;break e}c=65535&s,o&=15,o&&(a<o&&(n+=l[r++]<<a,a+=8),c+=n&(1<<o)-1,n>>>=o,a-=o),a<15&&(n+=l[r++]<<a,a+=8,n+=l[r++]<<a,a+=8),s=S[n&P];r:for(;;){if(o=s>>>24,n>>>=o,a-=o,o=s>>>16&255,!(16&o)){if(0==(64&o)){s=S[(65535&s)+(n&(1<<o)-1)];continue r}e.msg="invalid distance code",f.mode=zo;break e}if(u=65535&s,o&=15,a<o&&(n+=l[r++]<<a,a+=8,a<o&&(n+=l[r++]<<a,a+=8)),u+=n&(1<<o)-1,u>g){e.msg="invalid distance too far back",f.mode=zo;break e}if(n>>>=o,a-=o,o=i-b,u>o){if(o=u-o,o>v&&f.sane){e.msg="invalid distance too far back",f.mode=zo;break e}if(h=0,d=k,0===_){if(h+=w-o,o<c){c-=o;do{y[i++]=k[h++];}while(--o);h=i-u,d=y;}}else if(_<o){if(h+=w+_-o,o-=_,o<c){c-=o;do{y[i++]=k[h++];}while(--o);if(h=0,_<c){o=_,c-=o;do{y[i++]=k[h++];}while(--o);h=i-u,d=y;}}}else if(h+=_-o,o<c){c-=o;do{y[i++]=k[h++];}while(--o);h=i-u,d=y;}for(;c>2;)y[i++]=d[h++],y[i++]=d[h++],y[i++]=d[h++],c-=3;c&&(y[i++]=d[h++],c>1&&(y[i++]=d[h++]));}else {h=i-u;do{y[i++]=y[h++],y[i++]=y[h++],y[i++]=y[h++],c-=3;}while(c>2);c&&(y[i++]=y[h++],c>1&&(y[i++]=y[h++]));}break}}break}}while(r<p&&i<m);c=a>>3,r-=c,a-=c<<3,n&=(1<<a)-1,e.next_in=r,e.next_out=i,e.avail_in=r<p?p-r+5:5-(r-p),e.avail_out=i<m?m-i+257:257-(i-m),f.hold=n,f.bits=a;}const Oo=15,Lo=852,No=592,jo=0,Ho=1,Wo=2,Go=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],Vo=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],$o=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],Zo=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];function Xo(e,t,r,i,n,a,s,o){const c=o.bits;let u,h,d,f,l,p=0,y=0,b=0,m=0,g=0,w=0,v=0,_=0,k=0,A=0,S=null,E=0;const P=new Sa(Oo+1),x=new Sa(Oo+1);let M,K,C,D=null,U=0;for(p=0;p<=Oo;p++)P[p]=0;for(y=0;y<i;y++)P[t[r+y]]++;for(g=c,m=Oo;m>=1&&0===P[m];m--);if(g>m&&(g=m),0===m)return n[a++]=20971520,n[a++]=20971520,o.bits=1,0;for(b=1;b<m&&0===P[b];b++);for(g<b&&(g=b),_=1,p=1;p<=Oo;p++)if(_<<=1,_-=P[p],_<0)return -1;if(_>0&&(e===jo||1!==m))return -1;for(x[1]=0,p=1;p<Oo;p++)x[p+1]=x[p]+P[p];for(y=0;y<i;y++)0!==t[r+y]&&(s[x[t[r+y]]++]=y);e===jo?(S=D=s,l=19):e===Ho?(S=Go,E-=257,D=Vo,U-=257,l=256):(S=$o,D=Zo,l=-1),A=0,y=0,p=b,f=a,w=g,v=0,d=-1,k=1<<g;const R=k-1;if(e===Ho&&k>Lo||e===Wo&&k>No)return 1;for(;;){M=p-v,s[y]<l?(K=0,C=s[y]):s[y]>l?(K=D[U+s[y]],C=S[E+s[y]]):(K=96,C=0),u=1<<p-v,h=1<<w,b=h;do{h-=u,n[f+(A>>v)+h]=M<<24|K<<16|C|0;}while(0!==h);for(u=1<<p-1;A&u;)u>>=1;if(0!==u?(A&=u-1,A+=u):A=0,y++,0==--P[p]){if(p===m)break;p=t[r+s[y]];}if(p>g&&(A&R)!==d){for(0===v&&(v=g),f+=b,w=p-v,_=1<<w;w+v<m&&(_-=P[w+v],!(_<=0));)w++,_<<=1;if(k+=1<<w,e===Ho&&k>Lo||e===Wo&&k>No)return 1;d=A&R,n[d]=g<<24|w<<16|f-a|0;}}return 0!==A&&(n[f+A]=p-v<<24|64<<16|0),o.bits=g,0}const Yo=0,Qo=1,Jo=2,ec=1,tc=2,rc=3,ic=4,nc=5,ac=6,sc=7,oc=8,cc=9,uc=10,hc=11,dc=12,fc=13,lc=14,pc=15,yc=16,bc=17,mc=18,gc=19,wc=20,vc=21,_c=22,kc=23,Ac=24,Sc=25,Ec=26,Pc=27,xc=28,Mc=29,Kc=30,Cc=852,Dc=592;function Uc(e){return (e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}class Rc{constructor(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Sa(320),this.work=new Sa(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}}function Ic(e){let t;return e&&e.state?(t=e.state,t.wsize=0,t.whave=0,t.wnext=0,function(e){let t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=ec,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Ea(Cc),t.distcode=t.distdyn=new Ea(Dc),t.sane=1,t.back=-1,Ba):qa}(e)):qa}function Bc(e,t){let r,i;return e?(i=new Rc,e.state=i,i.window=null,r=function(e,t){let r,i;return e&&e.state?(i=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?qa:(null!==i.window&&i.wbits!==t&&(i.window=null),i.wrap=r,i.wbits=t,Ic(e))):qa}(e,t),r!==Ba&&(e.state=null),r):qa}let Tc,zc,qc=!0;function Fc(e){if(qc){let t;for(Tc=new Ea(512),zc=new Ea(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(Xo(Qo,e.lens,0,288,Tc,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;Xo(Jo,e.lens,0,32,zc,0,e.work,{bits:5}),qc=!1;}e.lencode=Tc,e.lenbits=9,e.distcode=zc,e.distbits=5;}function Oc(e,t,r,i){let n;const a=e.state;return null===a.window&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Aa(a.wsize)),i>=a.wsize?(xa(a.window,t,r-a.wsize,a.wsize,0),a.wnext=0,a.whave=a.wsize):(n=a.wsize-a.wnext,n>i&&(n=i),xa(a.window,t,r-i,n,a.wnext),(i-=n)?(xa(a.window,t,r-i,i,0),a.wnext=i,a.whave=a.wsize):(a.wnext+=n,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=n))),0}function Lc(e,t){let r,i,n,a,s,o,c,u,h,d,f,l,p,y,b,m,g,w,v,_,k,A,S,E,P=0,x=new Aa(4);const M=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return qa;r=e.state,r.mode===dc&&(r.mode=fc),s=e.next_out,n=e.output,c=e.avail_out,a=e.next_in,i=e.input,o=e.avail_in,u=r.hold,h=r.bits,d=o,f=c,A=Ba;e:for(;;)switch(r.mode){case ec:if(0===r.wrap){r.mode=fc;break}for(;h<16;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(2&r.wrap&&35615===u){r.check=0,x[0]=255&u,x[1]=u>>>8&255,r.check=Xs(r.check,x,2,0),u=0,h=0,r.mode=tc;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){e.msg="incorrect header check",r.mode=Kc;break}if((15&u)!==Za){e.msg="unknown compression method",r.mode=Kc;break}if(u>>>=4,h-=4,k=8+(15&u),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=Kc;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&u?uc:dc,u=0,h=0;break;case tc:for(;h<16;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(r.flags=u,(255&r.flags)!==Za){e.msg="unknown compression method",r.mode=Kc;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=Kc;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(x[0]=255&u,x[1]=u>>>8&255,r.check=Xs(r.check,x,2,0)),u=0,h=0,r.mode=rc;case rc:for(;h<32;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}r.head&&(r.head.time=u),512&r.flags&&(x[0]=255&u,x[1]=u>>>8&255,x[2]=u>>>16&255,x[3]=u>>>24&255,r.check=Xs(r.check,x,4,0)),u=0,h=0,r.mode=ic;case ic:for(;h<16;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(x[0]=255&u,x[1]=u>>>8&255,r.check=Xs(r.check,x,2,0)),u=0,h=0,r.mode=nc;case nc:if(1024&r.flags){for(;h<16;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(x[0]=255&u,x[1]=u>>>8&255,r.check=Xs(r.check,x,2,0)),u=0,h=0;}else r.head&&(r.head.extra=null);r.mode=ac;case ac:if(1024&r.flags&&(l=r.length,l>o&&(l=o),l&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=Array(r.head.extra_len)),xa(r.head.extra,i,a,l,k)),512&r.flags&&(r.check=Xs(r.check,i,l,a)),o-=l,a+=l,r.length-=l),r.length))break e;r.length=0,r.mode=sc;case sc:if(2048&r.flags){if(0===o)break e;l=0;do{k=i[a+l++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k));}while(k&&l<o);if(512&r.flags&&(r.check=Xs(r.check,i,l,a)),o-=l,a+=l,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=oc;case oc:if(4096&r.flags){if(0===o)break e;l=0;do{k=i[a+l++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k));}while(k&&l<o);if(512&r.flags&&(r.check=Xs(r.check,i,l,a)),o-=l,a+=l,k)break e}else r.head&&(r.head.comment=null);r.mode=cc;case cc:if(512&r.flags){for(;h<16;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(u!==(65535&r.check)){e.msg="header crc mismatch",r.mode=Kc;break}u=0,h=0;}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=dc;break;case uc:for(;h<32;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}e.adler=r.check=Uc(u),u=0,h=0,r.mode=hc;case hc:if(0===r.havedict)return e.next_out=s,e.avail_out=c,e.next_in=a,e.avail_in=o,r.hold=u,r.bits=h,za;e.adler=r.check=1,r.mode=dc;case dc:if(t===Ra||t===Ia)break e;case fc:if(r.last){u>>>=7&h,h-=7&h,r.mode=Pc;break}for(;h<3;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}switch(r.last=1&u,u>>>=1,h-=1,3&u){case 0:r.mode=lc;break;case 1:if(Fc(r),r.mode=wc,t===Ia){u>>>=2,h-=2;break e}break;case 2:r.mode=bc;break;case 3:e.msg="invalid block type",r.mode=Kc;}u>>>=2,h-=2;break;case lc:for(u>>>=7&h,h-=7&h;h<32;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if((65535&u)!=(u>>>16^65535)){e.msg="invalid stored block lengths",r.mode=Kc;break}if(r.length=65535&u,u=0,h=0,r.mode=pc,t===Ia)break e;case pc:r.mode=yc;case yc:if(l=r.length,l){if(l>o&&(l=o),l>c&&(l=c),0===l)break e;xa(n,i,a,l,s),o-=l,a+=l,c-=l,s+=l,r.length-=l;break}r.mode=dc;break;case bc:for(;h<14;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(r.nlen=257+(31&u),u>>>=5,h-=5,r.ndist=1+(31&u),u>>>=5,h-=5,r.ncode=4+(15&u),u>>>=4,h-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=Kc;break}r.have=0,r.mode=mc;case mc:for(;r.have<r.ncode;){for(;h<3;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}r.lens[M[r.have++]]=7&u,u>>>=3,h-=3;}for(;r.have<19;)r.lens[M[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},A=Xo(Yo,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,A){e.msg="invalid code lengths set",r.mode=Kc;break}r.have=0,r.mode=gc;case gc:for(;r.have<r.nlen+r.ndist;){for(;P=r.lencode[u&(1<<r.lenbits)-1],b=P>>>24,m=P>>>16&255,g=65535&P,!(b<=h);){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(g<16)u>>>=b,h-=b,r.lens[r.have++]=g;else {if(16===g){for(E=b+2;h<E;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(u>>>=b,h-=b,0===r.have){e.msg="invalid bit length repeat",r.mode=Kc;break}k=r.lens[r.have-1],l=3+(3&u),u>>>=2,h-=2;}else if(17===g){for(E=b+3;h<E;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}u>>>=b,h-=b,k=0,l=3+(7&u),u>>>=3,h-=3;}else {for(E=b+7;h<E;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}u>>>=b,h-=b,k=0,l=11+(127&u),u>>>=7,h-=7;}if(r.have+l>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=Kc;break}for(;l--;)r.lens[r.have++]=k;}}if(r.mode===Kc)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=Kc;break}if(r.lenbits=9,S={bits:r.lenbits},A=Xo(Qo,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,A){e.msg="invalid literal/lengths set",r.mode=Kc;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},A=Xo(Jo,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,A){e.msg="invalid distances set",r.mode=Kc;break}if(r.mode=wc,t===Ia)break e;case wc:r.mode=vc;case vc:if(o>=6&&c>=258){e.next_out=s,e.avail_out=c,e.next_in=a,e.avail_in=o,r.hold=u,r.bits=h,Fo(e,f),s=e.next_out,n=e.output,c=e.avail_out,a=e.next_in,i=e.input,o=e.avail_in,u=r.hold,h=r.bits,r.mode===dc&&(r.back=-1);break}for(r.back=0;P=r.lencode[u&(1<<r.lenbits)-1],b=P>>>24,m=P>>>16&255,g=65535&P,!(b<=h);){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(m&&0==(240&m)){for(w=b,v=m,_=g;P=r.lencode[_+((u&(1<<w+v)-1)>>w)],b=P>>>24,m=P>>>16&255,g=65535&P,!(w+b<=h);){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}u>>>=w,h-=w,r.back+=w;}if(u>>>=b,h-=b,r.back+=b,r.length=g,0===m){r.mode=Ec;break}if(32&m){r.back=-1,r.mode=dc;break}if(64&m){e.msg="invalid literal/length code",r.mode=Kc;break}r.extra=15&m,r.mode=_c;case _c:if(r.extra){for(E=r.extra;h<E;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,h-=r.extra,r.back+=r.extra;}r.was=r.length,r.mode=kc;case kc:for(;P=r.distcode[u&(1<<r.distbits)-1],b=P>>>24,m=P>>>16&255,g=65535&P,!(b<=h);){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(0==(240&m)){for(w=b,v=m,_=g;P=r.distcode[_+((u&(1<<w+v)-1)>>w)],b=P>>>24,m=P>>>16&255,g=65535&P,!(w+b<=h);){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}u>>>=w,h-=w,r.back+=w;}if(u>>>=b,h-=b,r.back+=b,64&m){e.msg="invalid distance code",r.mode=Kc;break}r.offset=g,r.extra=15&m,r.mode=Ac;case Ac:if(r.extra){for(E=r.extra;h<E;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,h-=r.extra,r.back+=r.extra;}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=Kc;break}r.mode=Sc;case Sc:if(0===c)break e;if(l=f-c,r.offset>l){if(l=r.offset-l,l>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=Kc;break}l>r.wnext?(l-=r.wnext,p=r.wsize-l):p=r.wnext-l,l>r.length&&(l=r.length),y=r.window;}else y=n,p=s-r.offset,l=r.length;l>c&&(l=c),c-=l,r.length-=l;do{n[s++]=y[p++];}while(--l);0===r.length&&(r.mode=vc);break;case Ec:if(0===c)break e;n[s++]=r.length,c--,r.mode=vc;break;case Pc:if(r.wrap){for(;h<32;){if(0===o)break e;o--,u|=i[a++]<<h,h+=8;}if(f-=c,e.total_out+=f,r.total+=f,f&&(e.adler=r.check=r.flags?Xs(r.check,n,f,s-f):$s(r.check,n,f,s-f)),f=c,(r.flags?u:Uc(u))!==r.check){e.msg="incorrect data check",r.mode=Kc;break}u=0,h=0;}r.mode=xc;case xc:if(r.wrap&&r.flags){for(;h<32;){if(0===o)break e;o--,u+=i[a++]<<h,h+=8;}if(u!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=Kc;break}u=0,h=0;}r.mode=Mc;case Mc:A=Ta;break e;case Kc:A=Fa;break e;default:return qa}return e.next_out=s,e.avail_out=c,e.next_in=a,e.avail_in=o,r.hold=u,r.bits=h,(r.wsize||f!==e.avail_out&&r.mode<Kc&&(r.mode<Pc||t!==Ua))&&Oc(e,e.output,e.next_out,f-e.avail_out),d-=e.avail_in,f-=e.avail_out,e.total_in+=d,e.total_out+=f,r.total+=f,r.wrap&&f&&(e.adler=r.check=r.flags?Xs(r.check,n,f,e.next_out-f):$s(r.check,n,f,e.next_out-f)),e.data_type=r.bits+(r.last?64:0)+(r.mode===dc?128:0)+(r.mode===wc||r.mode===pc?256:0),(0===d&&0===f||t===Ua)&&A===Ba&&(A=Oa),A}function Nc(e,t){const r=t.length;let i,n;return e&&e.state?(i=e.state,0!==i.wrap&&i.mode!==hc?qa:i.mode===hc&&(n=1,n=$s(n,t,r,0),n!==i.check)?Fa:(Oc(e,t,r,r),i.havedict=1,Ba)):qa}class jc{constructor(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;}}class Hc{constructor(e){this.options={chunkSize:16384,windowBits:0,...e||{}};const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Bo,this.strm.avail_out=0;let r=Bc(this.strm,t.windowBits);if(r!==Ba)throw Error(Ys[r]);if(this.header=new jc,function(e,t){let r;e&&e.state&&(r=e.state,0==(2&r.wrap)||(r.head=t,t.done=!1));}(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=Io(t.dictionary):t.dictionary instanceof ArrayBuffer&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=Nc(this.strm,t.dictionary),r!==Ba)))throw Error(Ys[r])}push(e,t){const{strm:r,options:{chunkSize:i,dictionary:n}}=this;let a,s,o=!1;if(this.ended)return !1;s=t===~~t?t:!0===t?Ua:Ma,"string"==typeof e?r.input=function(e){const t=new Aa(e.length);for(let r=0,i=t.length;r<i;r++)t[r]=e.charCodeAt(r);return t}(e):e instanceof ArrayBuffer?r.input=new Uint8Array(e):r.input=e,r.next_in=0,r.avail_in=r.input.length;do{if(0===r.avail_out&&(r.output=new Aa(i),r.next_out=0,r.avail_out=i),a=Lc(r,Ma),a===za&&n&&(a=Nc(this.strm,n)),a===Oa&&!0===o&&(a=Ba,o=!1),a!==Ta&&a!==Ba)return this.onEnd(a),this.ended=!0,!1;r.next_out&&(0!==r.avail_out&&a!==Ta&&(0!==r.avail_in||s!==Ua&&s!==Ca)||this.onData(va(r.output,r.next_out))),0===r.avail_in&&0===r.avail_out&&(o=!0);}while((r.avail_in>0||0===r.avail_out)&&a!==Ta);return a===Ta&&(s=Ua),s===Ua?(a=function(e){if(!e||!e.state)return qa;const t=e.state;return t.window&&(t.window=null),e.state=null,Ba}(this.strm),this.onEnd(a),this.ended=!0,a===Ba):s!==Ca||(this.onEnd(Ba),r.avail_out=0,!0)}onData(e){this.chunks.push(e);}onEnd(e){e===Ba&&(this.result=Pa(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;}}var Wc=[0,1,3,7,15,31,63,127,255],Gc=function(e){this.stream=e,this.bitOffset=0,this.curByte=0,this.hasByte=!1;};Gc.prototype._ensureByte=function(){this.hasByte||(this.curByte=this.stream.readByte(),this.hasByte=!0);},Gc.prototype.read=function(e){for(var t=0;e>0;){this._ensureByte();var r=8-this.bitOffset;if(e>=r)t<<=r,t|=Wc[r]&this.curByte,this.hasByte=!1,this.bitOffset=0,e-=r;else {t<<=e;var i=r-e;t|=(this.curByte&Wc[e]<<i)>>i,this.bitOffset+=e,e=0;}}return t},Gc.prototype.seek=function(e){var t=e%8,r=(e-t)/8;this.bitOffset=t,this.stream.seek(r),this.hasByte=!1;},Gc.prototype.pi=function(){var e,t=new Uint8Array(6);for(e=0;e<t.length;e++)t[e]=this.read(8);return function(e){return Array.prototype.map.call(e,(e=>("00"+e.toString(16)).slice(-2))).join("")}(t)};var Vc=Gc,$c=function(){};$c.prototype.readByte=function(){throw Error("abstract method readByte() not implemented")},$c.prototype.read=function(e,t,r){for(var i=0;i<r;){var n=this.readByte();if(n<0)return 0===i?-1:i;e[t++]=n,i++;}return i},$c.prototype.seek=function(e){throw Error("abstract method seek() not implemented")},$c.prototype.writeByte=function(e){throw Error("abstract method readByte() not implemented")},$c.prototype.write=function(e,t,r){var i;for(i=0;i<r;i++)this.writeByte(e[t++]);return r},$c.prototype.flush=function(){};var Zc,Xc=$c,Yc=(Zc=new Uint32Array([0,79764919,159529838,222504665,319059676,398814059,445009330,507990021,638119352,583659535,797628118,726387553,890018660,835552979,1015980042,944750013,1276238704,1221641927,1167319070,1095957929,1595256236,1540665371,1452775106,1381403509,1780037320,1859660671,1671105958,1733955601,2031960084,2111593891,1889500026,1952343757,2552477408,2632100695,2443283854,2506133561,2334638140,2414271883,2191915858,2254759653,3190512472,3135915759,3081330742,3009969537,2905550212,2850959411,2762807018,2691435357,3560074640,3505614887,3719321342,3648080713,3342211916,3287746299,3467911202,3396681109,4063920168,4143685023,4223187782,4286162673,3779000052,3858754371,3904687514,3967668269,881225847,809987520,1023691545,969234094,662832811,591600412,771767749,717299826,311336399,374308984,453813921,533576470,25881363,88864420,134795389,214552010,2023205639,2086057648,1897238633,1976864222,1804852699,1867694188,1645340341,1724971778,1587496639,1516133128,1461550545,1406951526,1302016099,1230646740,1142491917,1087903418,2896545431,2825181984,2770861561,2716262478,3215044683,3143675388,3055782693,3001194130,2326604591,2389456536,2200899649,2280525302,2578013683,2640855108,2418763421,2498394922,3769900519,3832873040,3912640137,3992402750,4088425275,4151408268,4197601365,4277358050,3334271071,3263032808,3476998961,3422541446,3585640067,3514407732,3694837229,3640369242,1762451694,1842216281,1619975040,1682949687,2047383090,2127137669,1938468188,2001449195,1325665622,1271206113,1183200824,1111960463,1543535498,1489069629,1434599652,1363369299,622672798,568075817,748617968,677256519,907627842,853037301,1067152940,995781531,51762726,131386257,177728840,240578815,269590778,349224269,429104020,491947555,4046411278,4126034873,4172115296,4234965207,3794477266,3874110821,3953728444,4016571915,3609705398,3555108353,3735388376,3664026991,3290680682,3236090077,3449943556,3378572211,3174993278,3120533705,3032266256,2961025959,2923101090,2868635157,2813903052,2742672763,2604032198,2683796849,2461293480,2524268063,2284983834,2364738477,2175806836,2238787779,1569362073,1498123566,1409854455,1355396672,1317987909,1246755826,1192025387,1137557660,2072149281,2135122070,1912620623,1992383480,1753615357,1816598090,1627664531,1707420964,295390185,358241886,404320391,483945776,43990325,106832002,186451547,266083308,932423249,861060070,1041341759,986742920,613929101,542559546,756411363,701822548,3316196985,3244833742,3425377559,3370778784,3601682597,3530312978,3744426955,3689838204,3819031489,3881883254,3928223919,4007849240,4037393693,4100235434,4180117107,4259748804,2310601993,2373574846,2151335527,2231098320,2596047829,2659030626,2470359227,2550115596,2947551409,2876312838,2788305887,2733848168,3165939309,3094707162,3040238851,2985771188]),function(){var e=4294967295;this.getCRC=function(){return ~e>>>0},this.updateCRC=function(t){e=e<<8^Zc[255&(e>>>24^t)];},this.updateCRCRun=function(t,r){for(;r-- >0;)e=e<<8^Zc[255&(e>>>24^t)];};}),Qc=function(e,t){var r,i=e[t];for(r=t;r>0;r--)e[r]=e[r-1];return e[0]=i,i},Jc={OK:0,LAST_BLOCK:-1,NOT_BZIP_DATA:-2,UNEXPECTED_INPUT_EOF:-3,UNEXPECTED_OUTPUT_EOF:-4,DATA_ERROR:-5,OUT_OF_MEMORY:-6,OBSOLETE_INPUT:-7,END_OF_BLOCK:-8},eu={};eu[Jc.LAST_BLOCK]="Bad file checksum",eu[Jc.NOT_BZIP_DATA]="Not bzip data",eu[Jc.UNEXPECTED_INPUT_EOF]="Unexpected input EOF",eu[Jc.UNEXPECTED_OUTPUT_EOF]="Unexpected output EOF",eu[Jc.DATA_ERROR]="Data error",eu[Jc.OUT_OF_MEMORY]="Out of memory",eu[Jc.OBSOLETE_INPUT]="Obsolete (pre 0.9.5) bzip format not supported.";var tu=function(e,t){var r=eu[e]||"unknown error";t&&(r+=": "+t);var i=new TypeError(r);throw i.errorCode=e,i},ru=function(e,t){this.writePos=this.writeCurrent=this.writeCount=0,this._start_bunzip(e,t);};ru.prototype._init_block=function(){return this._get_next_block()?(this.blockCRC=new Yc,!0):(this.writeCount=-1,!1)},ru.prototype._start_bunzip=function(e,t){var r=new Uint8Array(4);4===e.read(r,0,4)&&"BZh"===String.fromCharCode(r[0],r[1],r[2])||tu(Jc.NOT_BZIP_DATA,"bad magic");var i=r[3]-48;(i<1||i>9)&&tu(Jc.NOT_BZIP_DATA,"level out of range"),this.reader=new Vc(e),this.dbufSize=1e5*i,this.nextoutput=0,this.outputStream=t,this.streamCRC=0;},ru.prototype._get_next_block=function(){var e,t,r,i=this.reader,n=i.pi();if("177245385090"===n)return !1;"314159265359"!==n&&tu(Jc.NOT_BZIP_DATA),this.targetBlockCRC=i.read(32)>>>0,this.streamCRC=(this.targetBlockCRC^(this.streamCRC<<1|this.streamCRC>>>31))>>>0,i.read(1)&&tu(Jc.OBSOLETE_INPUT);var a=i.read(24);a>this.dbufSize&&tu(Jc.DATA_ERROR,"initial position out of bounds");var s=i.read(16),o=new Uint8Array(256),c=0;for(e=0;e<16;e++)if(s&1<<15-e){var u=16*e;for(r=i.read(16),t=0;t<16;t++)r&1<<15-t&&(o[c++]=u+t);}var h=i.read(3);(h<2||h>6)&&tu(Jc.DATA_ERROR);var d=i.read(15);0===d&&tu(Jc.DATA_ERROR);var f=new Uint8Array(256);for(e=0;e<h;e++)f[e]=e;var l=new Uint8Array(d);for(e=0;e<d;e++){for(t=0;i.read(1);t++)t>=h&&tu(Jc.DATA_ERROR);l[e]=Qc(f,t);}var p,y=c+2,b=[];for(t=0;t<h;t++){var m,g,w=new Uint8Array(y),v=new Uint16Array(21);for(s=i.read(5),e=0;e<y;e++){for(;(s<1||s>20)&&tu(Jc.DATA_ERROR),i.read(1);)i.read(1)?s--:s++;w[e]=s;}for(m=g=w[0],e=1;e<y;e++)w[e]>g?g=w[e]:w[e]<m&&(m=w[e]);p={},b.push(p),p.permute=new Uint16Array(258),p.limit=new Uint32Array(22),p.base=new Uint32Array(21),p.minLen=m,p.maxLen=g;var _=0;for(e=m;e<=g;e++)for(v[e]=p.limit[e]=0,s=0;s<y;s++)w[s]===e&&(p.permute[_++]=s);for(e=0;e<y;e++)v[w[e]]++;for(_=s=0,e=m;e<g;e++)_+=v[e],p.limit[e]=_-1,_<<=1,s+=v[e],p.base[e+1]=_-s;p.limit[g+1]=Number.MAX_VALUE,p.limit[g]=_+v[g]-1,p.base[m]=0;}var k=new Uint32Array(256);for(e=0;e<256;e++)f[e]=e;var A,S=0,E=0,P=0,x=this.dbuf=new Uint32Array(this.dbufSize);for(y=0;;){for(y--||(y=49,P>=d&&tu(Jc.DATA_ERROR),p=b[l[P++]]),e=p.minLen,t=i.read(e);e>p.maxLen&&tu(Jc.DATA_ERROR),!(t<=p.limit[e]);e++)t=t<<1|i.read(1);((t-=p.base[e])<0||t>=258)&&tu(Jc.DATA_ERROR);var M=p.permute[t];if(0!==M&&1!==M){if(S)for(S=0,E+s>this.dbufSize&&tu(Jc.DATA_ERROR),k[A=o[f[0]]]+=s;s--;)x[E++]=A;if(M>c)break;E>=this.dbufSize&&tu(Jc.DATA_ERROR),k[A=o[A=Qc(f,e=M-1)]]++,x[E++]=A;}else S||(S=1,s=0),s+=0===M?S:2*S,S<<=1;}for((a<0||a>=E)&&tu(Jc.DATA_ERROR),t=0,e=0;e<256;e++)r=t+k[e],k[e]=t,t=r;for(e=0;e<E;e++)x[k[A=255&x[e]]]|=e<<8,k[A]++;var K=0,C=0,D=0;return E&&(C=255&(K=x[a]),K>>=8,D=-1),this.writePos=K,this.writeCurrent=C,this.writeCount=E,this.writeRun=D,!0},ru.prototype._read_bunzip=function(e,t){var r,i,n;if(this.writeCount<0)return 0;var a=this.dbuf,s=this.writePos,o=this.writeCurrent,c=this.writeCount;this.outputsize;for(var u=this.writeRun;c;){for(c--,i=o,o=255&(s=a[s]),s>>=8,3==u++?(r=o,n=i,o=-1):(r=1,n=o),this.blockCRC.updateCRCRun(n,r);r--;)this.outputStream.writeByte(n),this.nextoutput++;o!=i&&(u=0);}return this.writeCount=c,this.blockCRC.getCRC()!==this.targetBlockCRC&&tu(Jc.DATA_ERROR,"Bad block CRC (got "+this.blockCRC.getCRC().toString(16)+" expected "+this.targetBlockCRC.toString(16)+")"),this.nextoutput};var iu=function(e){if("readByte"in e)return e;var t=new Xc;return t.pos=0,t.readByte=function(){return e[this.pos++]},t.seek=function(e){this.pos=e;},t.eof=function(){return this.pos>=e.length},t},nu=function(e){var t=new Xc,r=!0;if(e)if("number"==typeof e)t.buffer=new Uint8Array(e),r=!1;else {if("writeByte"in e)return e;t.buffer=e,r=!1;}else t.buffer=new Uint8Array(16384);return t.pos=0,t.writeByte=function(e){if(r&&this.pos>=this.buffer.length){var t=new Uint8Array(2*this.buffer.length);t.set(this.buffer),this.buffer=t;}this.buffer[this.pos++]=e;},t.getBuffer=function(){if(this.pos!==this.buffer.length){if(!r)throw new TypeError("outputsize does not match decoded input");var e=new Uint8Array(this.pos);e.set(this.buffer.subarray(0,this.pos)),this.buffer=e;}return this.buffer},t._coerced=!0,t};var au=function(e,t,r){for(var i=iu(e),n=nu(t),a=new ru(i,n);!("eof"in i)||!i.eof();)if(a._init_block())a._read_bunzip();else {var s=a.reader.read(32)>>>0;if(s!==a.streamCRC&&tu(Jc.DATA_ERROR,"Bad stream CRC (got "+a.streamCRC.toString(16)+" expected "+s.toString(16)+")"),!r||!("eof"in i)||i.eof())break;a._start_bunzip(i,n);}if("getBuffer"in n)return n.getBuffer()};const ou=Symbol("verified"),cu=new Set([$.signatureSubpacket.issuer,$.signatureSubpacket.issuerFingerprint,$.signatureSubpacket.embeddedSignature]);class uu{static get tag(){return $.packet.signature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.signatureData=null,this.unhashedSubpackets=[],this.signedHashValue=null,this.created=null,this.signatureExpirationTime=null,this.signatureNeverExpires=!0,this.exportable=null,this.trustLevel=null,this.trustAmount=null,this.regularExpression=null,this.revocable=null,this.keyExpirationTime=null,this.keyNeverExpires=null,this.preferredSymmetricAlgorithms=null,this.revocationKeyClass=null,this.revocationKeyAlgorithm=null,this.revocationKeyFingerprint=null,this.issuerKeyID=new pe,this.rawNotations=[],this.notations={},this.preferredHashAlgorithms=null,this.preferredCompressionAlgorithms=null,this.keyServerPreferences=null,this.preferredKeyServer=null,this.isPrimaryUserID=null,this.policyURI=null,this.keyFlags=null,this.signersUserID=null,this.reasonForRevocationFlag=null,this.reasonForRevocationString=null,this.features=null,this.signatureTargetPublicKeyAlgorithm=null,this.signatureTargetHashAlgorithm=null,this.signatureTargetHash=null,this.embeddedSignature=null,this.issuerKeyVersion=null,this.issuerFingerprint=null,this.preferredAEADAlgorithms=null,this.revoked=null,this[ou]=null;}read(e){let t=0;if(this.version=e[t++],4!==this.version&&5!==this.version)throw new bn(`Version ${this.version} of the signature packet is unsupported.`);if(this.signatureType=e[t++],this.publicKeyAlgorithm=e[t++],this.hashAlgorithm=e[t++],t+=this.readSubPackets(e.subarray(t,e.length),!0),!this.created)throw Error("Missing signature creation time subpacket.");this.signatureData=e.subarray(0,t),t+=this.readSubPackets(e.subarray(t,e.length),!1),this.signedHashValue=e.subarray(t,t+2),t+=2,this.params=ga.signature.parseSignatureParams(this.publicKeyAlgorithm,e.subarray(t,e.length));}writeParams(){return this.params instanceof Promise?H((async()=>ga.serializeParams(this.publicKeyAlgorithm,await this.params))):ga.serializeParams(this.publicKeyAlgorithm,this.params)}write(){const e=[];return e.push(this.signatureData),e.push(this.writeUnhashedSubPackets()),e.push(this.signedHashValue),e.push(this.writeParams()),X.concat(e)}async sign(e,t,r=new Date,i=!1){5===e.version?this.version=5:this.version=4;const n=[new Uint8Array([this.version,this.signatureType,this.publicKeyAlgorithm,this.hashAlgorithm])];this.created=X.normalizeDate(r),this.issuerKeyVersion=e.version,this.issuerFingerprint=e.getFingerprintBytes(),this.issuerKeyID=e.getKeyID(),n.push(this.writeHashedSubPackets()),this.unhashedSubpackets=[],this.signatureData=X.concat(n);const a=this.toHash(this.signatureType,t,i),s=await this.hash(this.signatureType,t,a,i);this.signedHashValue=L(q(s),0,2);const o=async()=>ga.signature.sign(this.publicKeyAlgorithm,this.hashAlgorithm,e.publicParams,e.privateParams,a,await N(s));X.isStream(s)?this.params=o():(this.params=await o(),this[ou]=!0);}writeHashedSubPackets(){const e=$.signatureSubpacket,t=[];let r;if(null===this.created)throw Error("Missing signature creation time");t.push(hu(e.signatureCreationTime,!0,X.writeDate(this.created))),null!==this.signatureExpirationTime&&t.push(hu(e.signatureExpirationTime,!0,X.writeNumber(this.signatureExpirationTime,4))),null!==this.exportable&&t.push(hu(e.exportableCertification,!0,new Uint8Array([this.exportable?1:0]))),null!==this.trustLevel&&(r=new Uint8Array([this.trustLevel,this.trustAmount]),t.push(hu(e.trustSignature,!0,r))),null!==this.regularExpression&&t.push(hu(e.regularExpression,!0,this.regularExpression)),null!==this.revocable&&t.push(hu(e.revocable,!0,new Uint8Array([this.revocable?1:0]))),null!==this.keyExpirationTime&&t.push(hu(e.keyExpirationTime,!0,X.writeNumber(this.keyExpirationTime,4))),null!==this.preferredSymmetricAlgorithms&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.preferredSymmetricAlgorithms)),t.push(hu(e.preferredSymmetricAlgorithms,!1,r))),null!==this.revocationKeyClass&&(r=new Uint8Array([this.revocationKeyClass,this.revocationKeyAlgorithm]),r=X.concat([r,this.revocationKeyFingerprint]),t.push(hu(e.revocationKey,!1,r))),this.issuerKeyID.isNull()||5===this.issuerKeyVersion||t.push(hu(e.issuer,!0,this.issuerKeyID.write())),this.rawNotations.forEach((({name:i,value:n,humanReadable:a,critical:s})=>{r=[new Uint8Array([a?128:0,0,0,0])];const o=X.encodeUTF8(i);r.push(X.writeNumber(o.length,2)),r.push(X.writeNumber(n.length,2)),r.push(o),r.push(n),r=X.concat(r),t.push(hu(e.notationData,s,r));})),null!==this.preferredHashAlgorithms&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.preferredHashAlgorithms)),t.push(hu(e.preferredHashAlgorithms,!1,r))),null!==this.preferredCompressionAlgorithms&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.preferredCompressionAlgorithms)),t.push(hu(e.preferredCompressionAlgorithms,!1,r))),null!==this.keyServerPreferences&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.keyServerPreferences)),t.push(hu(e.keyServerPreferences,!1,r))),null!==this.preferredKeyServer&&t.push(hu(e.preferredKeyServer,!1,X.encodeUTF8(this.preferredKeyServer))),null!==this.isPrimaryUserID&&t.push(hu(e.primaryUserID,!1,new Uint8Array([this.isPrimaryUserID?1:0]))),null!==this.policyURI&&t.push(hu(e.policyURI,!1,X.encodeUTF8(this.policyURI))),null!==this.keyFlags&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.keyFlags)),t.push(hu(e.keyFlags,!0,r))),null!==this.signersUserID&&t.push(hu(e.signersUserID,!1,X.encodeUTF8(this.signersUserID))),null!==this.reasonForRevocationFlag&&(r=X.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag)+this.reasonForRevocationString),t.push(hu(e.reasonForRevocation,!0,r))),null!==this.features&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.features)),t.push(hu(e.features,!1,r))),null!==this.signatureTargetPublicKeyAlgorithm&&(r=[new Uint8Array([this.signatureTargetPublicKeyAlgorithm,this.signatureTargetHashAlgorithm])],r.push(X.stringToUint8Array(this.signatureTargetHash)),r=X.concat(r),t.push(hu(e.signatureTarget,!0,r))),null!==this.embeddedSignature&&t.push(hu(e.embeddedSignature,!0,this.embeddedSignature.write())),null!==this.issuerFingerprint&&(r=[new Uint8Array([this.issuerKeyVersion]),this.issuerFingerprint],r=X.concat(r),t.push(hu(e.issuerFingerprint,5===this.version,r))),null!==this.preferredAEADAlgorithms&&(r=X.stringToUint8Array(X.uint8ArrayToString(this.preferredAEADAlgorithms)),t.push(hu(e.preferredAEADAlgorithms,!1,r)));const i=X.concat(t),n=X.writeNumber(i.length,2);return X.concat([n,i])}writeUnhashedSubPackets(){const e=[];this.unhashedSubpackets.forEach((t=>{e.push(hn(t.length)),e.push(t);}));const t=X.concat(e),r=X.writeNumber(t.length,2);return X.concat([r,t])}readSubPacket(e,t=!0){let r=0;const i=!!(128&e[r]),n=127&e[r];if(t||(this.unhashedSubpackets.push(e.subarray(r,e.length)),cu.has(n)))switch(r++,n){case $.signatureSubpacket.signatureCreationTime:this.created=X.readDate(e.subarray(r,e.length));break;case $.signatureSubpacket.signatureExpirationTime:{const t=X.readNumber(e.subarray(r,e.length));this.signatureNeverExpires=0===t,this.signatureExpirationTime=t;break}case $.signatureSubpacket.exportableCertification:this.exportable=1===e[r++];break;case $.signatureSubpacket.trustSignature:this.trustLevel=e[r++],this.trustAmount=e[r++];break;case $.signatureSubpacket.regularExpression:this.regularExpression=e[r];break;case $.signatureSubpacket.revocable:this.revocable=1===e[r++];break;case $.signatureSubpacket.keyExpirationTime:{const t=X.readNumber(e.subarray(r,e.length));this.keyExpirationTime=t,this.keyNeverExpires=0===t;break}case $.signatureSubpacket.preferredSymmetricAlgorithms:this.preferredSymmetricAlgorithms=[...e.subarray(r,e.length)];break;case $.signatureSubpacket.revocationKey:this.revocationKeyClass=e[r++],this.revocationKeyAlgorithm=e[r++],this.revocationKeyFingerprint=e.subarray(r,r+20);break;case $.signatureSubpacket.issuer:this.issuerKeyID.read(e.subarray(r,e.length));break;case $.signatureSubpacket.notationData:{const t=!!(128&e[r]);r+=4;const n=X.readNumber(e.subarray(r,r+2));r+=2;const a=X.readNumber(e.subarray(r,r+2));r+=2;const s=X.decodeUTF8(e.subarray(r,r+n)),o=e.subarray(r+n,r+n+a);this.rawNotations.push({name:s,humanReadable:t,value:o,critical:i}),t&&(this.notations[s]=X.decodeUTF8(o));break}case $.signatureSubpacket.preferredHashAlgorithms:this.preferredHashAlgorithms=[...e.subarray(r,e.length)];break;case $.signatureSubpacket.preferredCompressionAlgorithms:this.preferredCompressionAlgorithms=[...e.subarray(r,e.length)];break;case $.signatureSubpacket.keyServerPreferences:this.keyServerPreferences=[...e.subarray(r,e.length)];break;case $.signatureSubpacket.preferredKeyServer:this.preferredKeyServer=X.decodeUTF8(e.subarray(r,e.length));break;case $.signatureSubpacket.primaryUserID:this.isPrimaryUserID=0!==e[r++];break;case $.signatureSubpacket.policyURI:this.policyURI=X.decodeUTF8(e.subarray(r,e.length));break;case $.signatureSubpacket.keyFlags:this.keyFlags=[...e.subarray(r,e.length)];break;case $.signatureSubpacket.signersUserID:this.signersUserID=X.decodeUTF8(e.subarray(r,e.length));break;case $.signatureSubpacket.reasonForRevocation:this.reasonForRevocationFlag=e[r++],this.reasonForRevocationString=X.decodeUTF8(e.subarray(r,e.length));break;case $.signatureSubpacket.features:this.features=[...e.subarray(r,e.length)];break;case $.signatureSubpacket.signatureTarget:{this.signatureTargetPublicKeyAlgorithm=e[r++],this.signatureTargetHashAlgorithm=e[r++];const t=ga.getHashByteLength(this.signatureTargetHashAlgorithm);this.signatureTargetHash=X.uint8ArrayToString(e.subarray(r,r+t));break}case $.signatureSubpacket.embeddedSignature:this.embeddedSignature=new uu,this.embeddedSignature.read(e.subarray(r,e.length));break;case $.signatureSubpacket.issuerFingerprint:this.issuerKeyVersion=e[r++],this.issuerFingerprint=e.subarray(r,e.length),5===this.issuerKeyVersion?this.issuerKeyID.read(this.issuerFingerprint):this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));break;case $.signatureSubpacket.preferredAEADAlgorithms:this.preferredAEADAlgorithms=[...e.subarray(r,e.length)];break;default:{const e=Error("Unknown signature subpacket type "+n);if(i)throw e;X.printDebug(e);}}}readSubPackets(e,t=!0,r){const i=X.readNumber(e.subarray(0,2));let n=2;for(;n<2+i;){const i=un(e.subarray(n,e.length));n+=i.offset,this.readSubPacket(e.subarray(n,n+i.len),t,r),n+=i.len;}return n}toSign(e,t){const r=$.signature;switch(e){case r.binary:return null!==t.text?X.encodeUTF8(t.getText(!0)):t.getBytes(!0);case r.text:{const e=t.getBytes(!0);return X.canonicalizeEOL(e)}case r.standalone:return new Uint8Array(0);case r.certGeneric:case r.certPersona:case r.certCasual:case r.certPositive:case r.certRevocation:{let e,i;if(t.userID)i=180,e=t.userID;else {if(!t.userAttribute)throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");i=209,e=t.userAttribute;}const n=e.write();return X.concat([this.toSign(r.key,t),new Uint8Array([i]),X.writeNumber(n.length,4),n])}case r.subkeyBinding:case r.subkeyRevocation:case r.keyBinding:return X.concat([this.toSign(r.key,t),this.toSign(r.key,{key:t.bind})]);case r.key:if(void 0===t.key)throw Error("Key packet is required for this signature.");return t.key.writeForHash(this.version);case r.keyRevocation:return this.toSign(r.key,t);case r.timestamp:return new Uint8Array(0);case r.thirdParty:throw Error("Not implemented");default:throw Error("Unknown signature type.")}}calculateTrailer(e,t){let r=0;return B(q(this.signatureData),(e=>{r+=e.length;}),(()=>{const i=[];return 5!==this.version||this.signatureType!==$.signature.binary&&this.signatureType!==$.signature.text||(t?i.push(new Uint8Array(6)):i.push(e.writeHeader())),i.push(new Uint8Array([this.version,255])),5===this.version&&i.push(new Uint8Array(4)),i.push(X.writeNumber(r,4)),X.concat(i)}))}toHash(e,t,r=!1){const i=this.toSign(e,t);return X.concat([i,this.signatureData,this.calculateTrailer(t,r)])}async hash(e,t,r,i=!1){return r||(r=this.toHash(e,t,i)),ga.hash.digest(this.hashAlgorithm,r)}async verify(e,t,r,i=new Date,n=!1,a=ne){if(!this.issuerKeyID.equals(e.getKeyID()))throw Error("Signature was not issued by the given public key");if(this.publicKeyAlgorithm!==e.algorithm)throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");const s=t===$.signature.binary||t===$.signature.text;if(!(this[ou]&&!s)){let i,a;if(this.hashed?a=await this.hashed:(i=this.toHash(t,r,n),a=await this.hash(t,r,i)),a=await N(a),this.signedHashValue[0]!==a[0]||this.signedHashValue[1]!==a[1])throw Error("Signed digest did not match");if(this.params=await this.params,this[ou]=await ga.signature.verify(this.publicKeyAlgorithm,this.hashAlgorithm,this.params,e.publicParams,i,a),!this[ou])throw Error("Signature verification failed")}const o=X.normalizeDate(i);if(o&&this.created>o)throw Error("Signature creation time is in the future");if(o&&o>=this.getExpirationTime())throw Error("Signature is expired");if(a.rejectHashAlgorithms.has(this.hashAlgorithm))throw Error("Insecure hash algorithm: "+$.read($.hash,this.hashAlgorithm).toUpperCase());if(a.rejectMessageHashAlgorithms.has(this.hashAlgorithm)&&[$.signature.binary,$.signature.text].includes(this.signatureType))throw Error("Insecure message hash algorithm: "+$.read($.hash,this.hashAlgorithm).toUpperCase());if(this.rawNotations.forEach((({name:e,critical:t})=>{if(t&&a.knownNotations.indexOf(e)<0)throw Error("Unknown critical notation: "+e)})),null!==this.revocationKeyClass)throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.")}isExpired(e=new Date){const t=X.normalizeDate(e);return null!==t&&!(this.created<=t&&t<this.getExpirationTime())}getExpirationTime(){return this.signatureNeverExpires?1/0:new Date(this.created.getTime()+1e3*this.signatureExpirationTime)}}function hu(e,t,r){const i=[];return i.push(hn(r.length+1)),i.push(new Uint8Array([(t?128:0)|e])),i.push(r),X.concat(i)}class du{static get tag(){return $.packet.onePassSignature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.issuerKeyID=null,this.flags=null;}read(e){let t=0;if(this.version=e[t++],3!==this.version)throw new bn(`Version ${this.version} of the one-pass signature packet is unsupported.`);return this.signatureType=e[t++],this.hashAlgorithm=e[t++],this.publicKeyAlgorithm=e[t++],this.issuerKeyID=new pe,this.issuerKeyID.read(e.subarray(t,t+8)),t+=8,this.flags=e[t++],this}write(){const e=new Uint8Array([3,this.signatureType,this.hashAlgorithm,this.publicKeyAlgorithm]),t=new Uint8Array([this.flags]);return X.concatUint8Array([e,this.issuerKeyID.write(),t])}calculateTrailer(...e){return H((async()=>uu.prototype.calculateTrailer.apply(await this.correspondingSig,e)))}async verify(){const e=await this.correspondingSig;if(!e||e.constructor.tag!==$.packet.signature)throw Error("Corresponding signature packet missing");if(e.signatureType!==this.signatureType||e.hashAlgorithm!==this.hashAlgorithm||e.publicKeyAlgorithm!==this.publicKeyAlgorithm||!e.issuerKeyID.equals(this.issuerKeyID))throw Error("Corresponding signature packet does not match one-pass signature packet");return e.hashed=this.hashed,e.verify.apply(e,arguments)}}function fu(e,t){if(!t[e]){let t;try{t=$.read($.packet,e);}catch(t){throw new bn("Unknown packet type with tag: "+e)}throw Error("Packet not allowed in this context: "+t)}return new t[e]}du.prototype.hash=uu.prototype.hash,du.prototype.toHash=uu.prototype.toHash,du.prototype.toSign=uu.prototype.toSign;class lu extends Array{static async fromBinary(e,t,r=ne){const i=new lu;return await i.read(e,t,r),i}async read(e,t,r=ne){r.additionalAllowedPackets.length&&(t={...t,...X.constructAllowedPackets(r.additionalAllowedPackets)}),this.stream=T(e,(async(e,i)=>{const n=D(i);try{for(;;){await n.ready;if(await yn(e,(async e=>{try{if(e.tag===$.packet.marker||e.tag===$.packet.trust)return;const i=fu(e.tag,t);i.packets=new lu,i.fromStream=X.isStream(e.packet),await i.read(e.packet,r),await n.write(i);}catch(t){const i=!r.ignoreUnsupportedPackets&&t instanceof bn,a=!(r.ignoreMalformedPackets||t instanceof bn);if(i||a||pn(e.tag))await n.abort(t);else {const t=new mn(e.tag,e.packet);await n.write(t);}X.printDebugError(t);}})))return await n.ready,void await n.close()}}catch(e){await n.abort(e);}}));const i=C(this.stream);for(;;){const{done:e,value:t}=await i.read();if(e?this.stream=null:this.push(t),e||pn(t.constructor.tag))break}i.releaseLock();}write(){const e=[];for(let t=0;t<this.length;t++){const r=this[t]instanceof mn?this[t].tag:this[t].constructor.tag,i=this[t].write();if(X.isStream(i)&&pn(this[t].constructor.tag)){let t=[],n=0;const a=512;e.push(fn$9(r)),e.push(B(i,(e=>{if(t.push(e),n+=e.length,n>=a){const e=Math.min(Math.log(n)/Math.LN2|0,30),r=2**e,i=X.concat([dn(e)].concat(t));return t=[i.subarray(1+r)],n=t[0].length,i.subarray(0,1+r)}}),(()=>X.concat([hn(n)].concat(t)))));}else {if(X.isStream(i)){let t=0;e.push(B(q(i),(e=>{t+=e.length;}),(()=>ln(r,t))));}else e.push(ln(r,i.length));e.push(i);}}return X.concat(e)}filterByTag(...e){const t=new lu,r=e=>t=>e===t;for(let i=0;i<this.length;i++)e.some(r(this[i].constructor.tag))&&t.push(this[i]);return t}findPacket(e){return this.find((t=>t.constructor.tag===e))}indexOfTag(...e){const t=[],r=this,i=e=>t=>e===t;for(let n=0;n<this.length;n++)e.some(i(r[n].constructor.tag))&&t.push(n);return t}}const bu=X.getNodeZlib();function mu(e){return e}function gu(e,t,r={}){return function(i){return !X.isStream(i)||s(i)?H((()=>N(i).then((t=>new Promise(((i,n)=>{e(t,r,((e,t)=>{if(e)return n(e);i(t);}));})))))):y(b(i).pipe(t(r)))}}function wu(e,t={}){return function(r){const i=new e(t);return B(r,(e=>{if(e.length)return i.push(e,Ca),i.result}),(()=>{if(e===To)return i.push([],Ua),i.result}))}}function vu(e){return function(t){return H((async()=>e(await N(t))))}}bu?{uncompressed:mu,zip:/*#__PURE__*/gu(bu.inflateRaw,bu.createInflateRaw),zlib:/*#__PURE__*/gu(bu.inflate,bu.createInflate),bzip2:/*#__PURE__*/vu(au)}:{uncompressed:mu,zip:/*#__PURE__*/wu(Hc,{raw:!0}),zlib:/*#__PURE__*/wu(Hc),bzip2:/*#__PURE__*/vu(au)};class Ku{constructor(e=ne){this.algorithm=$.hash.sha256,this.type="iterated",this.c=e.s2kIterationCountByte,this.salt=null;}getCount(){return 16+(15&this.c)<<6+(this.c>>4)}read(e){let t=0;try{this.type=$.read($.s2k,e[t++]);}catch(e){throw new bn("Unknown S2K type.")}switch(this.algorithm=e[t++],this.type){case"simple":break;case"salted":this.salt=e.subarray(t,t+8),t+=8;break;case"iterated":this.salt=e.subarray(t,t+8),t+=8,this.c=e[t++];break;case"gnu":if("GNU"!==X.uint8ArrayToString(e.subarray(t,t+3)))throw new bn("Unknown s2k type.");t+=3;if(1001!==1e3+e[t++])throw new bn("Unknown s2k gnu protection mode.");this.type="gnu-dummy";break;default:throw new bn("Unknown s2k type.")}return t}write(){if("gnu-dummy"===this.type)return new Uint8Array([101,0,...X.stringToUint8Array("GNU"),1]);const e=[new Uint8Array([$.write($.s2k,this.type),this.algorithm])];switch(this.type){case"simple":break;case"salted":e.push(this.salt);break;case"iterated":e.push(this.salt),e.push(new Uint8Array([this.c]));break;case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}return X.concatUint8Array(e)}async produceKey(e,t){e=X.encodeUTF8(e);const r=[];let i=0,n=0;for(;i<t;){let t;switch(this.type){case"simple":t=X.concatUint8Array([new Uint8Array(n),e]);break;case"salted":t=X.concatUint8Array([new Uint8Array(n),this.salt,e]);break;case"iterated":{const r=X.concatUint8Array([this.salt,e]);let i=r.length;const a=Math.max(this.getCount(),i);t=new Uint8Array(n+a),t.set(r,n);for(let e=n+i;e<a;e+=i,i*=2)t.copyWithin(e,n,e);break}case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}const a=await ga.hash.digest(this.algorithm,t);r.push(a),i+=a.length,n++;}return X.concatUint8Array(r).subarray(0,t)}}class Du{static get tag(){return $.packet.publicKey}constructor(e=new Date,t=ne){this.version=t.v5Keys?5:4,this.created=X.normalizeDate(e),this.algorithm=null,this.publicParams=null,this.expirationTimeV3=0,this.fingerprint=null,this.keyID=null;}static fromSecretKeyPacket(e){const t=new Du,{version:r,created:i,algorithm:n,publicParams:a,keyID:s,fingerprint:o}=e;return t.version=r,t.created=i,t.algorithm=n,t.publicParams=a,t.keyID=s,t.fingerprint=o,t}async read(e){let t=0;if(this.version=e[t++],4===this.version||5===this.version){this.created=X.readDate(e.subarray(t,t+4)),t+=4,this.algorithm=e[t++],5===this.version&&(t+=4);const{read:r,publicParams:i}=ga.parsePublicKeyParams(this.algorithm,e.subarray(t));return this.publicParams=i,t+=r,await this.computeFingerprintAndKeyID(),t}throw new bn(`Version ${this.version} of the key packet is unsupported.`)}write(){const e=[];e.push(new Uint8Array([this.version])),e.push(X.writeDate(this.created)),e.push(new Uint8Array([this.algorithm]));const t=ga.serializeParams(this.algorithm,this.publicParams);return 5===this.version&&e.push(X.writeNumber(t.length,4)),e.push(t),X.concatUint8Array(e)}writeForHash(e){const t=this.writePublicKey();return 5===e?X.concatUint8Array([new Uint8Array([154]),X.writeNumber(t.length,4),t]):X.concatUint8Array([new Uint8Array([153]),X.writeNumber(t.length,2),t])}isDecrypted(){return null}getCreationTime(){return this.created}getKeyID(){return this.keyID}async computeFingerprintAndKeyID(){if(await this.computeFingerprint(),this.keyID=new pe,5===this.version)this.keyID.read(this.fingerprint.subarray(0,8));else {if(4!==this.version)throw Error("Unsupported key version");this.keyID.read(this.fingerprint.subarray(12,20));}}async computeFingerprint(){const e=this.writeForHash(this.version);if(5===this.version)this.fingerprint=await ga.hash.sha256(e);else {if(4!==this.version)throw Error("Unsupported key version");this.fingerprint=await ga.hash.sha1(e);}}getFingerprintBytes(){return this.fingerprint}getFingerprint(){return X.uint8ArrayToHex(this.getFingerprintBytes())}hasSameFingerprintAs(e){return this.version===e.version&&X.equalsUint8Array(this.writePublicKey(),e.writePublicKey())}getAlgorithmInfo(){const e={};e.algorithm=$.read($.publicKey,this.algorithm);const t=this.publicParams.n||this.publicParams.p;return t?e.bits=X.uint8ArrayBitLength(t):this.publicParams.oid&&(e.curve=this.publicParams.oid.getName()),e}}Du.prototype.readPublicKey=Du.prototype.read,Du.prototype.writePublicKey=Du.prototype.write;class Bu extends Du{static get tag(){return $.packet.publicSubkey}constructor(e,t){super(e,t);}static fromSecretSubkeyPacket(e){const t=new Bu,{version:r,created:i,algorithm:n,publicParams:a,keyID:s,fingerprint:o}=e;return t.version=r,t.created=i,t.algorithm=n,t.publicParams=a,t.keyID=s,t.fingerprint=o,t}}class Tu{static get tag(){return $.packet.userAttribute}constructor(){this.attributes=[];}read(e){let t=0;for(;t<e.length;){const r=un(e.subarray(t,e.length));t+=r.offset,this.attributes.push(X.uint8ArrayToString(e.subarray(t,t+r.len))),t+=r.len;}}write(){const e=[];for(let t=0;t<this.attributes.length;t++)e.push(hn(this.attributes[t].length)),e.push(X.stringToUint8Array(this.attributes[t]));return X.concatUint8Array(e)}equals(e){return !!(e&&e instanceof Tu)&&this.attributes.every((function(t,r){return t===e.attributes[r]}))}}class zu extends Du{static get tag(){return $.packet.secretKey}constructor(e=new Date,t=ne){super(e,t),this.keyMaterial=null,this.isEncrypted=null,this.s2kUsage=0,this.s2k=null,this.symmetric=null,this.aead=null,this.privateParams=null;}async read(e){let t=await this.readPublicKey(e);const r=t;this.s2kUsage=e[t++],5===this.version&&t++;try{if(255===this.s2kUsage||254===this.s2kUsage||253===this.s2kUsage){if(this.symmetric=e[t++],253===this.s2kUsage&&(this.aead=e[t++]),this.s2k=new Ku,t+=this.s2k.read(e.subarray(t,e.length)),"gnu-dummy"===this.s2k.type)return}else this.s2kUsage&&(this.symmetric=this.s2kUsage);this.s2kUsage&&(this.iv=e.subarray(t,t+ga.getCipher(this.symmetric).blockSize),t+=this.iv.length);}catch(t){if(!this.s2kUsage)throw t;this.unparseableKeyMaterial=e.subarray(r),this.isEncrypted=!0;}if(5===this.version&&(t+=4),this.keyMaterial=e.subarray(t),this.isEncrypted=!!this.s2kUsage,!this.isEncrypted){const e=this.keyMaterial.subarray(0,-2);if(!X.equalsUint8Array(X.writeChecksum(e),this.keyMaterial.subarray(-2)))throw Error("Key checksum mismatch");try{const{privateParams:t}=ga.parsePrivateKeyParams(this.algorithm,e,this.publicParams);this.privateParams=t;}catch(e){if(e instanceof bn)throw e;throw Error("Error reading MPIs")}}}write(){const e=this.writePublicKey();if(this.unparseableKeyMaterial)return X.concatUint8Array([e,this.unparseableKeyMaterial]);const t=[e];t.push(new Uint8Array([this.s2kUsage]));const r=[];return 255!==this.s2kUsage&&254!==this.s2kUsage&&253!==this.s2kUsage||(r.push(this.symmetric),253===this.s2kUsage&&r.push(this.aead),r.push(...this.s2k.write())),this.s2kUsage&&"gnu-dummy"!==this.s2k.type&&r.push(...this.iv),5===this.version&&t.push(new Uint8Array([r.length])),t.push(new Uint8Array(r)),this.isDummy()||(this.s2kUsage||(this.keyMaterial=ga.serializeParams(this.algorithm,this.privateParams)),5===this.version&&t.push(X.writeNumber(this.keyMaterial.length,4)),t.push(this.keyMaterial),this.s2kUsage||t.push(X.writeChecksum(this.keyMaterial))),X.concatUint8Array(t)}isDecrypted(){return !1===this.isEncrypted}isMissingSecretKeyMaterial(){return void 0!==this.unparseableKeyMaterial||this.isDummy()}isDummy(){return !(!this.s2k||"gnu-dummy"!==this.s2k.type)}makeDummy(e=ne){this.isDummy()||(this.isDecrypted()&&this.clearPrivateParams(),delete this.unparseableKeyMaterial,this.isEncrypted=null,this.keyMaterial=null,this.s2k=new Ku(e),this.s2k.algorithm=0,this.s2k.c=0,this.s2k.type="gnu-dummy",this.s2kUsage=254,this.symmetric=$.symmetric.aes256);}async encrypt(e,t=ne){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key packet is already encrypted");if(!e)throw Error("A non-empty passphrase is required for key encryption.");this.s2k=new Ku(t),this.s2k.salt=ga.random.getRandomBytes(8);const r=ga.serializeParams(this.algorithm,this.privateParams);this.symmetric=$.symmetric.aes256;const i=await qu(this.s2k,e,this.symmetric),{blockSize:n}=ga.getCipher(this.symmetric);if(this.iv=ga.random.getRandomBytes(n),t.aeadProtect){this.s2kUsage=253,this.aead=$.aead.eax;const e=ga.getAEADMode(this.aead),t=await e(this.symmetric,i);this.keyMaterial=await t.encrypt(r,this.iv.subarray(0,e.ivLength),new Uint8Array);}else this.s2kUsage=254,this.keyMaterial=await ga.mode.cfb.encrypt(this.symmetric,i,X.concatUint8Array([r,await ga.hash.sha1(r,t)]),this.iv,t);}async decrypt(e){if(this.isDummy())return !1;if(this.unparseableKeyMaterial)throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");if(this.isDecrypted())throw Error("Key packet is already decrypted.");let t,r;if(254!==this.s2kUsage&&253!==this.s2kUsage)throw 255===this.s2kUsage?Error("Encrypted private key is authenticated using an insecure two-byte hash"):Error("Private key is encrypted using an insecure S2K function: unsalted MD5");if(t=await qu(this.s2k,e,this.symmetric),253===this.s2kUsage){const e=ga.getAEADMode(this.aead),i=await e(this.symmetric,t);try{r=await i.decrypt(this.keyMaterial,this.iv.subarray(0,e.ivLength),new Uint8Array);}catch(e){if("Authentication tag mismatch"===e.message)throw Error("Incorrect key passphrase: "+e.message);throw e}}else {const e=await ga.mode.cfb.decrypt(this.symmetric,t,this.keyMaterial,this.iv);r=e.subarray(0,-20);const i=await ga.hash.sha1(r);if(!X.equalsUint8Array(i,e.subarray(-20)))throw Error("Incorrect key passphrase")}try{const{privateParams:e}=ga.parsePrivateKeyParams(this.algorithm,r,this.publicParams);this.privateParams=e;}catch(e){throw Error("Error reading MPIs")}this.isEncrypted=!1,this.keyMaterial=null,this.s2kUsage=0;}async validate(){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key is not decrypted");let e;try{e=await ga.validateParams(this.algorithm,this.publicParams,this.privateParams);}catch(t){e=!1;}if(!e)throw Error("Key is invalid")}async generate(e,t){const{privateParams:r,publicParams:i}=await ga.generateParams(this.algorithm,e,t);this.privateParams=r,this.publicParams=i,this.isEncrypted=!1;}clearPrivateParams(){this.isMissingSecretKeyMaterial()||(Object.keys(this.privateParams).forEach((e=>{this.privateParams[e].fill(0),delete this.privateParams[e];})),this.privateParams=null,this.isEncrypted=!0);}}async function qu(e,t,r){const{keySize:i}=ga.getCipher(r);return e.produceKey(t,i)}var Fu=it((function(e){!function(t){function r(e){function t(){return Ae<Se}function r(){return Ae}function n(e){Ae=e;}function a(){Ae=0,Se=ke.length;}function s(e,t){return {name:e,tokens:t||"",semantic:t||"",children:[]}}function o(e,t){var r;return null===t?null:((r=s(e)).tokens=t.tokens,r.semantic=t.semantic,r.children.push(t),r)}function c(e,t){return null!==t&&(e.tokens+=t.tokens,e.semantic+=t.semantic),e.children.push(t),e}function u(e){var r;return t()&&e(r=ke[Ae])?(Ae+=1,s("token",r)):null}function h(e){return function(){return o("literal",u((function(t){return t===e})))}}function d(){var e=arguments;return function(){var t,i,a,o;for(o=r(),i=s("and"),t=0;t<e.length;t+=1){if(null===(a=e[t]()))return n(o),null;c(i,a);}return i}}function f(){var e=arguments;return function(){var t,i,a;for(a=r(),t=0;t<e.length;t+=1){if(null!==(i=e[t]()))return i;n(a);}return null}}function l(e){return function(){var t,i;return i=r(),null!==(t=e())?t:(n(i),s("opt"))}}function p(e){return function(){var t=e();return null!==t&&(t.semantic=""),t}}function y(e){return function(){var t=e();return null!==t&&t.semantic.length>0&&(t.semantic=" "),t}}function b(e,t){return function(){var i,a,o,u,h;for(u=r(),i=s("star"),o=0,h=void 0===t?0:t;null!==(a=e());)o+=1,c(i,a);return o>=h?i:(n(u),null)}}function m(e){return e.charCodeAt(0)>=128}function g(){return o("cr",h("\r")())}function w(){return o("crlf",d(g,k)())}function v(){return o("dquote",h('"')())}function _(){return o("htab",h("\t")())}function k(){return o("lf",h("\n")())}function A(){return o("sp",h(" ")())}function S(){return o("vchar",u((function(t){var r=t.charCodeAt(0),i=33<=r&&r<=126;return e.rfc6532&&(i=i||m(t)),i})))}function E(){return o("wsp",f(A,_)())}function P(){var e=o("quoted-pair",f(d(h("\\"),f(S,E)),ie)());return null===e?null:(e.semantic=e.semantic[1],e)}function x(){return o("fws",f(ae,d(l(d(b(E),p(w))),b(E,1)))())}function M(){return o("ctext",f((function(){return u((function(t){var r=t.charCodeAt(0),i=33<=r&&r<=39||42<=r&&r<=91||93<=r&&r<=126;return e.rfc6532&&(i=i||m(t)),i}))}),te)())}function K(){return o("ccontent",f(M,P,C)())}function C(){return o("comment",d(h("("),b(d(l(x),K)),l(x),h(")"))())}function D(){return o("cfws",f(d(b(d(l(x),C),1),l(x)),x)())}function U(){return o("atext",u((function(t){var r="a"<=t&&t<="z"||"A"<=t&&t<="Z"||"0"<=t&&t<="9"||["!","#","$","%","&","'","*","+","-","/","=","?","^","_","`","{","|","}","~"].indexOf(t)>=0;return e.rfc6532&&(r=r||m(t)),r})))}function R(){return o("atom",d(y(l(D)),b(U,1),y(l(D)))())}function I(){var e,t;return null===(e=o("dot-atom-text",b(U,1)()))||null!==(t=b(d(h("."),b(U,1)))())&&c(e,t),e}function B(){return o("dot-atom",d(p(l(D)),I,p(l(D)))())}function T(){return o("qtext",f((function(){return u((function(t){var r=t.charCodeAt(0),i=33===r||35<=r&&r<=91||93<=r&&r<=126;return e.rfc6532&&(i=i||m(t)),i}))}),re)())}function z(){return o("qcontent",f(T,P)())}function q(){return o("quoted-string",d(p(l(D)),p(v),b(d(l(y(x)),z)),l(p(x)),p(v),p(l(D)))())}function F(){return o("word",f(R,q)())}function O(){return o("address",f(L,H)())}function L(){return o("mailbox",f(N,J)())}function N(){return o("name-addr",d(l(W),j)())}function j(){return o("angle-addr",f(d(p(l(D)),h("<"),J,h(">"),p(l(D))),se)())}function H(){return o("group",d(W,h(":"),l($),h(";"),p(l(D)))())}function W(){return o("display-name",(null!==(e=o("phrase",f(ne,b(F,1))()))&&(e.semantic=function(e){return e.replace(/([ \t]|\r\n)+/g," ").replace(/^\s*/,"").replace(/\s*$/,"")}(e.semantic)),e));var e;}function G(){return o("mailbox-list",f(d(L,b(d(h(","),L))),ue)())}function V(){return o("address-list",f(d(O,b(d(h(","),O))),he)())}function $(){return o("group-list",f(G,p(D),de)())}function Z(){return o("local-part",f(fe,B,q)())}function X(){return o("dtext",f((function(){return u((function(t){var r=t.charCodeAt(0),i=33<=r&&r<=90||94<=r&&r<=126;return e.rfc6532&&(i=i||m(t)),i}))}),pe)())}function Y(){return o("domain-literal",d(p(l(D)),h("["),b(d(l(x),X)),l(x),h("]"),p(l(D)))())}function Q(){return o("domain",(t=f(le,B,Y)(),e.rejectTLD&&t&&t.semantic&&t.semantic.indexOf(".")<0?null:(t&&(t.semantic=t.semantic.replace(/\s+/g,"")),t)));var t;}function J(){return o("addr-spec",d(Z,h("@"),Q)())}function ee(){return e.strict?null:o("obs-NO-WS-CTL",u((function(e){var t=e.charCodeAt(0);return 1<=t&&t<=8||11===t||12===t||14<=t&&t<=31||127===t})))}function te(){return e.strict?null:o("obs-ctext",ee())}function re(){return e.strict?null:o("obs-qtext",ee())}function ie(){return e.strict?null:o("obs-qp",d(h("\\"),f(h("\0"),ee,k,g))())}function ne(){return e.strict?null:e.atInDisplayName?o("obs-phrase",d(F,b(f(F,h("."),h("@"),y(D))))()):o("obs-phrase",d(F,b(f(F,h("."),y(D))))())}function ae(){return e.strict?null:o("obs-FWS",b(d(p(l(w)),E),1)())}function se(){return e.strict?null:o("obs-angle-addr",d(p(l(D)),h("<"),oe,J,h(">"),p(l(D)))())}function oe(){return e.strict?null:o("obs-route",d(ce,h(":"))())}function ce(){return e.strict?null:o("obs-domain-list",d(b(f(p(D),h(","))),h("@"),Q,b(d(h(","),p(l(D)),l(d(h("@"),Q)))))())}function ue(){return e.strict?null:o("obs-mbox-list",d(b(d(p(l(D)),h(","))),L,b(d(h(","),l(d(L,p(D))))))())}function he(){return e.strict?null:o("obs-addr-list",d(b(d(p(l(D)),h(","))),O,b(d(h(","),l(d(O,p(D))))))())}function de(){return e.strict?null:o("obs-group-list",d(b(d(p(l(D)),h(",")),1),p(l(D)))())}function fe(){return e.strict?null:o("obs-local-part",d(F,b(d(h("."),F)))())}function le(){return e.strict?null:o("obs-domain",d(R,b(d(h("."),R)))())}function pe(){return e.strict?null:o("obs-dtext",f(ee,P)())}function ye(e,t){var r,i,n;if(null==t)return null;for(i=[t];i.length>0;){if((n=i.pop()).name===e)return n;for(r=n.children.length-1;r>=0;r-=1)i.push(n.children[r]);}return null}function be(e,t){var r,i,n,a,s;if(null==t)return null;for(i=[t],a=[],s={},r=0;r<e.length;r+=1)s[e[r]]=!0;for(;i.length>0;)if((n=i.pop()).name in s)a.push(n);else for(r=n.children.length-1;r>=0;r-=1)i.push(n.children[r]);return a}function me(t){var r,i,n,a,s;if(null===t)return null;for(r=[],i=be(["group","mailbox"],t),n=0;n<i.length;n+=1)"group"===(a=i[n]).name?r.push(ge(a)):"mailbox"===a.name&&r.push(we(a));return s={ast:t,addresses:r},e.simple&&(s=function(e){var t;if(e&&e.addresses)for(t=0;t<e.addresses.length;t+=1)delete e.addresses[t].node;return e}(s)),e.oneResult?function(t){if(!t)return null;if(!e.partial&&t.addresses.length>1)return null;return t.addresses&&t.addresses[0]}(s):e.simple?s&&s.addresses:s}function ge(e){var t,r=ye("display-name",e),i=[],n=be(["mailbox"],e);for(t=0;t<n.length;t+=1)i.push(we(n[t]));return {node:e,parts:{name:r},type:e.name,name:ve(r),addresses:i}}function we(e){var t=ye("display-name",e),r=ye("addr-spec",e),i=function(e,t){var r,i,n,a;if(null==t)return null;for(i=[t],a=[];i.length>0;)for((n=i.pop()).name===e&&a.push(n),r=n.children.length-1;r>=0;r-=1)i.push(n.children[r]);return a}("cfws",e),n=be(["comment"],e),a=ye("local-part",r),s=ye("domain",r);return {node:e,parts:{name:t,address:r,local:a,domain:s,comments:i},type:e.name,name:ve(t),address:ve(r),local:ve(a),domain:ve(s),comments:_e(n),groupName:ve(e.groupName)}}function ve(e){return null!=e?e.semantic:null}function _e(e){var t="";if(e)for(var r=0;r<e.length;r+=1)t+=ve(e[r]);return t}var ke,Ae,Se,Ee,Pe;if(null===(e=i(e,{})))return null;if(ke=e.input,Pe={address:O,"address-list":V,"angle-addr":j,from:function(){return o("from",f(G,V)())},group:H,mailbox:L,"mailbox-list":G,"reply-to":function(){return o("reply-to",V())},sender:function(){return o("sender",f(L,O)())}}[e.startAt]||V,!e.strict){if(a(),e.strict=!0,Ee=Pe(ke),e.partial||!t())return me(Ee);e.strict=!1;}return a(),Ee=Pe(ke),!e.partial&&t()?null:me(Ee)}function i(e,t){function r(e){return "[object String]"===Object.prototype.toString.call(e)}function i(e){return null==e}var n,a;if(r(e))e={input:e};else if(!function(e){return e===Object(e)}(e))return null;if(!r(e.input))return null;if(!t)return null;for(a in n={oneResult:!1,partial:!1,rejectTLD:!1,rfc6532:!1,simple:!1,startAt:"address-list",strict:!1,atInDisplayName:!1})i(e[a])&&(e[a]=i(t[a])?n[a]:t[a]);return e}r.parseOneAddress=function(e){return r(i(e,{oneResult:!0,rfc6532:!0,simple:!0,startAt:"address-list"}))},r.parseAddressList=function(e){return r(i(e,{rfc6532:!0,simple:!0,startAt:"address-list"}))},r.parseFrom=function(e){return r(i(e,{rfc6532:!0,simple:!0,startAt:"from"}))},r.parseSender=function(e){return r(i(e,{oneResult:!0,rfc6532:!0,simple:!0,startAt:"sender"}))},r.parseReplyTo=function(e){return r(i(e,{rfc6532:!0,simple:!0,startAt:"reply-to"}))},e.exports=r;}();}));class Ou{static get tag(){return $.packet.userID}constructor(){this.userID="",this.name="",this.email="",this.comment="";}static fromObject(e){if(X.isString(e)||e.name&&!X.isString(e.name)||e.email&&!X.isEmailAddress(e.email)||e.comment&&!X.isString(e.comment))throw Error("Invalid user ID format");const t=new Ou;Object.assign(t,e);const r=[];return t.name&&r.push(t.name),t.comment&&r.push(`(${t.comment})`),t.email&&r.push(`<${t.email}>`),t.userID=r.join(" "),t}read(e,t=ne){const r=X.decodeUTF8(e);if(r.length>t.maxUserIDLength)throw Error("User ID string is too long");try{const{name:e,address:t,comments:i}=Fu.parseOneAddress({input:r,atInDisplayName:!0});this.comment=i.replace(/^\(|\)$/g,""),this.name=e,this.email=t;}catch(e){}this.userID=r;}write(){return X.encodeUTF8(this.userID)}equals(e){return e&&e.userID===this.userID}}class Lu extends zu{static get tag(){return $.packet.secretSubkey}constructor(e=new Date,t=ne){super(e,t);}}async function Gu(e,t){const r=new Lu(e.date,t);return r.packets=null,r.algorithm=$.write($.publicKey,e.algorithm),await r.generate(e.rsaBits,e.curve),await r.computeFingerprintAndKeyID(),r}async function $u(e,t,r,i,n=new Date,a){let s,o;for(let c=e.length-1;c>=0;c--)try{(!s||e[c].created>=s.created)&&(await e[c].verify(t,r,i,n,void 0,a),s=e[c]);}catch(e){o=e;}if(!s)throw X.wrapError(`Could not find valid ${$.read($.signature,r)} signature in key ${t.getKeyID().toHex()}`.replace("certGeneric ","self-").replace(/([a-z])([A-Z])/g,((e,t,r)=>t+" "+r.toLowerCase())),o);return s}function Zu(e,t,r=new Date){const i=X.normalizeDate(r);if(null!==i){const r=rh(e,t);return !(e.created<=i&&i<r)}return !1}async function Xu(e,t,r,i){const n={};n.key=t,n.bind=e;const a={signatureType:$.signature.subkeyBinding};r.sign?(a.keyFlags=[$.keyFlags.signData],a.embeddedSignature=await Ju(n,null,e,{signatureType:$.signature.keyBinding},r.date,void 0,void 0,void 0,i)):a.keyFlags=[$.keyFlags.encryptCommunication|$.keyFlags.encryptStorage],r.keyExpirationTime>0&&(a.keyExpirationTime=r.keyExpirationTime,a.keyNeverExpires=!1);return await Ju(n,null,t,a,r.date,void 0,void 0,void 0,i)}async function Yu(e,t,r=new Date,i={},n){let a=n.preferredHashAlgorithm,s=a;if(e){const t=await e.getPrimaryUser(r,i,n);t.selfCertification.preferredHashAlgorithms&&([s]=t.selfCertification.preferredHashAlgorithms,a=ga.hash.getHashByteLength(a)<=ga.hash.getHashByteLength(s)?s:a);}switch(t.algorithm){case $.publicKey.ecdsa:case $.publicKey.eddsaLegacy:case $.publicKey.ed25519:s=ga.getPreferredCurveHashAlgo(t.algorithm,t.publicParams.oid);}return ga.hash.getHashByteLength(a)<=ga.hash.getHashByteLength(s)?s:a}async function Ju(e,t,r,i,n,a,s=[],o=!1,c){if(r.isDummy())throw Error("Cannot sign with a gnu-dummy key.");if(!r.isDecrypted())throw Error("Signing key is not decrypted.");const u=new uu;return Object.assign(u,i),u.publicKeyAlgorithm=r.algorithm,u.hashAlgorithm=await Yu(t,r,n,a,c),u.rawNotations=s,await u.sign(r,e,n,o),u}async function eh(e,t,r,i=new Date,n){(e=e[r])&&(t[r].length?await Promise.all(e.map((async function(e){e.isExpired(i)||n&&!await n(e)||t[r].some((function(t){return X.equalsUint8Array(t.writeParams(),e.writeParams())}))||t[r].push(e);}))):t[r]=e);}async function th(e,t,r,i,n,a,s=new Date,o){a=a||e;const c=[];return await Promise.all(i.map((async function(e){try{n&&!e.issuerKeyID.equals(n.issuerKeyID)||(await e.verify(a,t,r,o.revocationsExpire?s:null,!1,o),c.push(e.issuerKeyID));}catch(e){}}))),n?(n.revoked=!!c.some((e=>e.equals(n.issuerKeyID)))||(n.revoked||!1),n.revoked):c.length>0}function rh(e,t){let r;return !1===t.keyNeverExpires&&(r=e.created.getTime()+1e3*t.keyExpirationTime),r?new Date(r):1/0}function ih(e,t={}){switch(e.type=e.type||t.type,e.curve=e.curve||t.curve,e.rsaBits=e.rsaBits||t.rsaBits,e.keyExpirationTime=void 0!==e.keyExpirationTime?e.keyExpirationTime:t.keyExpirationTime,e.passphrase=X.isString(e.passphrase)?e.passphrase:t.passphrase,e.date=e.date||t.date,e.sign=e.sign||!1,e.type){case"ecc":try{e.curve=$.write($.curve,e.curve);}catch(e){throw Error("Unknown curve")}e.curve!==$.curve.ed25519Legacy&&e.curve!==$.curve.curve25519Legacy||(e.curve=e.sign?$.curve.ed25519Legacy:$.curve.curve25519Legacy),e.sign?e.algorithm=e.curve===$.curve.ed25519Legacy?$.publicKey.eddsaLegacy:$.publicKey.ecdsa:e.algorithm=$.publicKey.ecdh;break;case"rsa":e.algorithm=$.publicKey.rsaEncryptSign;break;default:throw Error("Unsupported key type "+e.type)}return e}function nh(e,t){const r=e.algorithm;return r!==$.publicKey.rsaEncrypt&&r!==$.publicKey.elgamal&&r!==$.publicKey.ecdh&&r!==$.publicKey.x25519&&(!t.keyFlags||0!=(t.keyFlags[0]&$.keyFlags.signData))}function ah(e,t){const r=e.algorithm;return r!==$.publicKey.dsa&&r!==$.publicKey.rsaSign&&r!==$.publicKey.ecdsa&&r!==$.publicKey.eddsaLegacy&&r!==$.publicKey.ed25519&&(!t.keyFlags||0!=(t.keyFlags[0]&$.keyFlags.encryptCommunication)||0!=(t.keyFlags[0]&$.keyFlags.encryptStorage))}function sh(e,t){return !!t.allowInsecureDecryptionWithSigningKeys||(!e.keyFlags||0!=(e.keyFlags[0]&$.keyFlags.encryptCommunication)||0!=(e.keyFlags[0]&$.keyFlags.encryptStorage))}function oh(e,t){const r=$.write($.publicKey,e.algorithm),i=e.getAlgorithmInfo();if(t.rejectPublicKeyAlgorithms.has(r))throw Error(i.algorithm+" keys are considered too weak.");switch(r){case $.publicKey.rsaEncryptSign:case $.publicKey.rsaSign:case $.publicKey.rsaEncrypt:if(i.bits<t.minRSABits)throw Error(`RSA keys shorter than ${t.minRSABits} bits are considered too weak.`);break;case $.publicKey.ecdsa:case $.publicKey.eddsaLegacy:case $.publicKey.ecdh:if(t.rejectCurves.has(i.curve))throw Error(`Support for ${i.algorithm} keys using curve ${i.curve} is disabled.`)}}class ch{constructor(e,t){this.userID=e.constructor.tag===$.packet.userID?e:null,this.userAttribute=e.constructor.tag===$.packet.userAttribute?e:null,this.selfCertifications=[],this.otherCertifications=[],this.revocationSignatures=[],this.mainKey=t;}toPacketList(){const e=new lu;return e.push(this.userID||this.userAttribute),e.push(...this.revocationSignatures),e.push(...this.selfCertifications),e.push(...this.otherCertifications),e}clone(){const e=new ch(this.userID||this.userAttribute,this.mainKey);return e.selfCertifications=[...this.selfCertifications],e.otherCertifications=[...this.otherCertifications],e.revocationSignatures=[...this.revocationSignatures],e}async certify(e,t,r){const i=this.mainKey.keyPacket,n={userID:this.userID,userAttribute:this.userAttribute,key:i},a=new ch(n.userID||n.userAttribute,this.mainKey);return a.otherCertifications=await Promise.all(e.map((async function(e){if(!e.isPrivate())throw Error("Need private key for signing");if(e.hasSameFingerprintAs(i))throw Error("The user's own key can only be used for self-certifications");const a=await e.getSigningKey(void 0,t,void 0,r);return Ju(n,e,a.keyPacket,{signatureType:$.signature.certGeneric,keyFlags:[$.keyFlags.certifyKeys|$.keyFlags.signData]},t,void 0,void 0,void 0,r)}))),await a.update(this,t,r),a}async isRevoked(e,t,r=new Date,i=ne){const n=this.mainKey.keyPacket;return th(n,$.signature.certRevocation,{key:n,userID:this.userID,userAttribute:this.userAttribute},this.revocationSignatures,e,t,r,i)}async verifyCertificate(e,t,r=new Date,i){const n=this,a=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:a},{issuerKeyID:o}=e,c=t.filter((e=>e.getKeys(o).length>0));return 0===c.length?null:(await Promise.all(c.map((async t=>{const a=await t.getSigningKey(o,e.created,void 0,i);if(e.revoked||await n.isRevoked(e,a.keyPacket,r,i))throw Error("User certificate is revoked");try{await e.verify(a.keyPacket,$.signature.certGeneric,s,r,void 0,i);}catch(e){throw X.wrapError("User certificate is invalid",e)}}))),!0)}async verifyAllCertifications(e,t=new Date,r){const i=this,n=this.selfCertifications.concat(this.otherCertifications);return Promise.all(n.map((async n=>({keyID:n.issuerKeyID,valid:await i.verifyCertificate(n,e,t,r).catch((()=>!1))}))))}async verify(e=new Date,t){if(!this.selfCertifications.length)throw Error("No self-certifications found");const r=this,i=this.mainKey.keyPacket,n={userID:this.userID,userAttribute:this.userAttribute,key:i};let a;for(let s=this.selfCertifications.length-1;s>=0;s--)try{const a=this.selfCertifications[s];if(a.revoked||await r.isRevoked(a,void 0,e,t))throw Error("Self-certification is revoked");try{await a.verify(i,$.signature.certGeneric,n,e,void 0,t);}catch(e){throw X.wrapError("Self-certification is invalid",e)}return !0}catch(e){a=e;}throw a}async update(e,t,r){const i=this.mainKey.keyPacket,n={userID:this.userID,userAttribute:this.userAttribute,key:i};await eh(e,this,"selfCertifications",t,(async function(e){try{return await e.verify(i,$.signature.certGeneric,n,t,!1,r),!0}catch(e){return !1}})),await eh(e,this,"otherCertifications",t),await eh(e,this,"revocationSignatures",t,(function(e){return th(i,$.signature.certRevocation,n,[e],void 0,void 0,t,r)}));}async revoke(e,{flag:t=$.reasonForRevocation.noReason,string:r=""}={},i=new Date,n=ne){const a={userID:this.userID,userAttribute:this.userAttribute,key:e},s=new ch(a.userID||a.userAttribute,this.mainKey);return s.revocationSignatures.push(await Ju(a,null,e,{signatureType:$.signature.certRevocation,reasonForRevocationFlag:$.write($.reasonForRevocation,t),reasonForRevocationString:r},i,void 0,void 0,!1,n)),await s.update(this),s}}class uh{constructor(e,t){this.keyPacket=e,this.bindingSignatures=[],this.revocationSignatures=[],this.mainKey=t;}toPacketList(){const e=new lu;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.bindingSignatures),e}clone(){const e=new uh(this.keyPacket,this.mainKey);return e.bindingSignatures=[...this.bindingSignatures],e.revocationSignatures=[...this.revocationSignatures],e}async isRevoked(e,t,r=new Date,i=ne){const n=this.mainKey.keyPacket;return th(n,$.signature.subkeyRevocation,{key:n,bind:this.keyPacket},this.revocationSignatures,e,t,r,i)}async verify(e=new Date,t=ne){const r=this.mainKey.keyPacket,i={key:r,bind:this.keyPacket},n=await $u(this.bindingSignatures,r,$.signature.subkeyBinding,i,e,t);if(n.revoked||await this.isRevoked(n,null,e,t))throw Error("Subkey is revoked");if(Zu(this.keyPacket,n,e))throw Error("Subkey is expired");return n}async getExpirationTime(e=new Date,t=ne){const r=this.mainKey.keyPacket,i={key:r,bind:this.keyPacket};let n;try{n=await $u(this.bindingSignatures,r,$.signature.subkeyBinding,i,e,t);}catch(e){return null}const a=rh(this.keyPacket,n),s=n.getExpirationTime();return a<s?a:s}async update(e,t=new Date,r=ne){const i=this.mainKey.keyPacket;if(!this.hasSameFingerprintAs(e))throw Error("Subkey update method: fingerprints of subkeys not equal");this.keyPacket.constructor.tag===$.packet.publicSubkey&&e.keyPacket.constructor.tag===$.packet.secretSubkey&&(this.keyPacket=e.keyPacket);const n=this,a={key:i,bind:n.keyPacket};await eh(e,this,"bindingSignatures",t,(async function(e){for(let t=0;t<n.bindingSignatures.length;t++)if(n.bindingSignatures[t].issuerKeyID.equals(e.issuerKeyID))return e.created>n.bindingSignatures[t].created&&(n.bindingSignatures[t]=e),!1;try{return await e.verify(i,$.signature.subkeyBinding,a,t,void 0,r),!0}catch(e){return !1}})),await eh(e,this,"revocationSignatures",t,(function(e){return th(i,$.signature.subkeyRevocation,a,[e],void 0,void 0,t,r)}));}async revoke(e,{flag:t=$.reasonForRevocation.noReason,string:r=""}={},i=new Date,n=ne){const a={key:e,bind:this.keyPacket},s=new uh(this.keyPacket,this.mainKey);return s.revocationSignatures.push(await Ju(a,null,e,{signatureType:$.signature.subkeyRevocation,reasonForRevocationFlag:$.write($.reasonForRevocation,t),reasonForRevocationString:r},i,void 0,void 0,!1,n)),await s.update(this),s}hasSameFingerprintAs(e){return this.keyPacket.hasSameFingerprintAs(e.keyPacket||e)}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","isDecrypted"].forEach((e=>{uh.prototype[e]=function(){return this.keyPacket[e]()};}));const hh=/*#__PURE__*/X.constructAllowedPackets([uu]),dh=new Set([$.packet.publicKey,$.packet.privateKey]),fh=new Set([$.packet.publicKey,$.packet.privateKey,$.packet.publicSubkey,$.packet.privateSubkey]);class lh{packetListToStructure(e,t=new Set){let r,i,n,a;for(const s of e){if(s instanceof mn){fh.has(s.tag)&&!a&&(a=dh.has(s.tag)?dh:fh);continue}const e=s.constructor.tag;if(a){if(!a.has(e))continue;a=null;}if(t.has(e))throw Error("Unexpected packet type: "+e);switch(e){case $.packet.publicKey:case $.packet.secretKey:if(this.keyPacket)throw Error("Key block contains multiple keys");if(this.keyPacket=s,i=this.getKeyID(),!i)throw Error("Missing Key ID");break;case $.packet.userID:case $.packet.userAttribute:r=new ch(s,this),this.users.push(r);break;case $.packet.publicSubkey:case $.packet.secretSubkey:r=null,n=new uh(s,this),this.subkeys.push(n);break;case $.packet.signature:switch(s.signatureType){case $.signature.certGeneric:case $.signature.certPersona:case $.signature.certCasual:case $.signature.certPositive:if(!r){X.printDebug("Dropping certification signatures without preceding user packet");continue}s.issuerKeyID.equals(i)?r.selfCertifications.push(s):r.otherCertifications.push(s);break;case $.signature.certRevocation:r?r.revocationSignatures.push(s):this.directSignatures.push(s);break;case $.signature.key:this.directSignatures.push(s);break;case $.signature.subkeyBinding:if(!n){X.printDebug("Dropping subkey binding signature without preceding subkey packet");continue}n.bindingSignatures.push(s);break;case $.signature.keyRevocation:this.revocationSignatures.push(s);break;case $.signature.subkeyRevocation:if(!n){X.printDebug("Dropping subkey revocation signature without preceding subkey packet");continue}n.revocationSignatures.push(s);}}}}toPacketList(){const e=new lu;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.directSignatures),this.users.map((t=>e.push(...t.toPacketList()))),this.subkeys.map((t=>e.push(...t.toPacketList()))),e}clone(e=!1){const t=new this.constructor(this.toPacketList());return e&&t.getKeys().forEach((e=>{if(e.keyPacket=Object.create(Object.getPrototypeOf(e.keyPacket),Object.getOwnPropertyDescriptors(e.keyPacket)),!e.keyPacket.isDecrypted())return;const t={};Object.keys(e.keyPacket.privateParams).forEach((r=>{t[r]=new Uint8Array(e.keyPacket.privateParams[r]);})),e.keyPacket.privateParams=t;})),t}getSubkeys(e=null){return this.subkeys.filter((t=>!e||t.getKeyID().equals(e,!0)))}getKeys(e=null){const t=[];return e&&!this.getKeyID().equals(e,!0)||t.push(this),t.concat(this.getSubkeys(e))}getKeyIDs(){return this.getKeys().map((e=>e.getKeyID()))}getUserIDs(){return this.users.map((e=>e.userID?e.userID.userID:null)).filter((e=>null!==e))}write(){return this.toPacketList().write()}async getSigningKey(e=null,t=new Date,r={},i=ne){await this.verifyPrimaryKey(t,r,i);const n=this.keyPacket,a=this.subkeys.slice().sort(((e,t)=>t.keyPacket.created-e.keyPacket.created));let s;for(const r of a)if(!e||r.getKeyID().equals(e))try{await r.verify(t,i);const e={key:n,bind:r.keyPacket},a=await $u(r.bindingSignatures,n,$.signature.subkeyBinding,e,t,i);if(!nh(r.keyPacket,a))continue;if(!a.embeddedSignature)throw Error("Missing embedded signature");return await $u([a.embeddedSignature],r.keyPacket,$.signature.keyBinding,e,t,i),oh(r.keyPacket,i),r}catch(e){s=e;}try{const a=await this.getPrimaryUser(t,r,i);if((!e||n.getKeyID().equals(e))&&nh(n,a.selfCertification))return oh(n,i),this}catch(e){s=e;}throw X.wrapError("Could not find valid signing key packet in key "+this.getKeyID().toHex(),s)}async getEncryptionKey(e,t=new Date,r={},i=ne){await this.verifyPrimaryKey(t,r,i);const n=this.keyPacket,a=this.subkeys.slice().sort(((e,t)=>t.keyPacket.created-e.keyPacket.created));let s;for(const r of a)if(!e||r.getKeyID().equals(e))try{await r.verify(t,i);const e={key:n,bind:r.keyPacket},a=await $u(r.bindingSignatures,n,$.signature.subkeyBinding,e,t,i);if(ah(r.keyPacket,a))return oh(r.keyPacket,i),r}catch(e){s=e;}try{const a=await this.getPrimaryUser(t,r,i);if((!e||n.getKeyID().equals(e))&&ah(n,a.selfCertification))return oh(n,i),this}catch(e){s=e;}throw X.wrapError("Could not find valid encryption key packet in key "+this.getKeyID().toHex(),s)}async isRevoked(e,t,r=new Date,i=ne){return th(this.keyPacket,$.signature.keyRevocation,{key:this.keyPacket},this.revocationSignatures,e,t,r,i)}async verifyPrimaryKey(e=new Date,t={},r=ne){const i=this.keyPacket;if(await this.isRevoked(null,null,e,r))throw Error("Primary key is revoked");const{selfCertification:n}=await this.getPrimaryUser(e,t,r);if(Zu(i,n,e))throw Error("Primary key is expired");const a=await $u(this.directSignatures,i,$.signature.key,{key:i},e,r).catch((()=>{}));if(a&&Zu(i,a,e))throw Error("Primary key is expired")}async getExpirationTime(e,t=ne){let r;try{const{selfCertification:i}=await this.getPrimaryUser(null,e,t),n=rh(this.keyPacket,i),a=i.getExpirationTime(),s=await $u(this.directSignatures,this.keyPacket,$.signature.key,{key:this.keyPacket},null,t).catch((()=>{}));if(s){const e=rh(this.keyPacket,s);r=Math.min(n,a,e);}else r=n<a?n:a;}catch(e){r=null;}return X.normalizeDate(r)}async getPrimaryUser(e=new Date,t={},r=ne){const i=this.keyPacket,n=[];let a;for(let s=0;s<this.users.length;s++)try{const a=this.users[s];if(!a.userID)continue;if(void 0!==t.name&&a.userID.name!==t.name||void 0!==t.email&&a.userID.email!==t.email||void 0!==t.comment&&a.userID.comment!==t.comment)throw Error("Could not find user that matches that user ID");const o={userID:a.userID,key:i},c=await $u(a.selfCertifications,i,$.signature.certGeneric,o,e,r);n.push({index:s,user:a,selfCertification:c});}catch(e){a=e;}if(!n.length)throw a||Error("Could not find primary user");await Promise.all(n.map((async function(t){return t.selfCertification.revoked||t.user.isRevoked(t.selfCertification,null,e,r)})));const s=n.sort((function(e,t){const r=e.selfCertification,i=t.selfCertification;return i.revoked-r.revoked||r.isPrimaryUserID-i.isPrimaryUserID||r.created-i.created})).pop(),{user:o,selfCertification:c}=s;if(c.revoked||await o.isRevoked(c,null,e,r))throw Error("Primary user is revoked");return s}async update(e,t=new Date,r=ne){if(!this.hasSameFingerprintAs(e))throw Error("Primary key fingerprints must be equal to update the key");if(!this.isPrivate()&&e.isPrivate()){if(!(this.subkeys.length===e.subkeys.length&&this.subkeys.every((t=>e.subkeys.some((e=>t.hasSameFingerprintAs(e)))))))throw Error("Cannot update public key with private key if subkeys mismatch");return e.update(this,r)}const i=this.clone();return await eh(e,i,"revocationSignatures",t,(n=>th(i.keyPacket,$.signature.keyRevocation,i,[n],null,e.keyPacket,t,r))),await eh(e,i,"directSignatures",t),await Promise.all(e.users.map((async e=>{const n=i.users.filter((t=>e.userID&&e.userID.equals(t.userID)||e.userAttribute&&e.userAttribute.equals(t.userAttribute)));if(n.length>0)await Promise.all(n.map((i=>i.update(e,t,r))));else {const t=e.clone();t.mainKey=i,i.users.push(t);}}))),await Promise.all(e.subkeys.map((async e=>{const n=i.subkeys.filter((t=>t.hasSameFingerprintAs(e)));if(n.length>0)await Promise.all(n.map((i=>i.update(e,t,r))));else {const t=e.clone();t.mainKey=i,i.subkeys.push(t);}}))),i}async getRevocationCertificate(e=new Date,t=ne){const r={key:this.keyPacket},i=await $u(this.revocationSignatures,this.keyPacket,$.signature.keyRevocation,r,e,t),n=new lu;return n.push(i),le($.armor.publicKey,n.write(),null,null,"This is a revocation certificate")}async applyRevocationCertificate(e,t=new Date,r=ne){const i=await fe(e,r),n=(await lu.fromBinary(i.data,hh,r)).findPacket($.packet.signature);if(!n||n.signatureType!==$.signature.keyRevocation)throw Error("Could not find revocation signature packet");if(!n.issuerKeyID.equals(this.getKeyID()))throw Error("Revocation signature does not match key");try{await n.verify(this.keyPacket,$.signature.keyRevocation,{key:this.keyPacket},t,void 0,r);}catch(e){throw X.wrapError("Could not verify revocation signature",e)}const a=this.clone();return a.revocationSignatures.push(n),a}async signPrimaryUser(e,t,r,i=ne){const{index:n,user:a}=await this.getPrimaryUser(t,r,i),s=await a.certify(e,t,i),o=this.clone();return o.users[n]=s,o}async signAllUsers(e,t=new Date,r=ne){const i=this.clone();return i.users=await Promise.all(this.users.map((function(i){return i.certify(e,t,r)}))),i}async verifyPrimaryUser(e,t=new Date,r,i=ne){const n=this.keyPacket,{user:a}=await this.getPrimaryUser(t,r,i);return e?await a.verifyAllCertifications(e,t,i):[{keyID:n.getKeyID(),valid:await a.verify(t,i).catch((()=>!1))}]}async verifyAllUsers(e,t=new Date,r=ne){const i=this.keyPacket,n=[];return await Promise.all(this.users.map((async a=>{const s=e?await a.verifyAllCertifications(e,t,r):[{keyID:i.getKeyID(),valid:await a.verify(t,r).catch((()=>!1))}];n.push(...s.map((e=>({userID:a.userID?a.userID.userID:null,userAttribute:a.userAttribute,keyID:e.keyID,valid:e.valid}))));}))),n}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","hasSameFingerprintAs"].forEach((e=>{lh.prototype[e]=uh.prototype[e];}));class ph extends lh{constructor(e){if(super(),this.keyPacket=null,this.revocationSignatures=[],this.directSignatures=[],this.users=[],this.subkeys=[],e&&(this.packetListToStructure(e,new Set([$.packet.secretKey,$.packet.secretSubkey])),!this.keyPacket))throw Error("Invalid key: missing public-key packet")}isPrivate(){return !1}toPublic(){return this}armor(e=ne){return le($.armor.publicKey,this.toPacketList().write(),void 0,void 0,void 0,e)}}class yh extends ph{constructor(e){if(super(),this.packetListToStructure(e,new Set([$.packet.publicKey,$.packet.publicSubkey])),!this.keyPacket)throw Error("Invalid key: missing private-key packet")}isPrivate(){return !0}toPublic(){const e=new lu,t=this.toPacketList();for(const r of t)switch(r.constructor.tag){case $.packet.secretKey:{const t=Du.fromSecretKeyPacket(r);e.push(t);break}case $.packet.secretSubkey:{const t=Bu.fromSecretSubkeyPacket(r);e.push(t);break}default:e.push(r);}return new ph(e)}armor(e=ne){return le($.armor.privateKey,this.toPacketList().write(),void 0,void 0,void 0,e)}async getDecryptionKeys(e,t=new Date,r={},i=ne){const n=this.keyPacket,a=[];for(let r=0;r<this.subkeys.length;r++)if(!e||this.subkeys[r].getKeyID().equals(e,!0))try{const e={key:n,bind:this.subkeys[r].keyPacket};sh(await $u(this.subkeys[r].bindingSignatures,n,$.signature.subkeyBinding,e,t,i),i)&&a.push(this.subkeys[r]);}catch(e){}const s=await this.getPrimaryUser(t,r,i);return e&&!n.getKeyID().equals(e,!0)||!sh(s.selfCertification,i)||a.push(this),a}isDecrypted(){return this.getKeys().some((({keyPacket:e})=>e.isDecrypted()))}async validate(e=ne){if(!this.isPrivate())throw Error("Cannot validate a public key");let t;if(this.keyPacket.isDummy()){const r=await this.getSigningKey(null,null,void 0,{...e,rejectPublicKeyAlgorithms:new Set,minRSABits:0});r&&!r.keyPacket.isDummy()&&(t=r.keyPacket);}else t=this.keyPacket;if(t)return t.validate();{const e=this.getKeys(),t=e.map((e=>e.keyPacket.isDummy())).every(Boolean);if(t)throw Error("Cannot validate an all-gnu-dummy key");return Promise.all(e.map((async e=>e.keyPacket.validate())))}}clearPrivateParams(){this.getKeys().forEach((({keyPacket:e})=>{e.isDecrypted()&&e.clearPrivateParams();}));}async revoke({flag:e=$.reasonForRevocation.noReason,string:t=""}={},r=new Date,i=ne){if(!this.isPrivate())throw Error("Need private key for revoking");const n={key:this.keyPacket},a=this.clone();return a.revocationSignatures.push(await Ju(n,null,this.keyPacket,{signatureType:$.signature.keyRevocation,reasonForRevocationFlag:$.write($.reasonForRevocation,e),reasonForRevocationString:t},r,void 0,void 0,void 0,i)),a}async addSubkey(e={}){const t={...ne,...e.config};if(e.passphrase)throw Error("Subkey could not be encrypted here, please encrypt whole key");if(e.rsaBits<t.minRSABits)throw Error(`rsaBits should be at least ${t.minRSABits}, got: ${e.rsaBits}`);const r=this.keyPacket;if(r.isDummy())throw Error("Cannot add subkey to gnu-dummy primary key");if(!r.isDecrypted())throw Error("Key is not decrypted");const i=r.getAlgorithmInfo();i.type=i.curve?"ecc":"rsa",i.rsaBits=i.bits||4096,i.curve=i.curve||"curve25519",e=ih(e,i);const n=await Gu(e);oh(n,t);const a=await Xu(n,r,e,t),s=this.toPacketList();return s.push(n,a),new yh(s)}}const bh=/*#__PURE__*/X.constructAllowedPackets([Du,Bu,zu,Lu,Ou,Tu,uu]);function mh(e){for(const t of e)switch(t.constructor.tag){case $.packet.secretKey:return new yh(e);case $.packet.publicKey:return new ph(e)}throw Error("No key packet found")}async function wh({armoredKey:e,binaryKey:t,config:r,...i}){if(r={...ne,...r},!e&&!t)throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");if(e&&!X.isString(e))throw Error("readKey: options.armoredKey must be a string");if(t&&!X.isUint8Array(t))throw Error("readKey: options.binaryKey must be a Uint8Array");const n=Object.keys(i);if(n.length>0)throw Error("Unknown option: "+n.join(", "));let a;if(e){const{type:t,data:i}=await fe(e,r);if(t!==$.armor.publicKey&&t!==$.armor.privateKey)throw Error("Armored text not of type key");a=i;}else a=t;return mh(await lu.fromBinary(a,bh,r))}Object.keys(ne).length;const rd="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function id$1(){}const nd="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0;function ad(e){return "object"==typeof e&&null!==e||"function"==typeof e}const sd=id$1,od=Promise,cd=Promise.prototype.then,ud=Promise.resolve.bind(od),hd=Promise.reject.bind(od);function dd(e){return new od(e)}function fd(e){return ud(e)}function ld(e){return hd(e)}function pd(e,t,r){return cd.call(e,t,r)}function yd(e,t,r){pd(pd(e,t,r),void 0,sd);}function bd(e,t){yd(e,t);}function md(e,t){yd(e,void 0,t);}function gd(e,t,r){return pd(e,t,r)}function wd(e){pd(e,void 0,sd);}const vd=(()=>{const e=nd&&nd.queueMicrotask;if("function"==typeof e)return e;const t=fd(void 0);return e=>pd(t,e)})();function _d(e,t,r){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}function kd(e,t,r){try{return fd(_d(e,t,r))}catch(e){return ld(e)}}class Ad{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0;}get length(){return this._size}push(e){const t=this._back;let r=t;16383===t._elements.length&&(r={_elements:[],_next:void 0}),t._elements.push(e),r!==t&&(this._back=r,t._next=r),++this._size;}shift(){const e=this._front;let t=e;const r=this._cursor;let i=r+1;const n=e._elements,a=n[r];return 16384===i&&(t=e._next,i=0),--this._size,this._cursor=i,e!==t&&(this._front=t),n[r]=void 0,a}forEach(e){let t=this._cursor,r=this._front,i=r._elements;for(;!(t===i.length&&void 0===r._next||t===i.length&&(r=r._next,i=r._elements,t=0,0===i.length));)e(i[t]),++t;}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}function Sd(e,t){e._ownerReadableStream=t,t._reader=e,"readable"===t._state?Md(e):"closed"===t._state?function(e){Md(e),Dd(e);}(e):Kd(e,t._storedError);}function Ed(e,t){return up(e._ownerReadableStream,t)}function Pd(e){"readable"===e._ownerReadableStream._state?Cd(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(e,t){Kd(e,t);}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0;}function xd(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Md(e){e._closedPromise=dd(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r;}));}function Kd(e,t){Md(e),Cd(e,t);}function Cd(e,t){void 0!==e._closedPromise_reject&&(wd(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0);}function Dd(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0);}const Ud=rd("[[AbortSteps]]"),Rd=rd("[[ErrorSteps]]"),Id=rd("[[CancelSteps]]"),Bd=rd("[[PullSteps]]"),Td=Number.isFinite||function(e){return "number"==typeof e&&isFinite(e)},zd=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function qd(e,t){if(void 0!==e&&("object"!=typeof(r=e)&&"function"!=typeof r))throw new TypeError(t+" is not an object.");var r;}function Fd(e,t){if("function"!=typeof e)throw new TypeError(t+" is not a function.")}function Od(e,t){if(!function(e){return "object"==typeof e&&null!==e||"function"==typeof e}(e))throw new TypeError(t+" is not an object.")}function Ld(e,t,r){if(void 0===e)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function Nd(e,t,r){if(void 0===e)throw new TypeError(`${t} is required in '${r}'.`)}function jd(e){return Number(e)}function Hd(e){return 0===e?0:e}function Wd(e,t){const r=Number.MAX_SAFE_INTEGER;let i=Number(e);if(i=Hd(i),!Td(i))throw new TypeError(t+" is not a finite number");if(i=function(e){return Hd(zd(e))}(i),i<0||i>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return Td(i)&&0!==i?i:0}function Gd(e,t){if(!op(e))throw new TypeError(t+" is not a ReadableStream.")}function Vd(e){return new Qd(e)}function $d(e,t){e._reader._readRequests.push(t);}function Zd(e,t,r){const i=e._reader._readRequests.shift();r?i._closeSteps():i._chunkSteps(t);}function Xd(e){return e._reader._readRequests.length}function Yd(e){const t=e._reader;return void 0!==t&&!!Jd(t)}class Qd{constructor(e){if(Ld(e,1,"ReadableStreamDefaultReader"),Gd(e,"First parameter"),cp(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Sd(this,e),this._readRequests=new Ad;}get closed(){return Jd(this)?this._closedPromise:ld(tf("closed"))}cancel(e=undefined){return Jd(this)?void 0===this._ownerReadableStream?ld(xd("cancel")):Ed(this,e):ld(tf("cancel"))}read(){if(!Jd(this))return ld(tf("read"));if(void 0===this._ownerReadableStream)return ld(xd("read from"));let e,t;const r=dd(((r,i)=>{e=r,t=i;}));return ef(this,{_chunkSteps:t=>e({value:t,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:e=>t(e)}),r}releaseLock(){if(!Jd(this))throw tf("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");Pd(this);}}}function Jd(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function ef(e,t){const r=e._ownerReadableStream;r._disturbed=!0,"closed"===r._state?t._closeSteps():"errored"===r._state?t._errorSteps(r._storedError):r._readableStreamController[Bd](t);}function tf(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}let rf;Object.defineProperties(Qd.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(Qd.prototype,rd.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0}),"symbol"==typeof rd.asyncIterator&&(rf={[rd.asyncIterator](){return this}},Object.defineProperty(rf,rd.asyncIterator,{enumerable:!1}));class nf{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t;}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?gd(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise?gd(this._ongoingPromise,t,t):t()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;if(void 0===e._ownerReadableStream)return ld(xd("iterate"));let t,r;const i=dd(((e,i)=>{t=e,r=i;}));return ef(e,{_chunkSteps:e=>{this._ongoingPromise=void 0,vd((()=>t({value:e,done:!1})));},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,Pd(e),t({value:void 0,done:!0});},_errorSteps:t=>{this._ongoingPromise=void 0,this._isFinished=!0,Pd(e),r(t);}}),i}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(void 0===t._ownerReadableStream)return ld(xd("finish iterating"));if(!this._preventCancel){const r=Ed(t,e);return Pd(t),gd(r,(()=>({value:e,done:!0})))}return Pd(t),fd({value:e,done:!0})}}const af={next(){return sf(this)?this._asyncIteratorImpl.next():ld(of("next"))},return(e){return sf(this)?this._asyncIteratorImpl.return(e):ld(of("return"))}};function sf(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl")}function of(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}void 0!==rf&&Object.setPrototypeOf(af,rf);const cf=Number.isNaN||function(e){return e!=e};function uf(e){return !!function(e){if("number"!=typeof e)return !1;if(cf(e))return !1;if(e<0)return !1;return !0}(e)&&e!==1/0}function hf(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function df(e,t,r){if(!uf(r=Number(r)))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:t,size:r}),e._queueTotalSize+=r;}function ff(e){e._queue=new Ad,e._queueTotalSize=0;}function lf(e){return e.slice()}class pf{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!mf(this))throw Rf("view");return this._view}respond(e){if(!mf(this))throw Rf("respond");if(Ld(e,1,"respond"),e=Wd(e,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");this._view.buffer,function(e,t){if(t=Number(t),!uf(t))throw new RangeError("bytesWritten must be a finite");xf(e,t);}(this._associatedReadableByteStreamController,e);}respondWithNewView(e){if(!mf(this))throw Rf("respondWithNewView");if(Ld(e,1,"respondWithNewView"),!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(0===e.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===e.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");!function(e,t){const r=e._pendingPullIntos.peek();if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(r.byteLength!==t.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");r.buffer=t.buffer,xf(e,t.byteLength);}(this._associatedReadableByteStreamController,e);}}Object.defineProperties(pf.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(pf.prototype,rd.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class yf{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!bf(this))throw If("byobRequest");if(null===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek(),t=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),r=Object.create(pf.prototype);!function(e,t,r){e._associatedReadableByteStreamController=t,e._view=r;}(r,this,t),this._byobRequest=r;}return this._byobRequest}get desiredSize(){if(!bf(this))throw If("desiredSize");return Df(this)}close(){if(!bf(this))throw If("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const t=e._controlledReadableByteStream;if(e._closeRequested||"readable"!==t._state)return;if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){if(e._pendingPullIntos.peek().bytesFilled>0){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Cf(e,t),t}}Kf(e),hp(t);}(this);}enqueue(e){if(!bf(this))throw If("enqueue");if(Ld(e,1,"enqueue"),!ArrayBuffer.isView(e))throw new TypeError("chunk must be an array buffer view");if(0===e.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===e.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const t=this._controlledReadableByteStream._state;if("readable"!==t)throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);!function(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||"readable"!==r._state)return;const i=t.buffer,n=t.byteOffset,a=t.byteLength,s=i;if(Yd(r))if(0===Xd(r))_f(e,s,n,a);else {Zd(r,new Uint8Array(s,n,a),!1);}else zf(r)?(_f(e,s,n,a),Pf(e)):_f(e,s,n,a);gf(e);}(this,e);}error(e=undefined){if(!bf(this))throw If("error");Cf(this,e);}[Id](e){if(this._pendingPullIntos.length>0){this._pendingPullIntos.peek().bytesFilled=0;}ff(this);const t=this._cancelAlgorithm(e);return Kf(this),t}[Bd](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0){const t=this._queue.shift();this._queueTotalSize-=t.byteLength,Sf(this);const r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);return void e._chunkSteps(r)}const r=this._autoAllocateChunkSize;if(void 0!==r){let t;try{t=new ArrayBuffer(r);}catch(t){return void e._errorSteps(t)}const i={buffer:t,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(i);}$d(t,e),gf(this);}}function bf(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function mf(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function gf(e){const t=function(e){const t=e._controlledReadableByteStream;if("readable"!==t._state)return !1;if(e._closeRequested)return !1;if(!e._started)return !1;if(Yd(t)&&Xd(t)>0)return !0;if(zf(t)&&Tf(t)>0)return !0;const r=Df(e);if(r>0)return !0;return !1}(e);if(!t)return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;yd(e._pullAlgorithm(),(()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,gf(e));}),(t=>{Cf(e,t);}));}function wf(e,t){let r=!1;"closed"===e._state&&(r=!0);const i=vf(t);"default"===t.readerType?Zd(e,i,r):function(e,t,r){const i=e._reader,n=i._readIntoRequests.shift();r?n._closeSteps(t):n._chunkSteps(t);}(e,i,r);}function vf(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function _f(e,t,r,i){e._queue.push({buffer:t,byteOffset:r,byteLength:i}),e._queueTotalSize+=i;}function kf(e,t){const r=t.elementSize,i=t.bytesFilled-t.bytesFilled%r,n=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),a=t.bytesFilled+n,s=a-a%r;let o=n,c=!1;s>i&&(o=s-t.bytesFilled,c=!0);const u=e._queue;for(;o>0;){const r=u.peek(),i=Math.min(o,r.byteLength),n=t.byteOffset+t.bytesFilled;h=t.buffer,d=n,f=r.buffer,l=r.byteOffset,p=i,new Uint8Array(h).set(new Uint8Array(f,l,p),d),r.byteLength===i?u.shift():(r.byteOffset+=i,r.byteLength-=i),e._queueTotalSize-=i,Af(e,i,t),o-=i;}var h,d,f,l,p;return c}function Af(e,t,r){Ef(e),r.bytesFilled+=t;}function Sf(e){0===e._queueTotalSize&&e._closeRequested?(Kf(e),hp(e._controlledReadableByteStream)):gf(e);}function Ef(e){null!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null);}function Pf(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const t=e._pendingPullIntos.peek();kf(e,t)&&(Mf(e),wf(e._controlledReadableByteStream,t));}}function xf(e,t){const r=e._pendingPullIntos.peek();if("closed"===e._controlledReadableByteStream._state){if(0!==t)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(e,t){t.buffer=t.buffer;const r=e._controlledReadableByteStream;if(zf(r))for(;Tf(r)>0;)wf(r,Mf(e));}(e,r);}else !function(e,t,r){if(r.bytesFilled+t>r.byteLength)throw new RangeError("bytesWritten out of range");if(Af(e,t,r),r.bytesFilled<r.elementSize)return;Mf(e);const i=r.bytesFilled%r.elementSize;if(i>0){const t=r.byteOffset+r.bytesFilled,n=r.buffer.slice(t-i,t);_f(e,n,0,n.byteLength);}r.buffer=r.buffer,r.bytesFilled-=i,wf(e._controlledReadableByteStream,r),Pf(e);}(e,t,r);gf(e);}function Mf(e){const t=e._pendingPullIntos.shift();return Ef(e),t}function Kf(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0;}function Cf(e,t){const r=e._controlledReadableByteStream;"readable"===r._state&&(!function(e){Ef(e),e._pendingPullIntos=new Ad;}(e),ff(e),Kf(e),dp(r,t));}function Df(e){const t=e._controlledReadableByteStream._state;return "errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function Uf(e,t,r){const i=Object.create(yf.prototype);let n=()=>{},a=()=>fd(void 0),s=()=>fd(void 0);void 0!==t.start&&(n=()=>t.start(i)),void 0!==t.pull&&(a=()=>t.pull(i)),void 0!==t.cancel&&(s=e=>t.cancel(e));const o=t.autoAllocateChunkSize;if(0===o)throw new TypeError("autoAllocateChunkSize must be greater than 0");!function(e,t,r,i,n,a,s){t._controlledReadableByteStream=e,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,ff(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=a,t._pullAlgorithm=i,t._cancelAlgorithm=n,t._autoAllocateChunkSize=s,t._pendingPullIntos=new Ad,e._readableStreamController=t,yd(fd(r()),(()=>{t._started=!0,gf(t);}),(e=>{Cf(t,e);}));}(e,i,n,a,s,r,o);}function Rf(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function If(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function Bf(e,t){e._reader._readIntoRequests.push(t);}function Tf(e){return e._reader._readIntoRequests.length}function zf(e){const t=e._reader;return void 0!==t&&!!Ff(t)}Object.defineProperties(yf.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(yf.prototype,rd.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class qf{constructor(e){if(Ld(e,1,"ReadableStreamBYOBReader"),Gd(e,"First parameter"),cp(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!bf(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Sd(this,e),this._readIntoRequests=new Ad;}get closed(){return Ff(this)?this._closedPromise:ld(Of("closed"))}cancel(e=undefined){return Ff(this)?void 0===this._ownerReadableStream?ld(xd("cancel")):Ed(this,e):ld(Of("cancel"))}read(e){if(!Ff(this))return ld(Of("read"));if(!ArrayBuffer.isView(e))return ld(new TypeError("view must be an array buffer view"));if(0===e.byteLength)return ld(new TypeError("view must have non-zero byteLength"));if(0===e.buffer.byteLength)return ld(new TypeError("view's buffer must have non-zero byteLength"));if(void 0===this._ownerReadableStream)return ld(xd("read from"));let t,r;const i=dd(((e,i)=>{t=e,r=i;}));return function(e,t,r){const i=e._ownerReadableStream;i._disturbed=!0,"errored"===i._state?r._errorSteps(i._storedError):function(e,t,r){const i=e._controlledReadableByteStream;let n=1;t.constructor!==DataView&&(n=t.constructor.BYTES_PER_ELEMENT);const a=t.constructor,s={buffer:t.buffer,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:n,viewConstructor:a,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(s),void Bf(i,r);if("closed"!==i._state){if(e._queueTotalSize>0){if(kf(e,s)){const t=vf(s);return Sf(e),void r._chunkSteps(t)}if(e._closeRequested){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");return Cf(e,t),void r._errorSteps(t)}}e._pendingPullIntos.push(s),Bf(i,r),gf(e);}else {const e=new a(s.buffer,s.byteOffset,0);r._closeSteps(e);}}(i._readableStreamController,t,r);}(this,e,{_chunkSteps:e=>t({value:e,done:!1}),_closeSteps:e=>t({value:e,done:!0}),_errorSteps:e=>r(e)}),i}releaseLock(){if(!Ff(this))throw Of("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");Pd(this);}}}function Ff(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function Of(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Lf(e,t){const{highWaterMark:r}=e;if(void 0===r)return t;if(cf(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}function Nf(e){const{size:t}=e;return t||(()=>1)}function jf(e,t){qd(e,t);const r=null==e?void 0:e.highWaterMark,i=null==e?void 0:e.size;return {highWaterMark:void 0===r?void 0:jd(r),size:void 0===i?void 0:Hf(i,t+" has member 'size' that")}}function Hf(e,t){return Fd(e,t),t=>jd(e(t))}function Wf(e,t,r){return Fd(e,r),r=>kd(e,t,[r])}function Gf(e,t,r){return Fd(e,r),()=>kd(e,t,[])}function Vf(e,t,r){return Fd(e,r),r=>_d(e,t,[r])}function $f(e,t,r){return Fd(e,r),(r,i)=>kd(e,t,[r,i])}function Zf(e,t){if(!Jf(e))throw new TypeError(t+" is not a WritableStream.")}Object.defineProperties(qf.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(qf.prototype,rd.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class Xf{constructor(e={},t={}){void 0===e?e=null:Od(e,"First parameter");const r=jf(t,"Second parameter"),i=function(e,t){qd(e,t);const r=null==e?void 0:e.abort,i=null==e?void 0:e.close,n=null==e?void 0:e.start,a=null==e?void 0:e.type,s=null==e?void 0:e.write;return {abort:void 0===r?void 0:Wf(r,e,t+" has member 'abort' that"),close:void 0===i?void 0:Gf(i,e,t+" has member 'close' that"),start:void 0===n?void 0:Vf(n,e,t+" has member 'start' that"),write:void 0===s?void 0:$f(s,e,t+" has member 'write' that"),type:a}}(e,"First parameter");Qf(this);if(void 0!==i.type)throw new RangeError("Invalid type is specified");const n=Nf(r);!function(e,t,r,i){const n=Object.create(ml.prototype);let a=()=>{},s=()=>fd(void 0),o=()=>fd(void 0),c=()=>fd(void 0);void 0!==t.start&&(a=()=>t.start(n));void 0!==t.write&&(s=e=>t.write(e,n));void 0!==t.close&&(o=()=>t.close());void 0!==t.abort&&(c=e=>t.abort(e));gl(e,n,a,s,o,c,r,i);}(this,i,Lf(r,1),n);}get locked(){if(!Jf(this))throw El("locked");return el(this)}abort(e=undefined){return Jf(this)?el(this)?ld(new TypeError("Cannot abort a stream that already has a writer")):tl(this,e):ld(El("abort"))}close(){return Jf(this)?el(this)?ld(new TypeError("Cannot close a stream that already has a writer")):sl(this)?ld(new TypeError("Cannot close an already-closing stream")):rl(this):ld(El("close"))}getWriter(){if(!Jf(this))throw El("getWriter");return Yf(this)}}function Yf(e){return new ul(e)}function Qf(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new Ad,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1;}function Jf(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function el(e){return void 0!==e._writer}function tl(e,t){const r=e._state;if("closed"===r||"errored"===r)return fd(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let i=!1;"erroring"===r&&(i=!0,t=void 0);const n=dd(((r,n)=>{e._pendingAbortRequest={_promise:void 0,_resolve:r,_reject:n,_reason:t,_wasAlreadyErroring:i};}));return e._pendingAbortRequest._promise=n,i||nl(e,t),n}function rl(e){const t=e._state;if("closed"===t||"errored"===t)return ld(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=dd(((t,r)=>{const i={_resolve:t,_reject:r};e._closeRequest=i;})),i=e._writer;var n;return void 0!==i&&e._backpressure&&"writable"===t&&Tl(i),df(n=e._writableStreamController,bl,0),_l(n),r}function il(e,t){"writable"!==e._state?al(e):nl(e,t);}function nl(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const i=e._writer;void 0!==i&&ll(i,t),!function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return !1;return !0}(e)&&r._started&&al(e);}function al(e){e._state="errored",e._writableStreamController[Rd]();const t=e._storedError;if(e._writeRequests.forEach((e=>{e._reject(t);})),e._writeRequests=new Ad,void 0===e._pendingAbortRequest)return void ol(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void ol(e);yd(e._writableStreamController[Ud](r._reason),(()=>{r._resolve(),ol(e);}),(t=>{r._reject(t),ol(e);}));}function sl(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function ol(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;void 0!==t&&Cl(t,e._storedError);}function cl(e,t){const r=e._writer;void 0!==r&&t!==e._backpressure&&(t?function(e){Ul(e);}(r):Tl(r)),e._backpressure=t;}Object.defineProperties(Xf.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(Xf.prototype,rd.toStringTag,{value:"WritableStream",configurable:!0});class ul{constructor(e){if(Ld(e,1,"WritableStreamDefaultWriter"),Zf(e,"First parameter"),el(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const t=e._state;if("writable"===t)!sl(e)&&e._backpressure?Ul(this):Il(this),Ml(this);else if("erroring"===t)Rl(this,e._storedError),Ml(this);else if("closed"===t)Il(this),Ml(r=this),Dl(r);else {const t=e._storedError;Rl(this,t),Kl(this,t);}var r;}get closed(){return hl(this)?this._closedPromise:ld(Pl("closed"))}get desiredSize(){if(!hl(this))throw Pl("desiredSize");if(void 0===this._ownerWritableStream)throw xl("desiredSize");return function(e){const t=e._ownerWritableStream,r=t._state;if("errored"===r||"erroring"===r)return null;if("closed"===r)return 0;return vl(t._writableStreamController)}(this)}get ready(){return hl(this)?this._readyPromise:ld(Pl("ready"))}abort(e=undefined){return hl(this)?void 0===this._ownerWritableStream?ld(xl("abort")):function(e,t){const r=e._ownerWritableStream;return tl(r,t)}(this,e):ld(Pl("abort"))}close(){if(!hl(this))return ld(Pl("close"));const e=this._ownerWritableStream;return void 0===e?ld(xl("close")):sl(e)?ld(new TypeError("Cannot close an already-closing stream")):dl(this)}releaseLock(){if(!hl(this))throw Pl("releaseLock");void 0!==this._ownerWritableStream&&pl(this);}write(e=undefined){return hl(this)?void 0===this._ownerWritableStream?ld(xl("write to")):yl(this,e):ld(Pl("write"))}}function hl(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function dl(e){return rl(e._ownerWritableStream)}function fl(e,t){"pending"===e._closedPromiseState?Cl(e,t):function(e,t){Kl(e,t);}(e,t);}function ll(e,t){"pending"===e._readyPromiseState?Bl(e,t):function(e,t){Rl(e,t);}(e,t);}function pl(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");ll(e,r),fl(e,r),t._writer=void 0,e._ownerWritableStream=void 0;}function yl(e,t){const r=e._ownerWritableStream,i=r._writableStreamController,n=function(e,t){try{return e._strategySizeAlgorithm(t)}catch(t){return kl(e,t),1}}(i,t);if(r!==e._ownerWritableStream)return ld(xl("write to"));const a=r._state;if("errored"===a)return ld(r._storedError);if(sl(r)||"closed"===a)return ld(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return ld(r._storedError);const s=function(e){return dd(((t,r)=>{const i={_resolve:t,_reject:r};e._writeRequests.push(i);}))}(r);return function(e,t,r){try{df(e,t,r);}catch(t){return void kl(e,t)}const i=e._controlledWritableStream;if(!sl(i)&&"writable"===i._state){cl(i,Al(e));}_l(e);}(i,t,n),s}Object.defineProperties(ul.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(ul.prototype,rd.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const bl={};class ml{constructor(){throw new TypeError("Illegal constructor")}error(e=undefined){if(!function(e){if(!ad(e))return !1;if(!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream"))return !1;return !0}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&Sl(this,e);}[Ud](e){const t=this._abortAlgorithm(e);return wl(this),t}[Rd](){ff(this);}}function gl(e,t,r,i,n,a,s,o){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,ff(t),t._started=!1,t._strategySizeAlgorithm=o,t._strategyHWM=s,t._writeAlgorithm=i,t._closeAlgorithm=n,t._abortAlgorithm=a;const c=Al(t);cl(e,c);yd(fd(r()),(()=>{t._started=!0,_l(t);}),(r=>{t._started=!0,il(e,r);}));}function wl(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0;}function vl(e){return e._strategyHWM-e._queueTotalSize}function _l(e){const t=e._controlledWritableStream;if(!e._started)return;if(void 0!==t._inFlightWriteRequest)return;if("erroring"===t._state)return void al(t);if(0===e._queue.length)return;const r=e._queue.peek().value;r===bl?function(e){const t=e._controlledWritableStream;((function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0;}))(t),hf(e);const r=e._closeAlgorithm();wl(e),yd(r,(()=>{!function(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const t=e._writer;void 0!==t&&Dl(t);}(t);}),(e=>{!function(e,t){e._inFlightCloseRequest._reject(t),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(t),e._pendingAbortRequest=void 0),il(e,t);}(t,e);}));}(e):function(e,t){const r=e._controlledWritableStream;!function(e){e._inFlightWriteRequest=e._writeRequests.shift();}(r);const i=e._writeAlgorithm(t);yd(i,(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0;}(r);const t=r._state;if(hf(e),!sl(r)&&"writable"===t){const t=Al(e);cl(r,t);}_l(e);}),(t=>{"writable"===r._state&&wl(e),function(e,t){e._inFlightWriteRequest._reject(t),e._inFlightWriteRequest=void 0,il(e,t);}(r,t);}));}(e,r);}function kl(e,t){"writable"===e._controlledWritableStream._state&&Sl(e,t);}function Al(e){return vl(e)<=0}function Sl(e,t){const r=e._controlledWritableStream;wl(e),nl(r,t);}function El(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function Pl(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function xl(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function Ml(e){e._closedPromise=dd(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending";}));}function Kl(e,t){Ml(e),Cl(e,t);}function Cl(e,t){void 0!==e._closedPromise_reject&&(wd(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected");}function Dl(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved");}function Ul(e){e._readyPromise=dd(((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r;})),e._readyPromiseState="pending";}function Rl(e,t){Ul(e),Bl(e,t);}function Il(e){Ul(e),Tl(e);}function Bl(e,t){void 0!==e._readyPromise_reject&&(wd(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected");}function Tl(e){void 0!==e._readyPromise_resolve&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled");}Object.defineProperties(ml.prototype,{error:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(ml.prototype,rd.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const zl="undefined"!=typeof DOMException?DOMException:void 0;const ql=function(e){if("function"!=typeof e&&"object"!=typeof e)return !1;try{return new e,!0}catch(e){return !1}}(zl)?zl:function(){const e=function(e,t){this.message=e||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor);};return Object.defineProperty(e.prototype=Object.create(Error.prototype),"constructor",{value:e,writable:!0,configurable:!0}),e}();function Fl(e,t,r,i,n,a){const s=Vd(e),o=Yf(t);e._disturbed=!0;let c=!1,u=fd(void 0);return dd(((h,d)=>{let f;if(void 0!==a){if(f=()=>{const r=new ql("Aborted","AbortError"),a=[];i||a.push((()=>"writable"===t._state?tl(t,r):fd(void 0))),n||a.push((()=>"readable"===e._state?up(e,r):fd(void 0))),y((()=>Promise.all(a.map((e=>e())))),!0,r);},a.aborted)return void f();a.addEventListener("abort",f);}if(p(e,s._closedPromise,(e=>{i?b(!0,e):y((()=>tl(t,e)),!0,e);})),p(t,o._closedPromise,(t=>{n?b(!0,t):y((()=>up(e,t)),!0,t);})),function(e,t,r){"closed"===e._state?r():bd(t,r);}(e,s._closedPromise,(()=>{r?b():y((()=>function(e){const t=e._ownerWritableStream,r=t._state;return sl(t)||"closed"===r?fd(void 0):"errored"===r?ld(t._storedError):dl(e)}(o)));})),sl(t)||"closed"===t._state){const t=new TypeError("the destination writable stream closed before all data could be piped to it");n?b(!0,t):y((()=>up(e,t)),!0,t);}function l(){const e=u;return pd(u,(()=>e!==u?l():void 0))}function p(e,t,r){"errored"===e._state?r(e._storedError):md(t,r);}function y(e,r,i){function n(){yd(e(),(()=>m(r,i)),(e=>m(!0,e)));}c||(c=!0,"writable"!==t._state||sl(t)?n():bd(l(),n));}function b(e,r){c||(c=!0,"writable"!==t._state||sl(t)?m(e,r):bd(l(),(()=>m(e,r))));}function m(e,t){pl(o),Pd(s),void 0!==a&&a.removeEventListener("abort",f),e?d(t):h(void 0);}wd(dd(((e,t)=>{!function r(i){i?e():pd(c?fd(!0):pd(o._readyPromise,(()=>dd(((e,t)=>{ef(s,{_chunkSteps:t=>{u=pd(yl(o,t),void 0,id$1),e(!1);},_closeSteps:()=>e(!0),_errorSteps:t});})))),r,t);}(!1);})));}))}class Ol{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Ll(this))throw Yl("desiredSize");return $l(this)}close(){if(!Ll(this))throw Yl("close");if(!Zl(this))throw new TypeError("The stream is not in a state that permits close");Wl(this);}enqueue(e=undefined){if(!Ll(this))throw Yl("enqueue");if(!Zl(this))throw new TypeError("The stream is not in a state that permits enqueue");return Gl(this,e)}error(e=undefined){if(!Ll(this))throw Yl("error");Vl(this,e);}[Id](e){ff(this);const t=this._cancelAlgorithm(e);return Hl(this),t}[Bd](e){const t=this._controlledReadableStream;if(this._queue.length>0){const r=hf(this);this._closeRequested&&0===this._queue.length?(Hl(this),hp(t)):Nl(this),e._chunkSteps(r);}else $d(t,e),Nl(this);}}function Ll(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function Nl(e){if(!jl(e))return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;yd(e._pullAlgorithm(),(()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,Nl(e));}),(t=>{Vl(e,t);}));}function jl(e){const t=e._controlledReadableStream;if(!Zl(e))return !1;if(!e._started)return !1;if(cp(t)&&Xd(t)>0)return !0;return $l(e)>0}function Hl(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0;}function Wl(e){if(!Zl(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(Hl(e),hp(t));}function Gl(e,t){if(!Zl(e))return;const r=e._controlledReadableStream;if(cp(r)&&Xd(r)>0)Zd(r,t,!1);else {let r;try{r=e._strategySizeAlgorithm(t);}catch(t){throw Vl(e,t),t}try{df(e,t,r);}catch(t){throw Vl(e,t),t}}Nl(e);}function Vl(e,t){const r=e._controlledReadableStream;"readable"===r._state&&(ff(e),Hl(e),dp(r,t));}function $l(e){const t=e._controlledReadableStream._state;return "errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function Zl(e){const t=e._controlledReadableStream._state;return !e._closeRequested&&"readable"===t}function Xl(e,t,r,i,n,a,s){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,ff(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=s,t._strategyHWM=a,t._pullAlgorithm=i,t._cancelAlgorithm=n,e._readableStreamController=t;yd(fd(r()),(()=>{t._started=!0,Nl(t);}),(e=>{Vl(t,e);}));}function Yl(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Ql(e,t,r){return Fd(e,r),r=>kd(e,t,[r])}function Jl(e,t,r){return Fd(e,r),r=>kd(e,t,[r])}function ep(e,t,r){return Fd(e,r),r=>_d(e,t,[r])}function tp(e,t){if("bytes"!==(e=""+e))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function rp(e,t){if("byob"!==(e=""+e))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function ip(e,t){qd(e,t);const r=null==e?void 0:e.preventAbort,i=null==e?void 0:e.preventCancel,n=null==e?void 0:e.preventClose,a=null==e?void 0:e.signal;return void 0!==a&&function(e,t){if(!function(e){if("object"!=typeof e||null===e)return !1;try{return "boolean"==typeof e.aborted}catch(e){return !1}}(e))throw new TypeError(t+" is not an AbortSignal.")}(a,t+" has member 'signal' that"),{preventAbort:!!r,preventCancel:!!i,preventClose:!!n,signal:a}}Object.defineProperties(Ol.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(Ol.prototype,rd.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class np{constructor(e={},t={}){void 0===e?e=null:Od(e,"First parameter");const r=jf(t,"Second parameter"),i=function(e,t){qd(e,t);const r=e,i=null==r?void 0:r.autoAllocateChunkSize,n=null==r?void 0:r.cancel,a=null==r?void 0:r.pull,s=null==r?void 0:r.start,o=null==r?void 0:r.type;return {autoAllocateChunkSize:void 0===i?void 0:Wd(i,t+" has member 'autoAllocateChunkSize' that"),cancel:void 0===n?void 0:Ql(n,r,t+" has member 'cancel' that"),pull:void 0===a?void 0:Jl(a,r,t+" has member 'pull' that"),start:void 0===s?void 0:ep(s,r,t+" has member 'start' that"),type:void 0===o?void 0:tp(o,t+" has member 'type' that")}}(e,"First parameter");if(sp(this),"bytes"===i.type){if(void 0!==r.size)throw new RangeError("The strategy for a byte stream cannot have a size function");Uf(this,i,Lf(r,0));}else {const e=Nf(r);!function(e,t,r,i){const n=Object.create(Ol.prototype);let a=()=>{},s=()=>fd(void 0),o=()=>fd(void 0);void 0!==t.start&&(a=()=>t.start(n)),void 0!==t.pull&&(s=()=>t.pull(n)),void 0!==t.cancel&&(o=e=>t.cancel(e)),Xl(e,n,a,s,o,r,i);}(this,i,Lf(r,1),e);}}get locked(){if(!op(this))throw fp("locked");return cp(this)}cancel(e=undefined){return op(this)?cp(this)?ld(new TypeError("Cannot cancel a stream that already has a reader")):up(this,e):ld(fp("cancel"))}getReader(e=undefined){if(!op(this))throw fp("getReader");const t=function(e,t){qd(e,t);const r=null==e?void 0:e.mode;return {mode:void 0===r?void 0:rp(r,t+" has member 'mode' that")}}(e,"First parameter");return void 0===t.mode?Vd(this):function(e){return new qf(e)}(this)}pipeThrough(e,t={}){if(!op(this))throw fp("pipeThrough");Ld(e,1,"pipeThrough");const r=function(e,t){qd(e,t);const r=null==e?void 0:e.readable;Nd(r,"readable","ReadableWritablePair"),Gd(r,t+" has member 'readable' that");const i=null==e?void 0:e.writable;return Nd(i,"writable","ReadableWritablePair"),Zf(i,t+" has member 'writable' that"),{readable:r,writable:i}}(e,"First parameter"),i=ip(t,"Second parameter");if(cp(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(el(r.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return wd(Fl(this,r.writable,i.preventClose,i.preventAbort,i.preventCancel,i.signal)),r.readable}pipeTo(e,t={}){if(!op(this))return ld(fp("pipeTo"));if(void 0===e)return ld("Parameter 1 is required in 'pipeTo'.");if(!Jf(e))return ld(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let r;try{r=ip(t,"Second parameter");}catch(e){return ld(e)}return cp(this)?ld(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):el(e)?ld(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Fl(this,e,r.preventClose,r.preventAbort,r.preventCancel,r.signal)}tee(){if(!op(this))throw fp("tee");const e=function(e,t){const r=Vd(e);let i,n,a,s,o,c=!1,u=!1,h=!1;const d=dd((e=>{o=e;}));function f(){return c||(c=!0,ef(r,{_chunkSteps:e=>{vd((()=>{c=!1;const t=e,r=e;u||Gl(a._readableStreamController,t),h||Gl(s._readableStreamController,r);}));},_closeSteps:()=>{c=!1,u||Wl(a._readableStreamController),h||Wl(s._readableStreamController),u&&h||o(void 0);},_errorSteps:()=>{c=!1;}})),fd(void 0)}function l(){}return a=ap(l,f,(function(t){if(u=!0,i=t,h){const t=lf([i,n]),r=up(e,t);o(r);}return d})),s=ap(l,f,(function(t){if(h=!0,n=t,u){const t=lf([i,n]),r=up(e,t);o(r);}return d})),md(r._closedPromise,(e=>{Vl(a._readableStreamController,e),Vl(s._readableStreamController,e),u&&h||o(void 0);})),[a,s]}(this);return lf(e)}values(e=undefined){if(!op(this))throw fp("values");return function(e,t){const r=Vd(e),i=new nf(r,t),n=Object.create(af);return n._asyncIteratorImpl=i,n}(this,function(e,t){return qd(e,t),{preventCancel:!!(null==e?void 0:e.preventCancel)}}(e,"First parameter").preventCancel)}}function ap(e,t,r,i=1,n=(()=>1)){const a=Object.create(np.prototype);sp(a);return Xl(a,Object.create(Ol.prototype),e,t,r,i,n),a}function sp(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1;}function op(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function cp(e){return void 0!==e._reader}function up(e,t){if(e._disturbed=!0,"closed"===e._state)return fd(void 0);if("errored"===e._state)return ld(e._storedError);hp(e);return gd(e._readableStreamController[Id](t),id$1)}function hp(e){e._state="closed";const t=e._reader;void 0!==t&&(Dd(t),Jd(t)&&(t._readRequests.forEach((e=>{e._closeSteps();})),t._readRequests=new Ad));}function dp(e,t){e._state="errored",e._storedError=t;const r=e._reader;void 0!==r&&(Cd(r,t),Jd(r)?(r._readRequests.forEach((e=>{e._errorSteps(t);})),r._readRequests=new Ad):(r._readIntoRequests.forEach((e=>{e._errorSteps(t);})),r._readIntoRequests=new Ad));}function fp(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function lp(e,t){qd(e,t);const r=null==e?void 0:e.highWaterMark;return Nd(r,"highWaterMark","QueuingStrategyInit"),{highWaterMark:jd(r)}}Object.defineProperties(np.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(np.prototype,rd.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof rd.asyncIterator&&Object.defineProperty(np.prototype,rd.asyncIterator,{value:np.prototype.values,writable:!0,configurable:!0});const pp=function(e){return e.byteLength};class yp{constructor(e){Ld(e,1,"ByteLengthQueuingStrategy"),e=lp(e,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=e.highWaterMark;}get highWaterMark(){if(!mp(this))throw bp("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!mp(this))throw bp("size");return pp}}function bp(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function mp(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")}Object.defineProperties(yp.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(yp.prototype,rd.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const gp=function(){return 1};class wp{constructor(e){Ld(e,1,"CountQueuingStrategy"),e=lp(e,"First parameter"),this._countQueuingStrategyHighWaterMark=e.highWaterMark;}get highWaterMark(){if(!_p(this))throw vp("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!_p(this))throw vp("size");return gp}}function vp(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function _p(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")}function kp(e,t,r){return Fd(e,r),r=>kd(e,t,[r])}function Ap(e,t,r){return Fd(e,r),r=>_d(e,t,[r])}function Sp(e,t,r){return Fd(e,r),(r,i)=>kd(e,t,[r,i])}Object.defineProperties(wp.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(wp.prototype,rd.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class Ep{constructor(e={},t={},r={}){void 0===e&&(e=null);const i=jf(t,"Second parameter"),n=jf(r,"Third parameter"),a=function(e,t){qd(e,t);const r=null==e?void 0:e.flush,i=null==e?void 0:e.readableType,n=null==e?void 0:e.start,a=null==e?void 0:e.transform,s=null==e?void 0:e.writableType;return {flush:void 0===r?void 0:kp(r,e,t+" has member 'flush' that"),readableType:i,start:void 0===n?void 0:Ap(n,e,t+" has member 'start' that"),transform:void 0===a?void 0:Sp(a,e,t+" has member 'transform' that"),writableType:s}}(e,"First parameter");if(void 0!==a.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==a.writableType)throw new RangeError("Invalid writableType specified");const s=Lf(n,0),o=Nf(n),c=Lf(i,1),u=Nf(i);let h;!function(e,t,r,i,n,a){function s(){return t}function o(t){return function(e,t){const r=e._transformStreamController;if(e._backpressure){return gd(e._backpressureChangePromise,(()=>{const i=e._writable;if("erroring"===i._state)throw i._storedError;return Ip(r,t)}))}return Ip(r,t)}(e,t)}function c(t){return function(e,t){return xp(e,t),fd(void 0)}(e,t)}function u(){return function(e){const t=e._readable,r=e._transformStreamController,i=r._flushAlgorithm();return Up(r),gd(i,(()=>{if("errored"===t._state)throw t._storedError;Wl(t._readableStreamController);}),(r=>{throw xp(e,r),t._storedError}))}(e)}function h(){return function(e){return Kp(e,!1),e._backpressureChangePromise}(e)}function d(t){return Mp(e,t),fd(void 0)}e._writable=function(e,t,r,i,n=1,a=(()=>1)){const s=Object.create(Xf.prototype);return Qf(s),gl(s,Object.create(ml.prototype),e,t,r,i,n,a),s}(s,o,u,c,r,i),e._readable=ap(s,h,d,n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,Kp(e,!0),e._transformStreamController=void 0;}(this,dd((e=>{h=e;})),c,u,s,o),function(e,t){const r=Object.create(Cp.prototype);let i=e=>{try{return Rp(r,e),fd(void 0)}catch(e){return ld(e)}},n=()=>fd(void 0);void 0!==t.transform&&(i=e=>t.transform(e,r));void 0!==t.flush&&(n=()=>t.flush(r));!function(e,t,r,i){t._controlledTransformStream=e,e._transformStreamController=t,t._transformAlgorithm=r,t._flushAlgorithm=i;}(e,r,i,n);}(this,a),void 0!==a.start?h(a.start(this._transformStreamController)):h(void 0);}get readable(){if(!Pp(this))throw Tp("readable");return this._readable}get writable(){if(!Pp(this))throw Tp("writable");return this._writable}}function Pp(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function xp(e,t){Vl(e._readable._readableStreamController,t),Mp(e,t);}function Mp(e,t){Up(e._transformStreamController),kl(e._writable._writableStreamController,t),e._backpressure&&Kp(e,!1);}function Kp(e,t){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=dd((t=>{e._backpressureChangePromise_resolve=t;})),e._backpressure=t;}Object.defineProperties(Ep.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(Ep.prototype,rd.toStringTag,{value:"TransformStream",configurable:!0});class Cp{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Dp(this))throw Bp("desiredSize");return $l(this._controlledTransformStream._readable._readableStreamController)}enqueue(e=undefined){if(!Dp(this))throw Bp("enqueue");Rp(this,e);}error(e=undefined){if(!Dp(this))throw Bp("error");var t;t=e,xp(this._controlledTransformStream,t);}terminate(){if(!Dp(this))throw Bp("terminate");!function(e){const t=e._controlledTransformStream,r=t._readable._readableStreamController;Wl(r);Mp(t,new TypeError("TransformStream terminated"));}(this);}}function Dp(e){return !!ad(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function Up(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0;}function Rp(e,t){const r=e._controlledTransformStream,i=r._readable._readableStreamController;if(!Zl(i))throw new TypeError("Readable side is not in a state that permits enqueue");try{Gl(i,t);}catch(e){throw Mp(r,e),r._readable._storedError}const n=function(e){return !jl(e)}(i);n!==r._backpressure&&Kp(r,!0);}function Ip(e,t){return gd(e._transformAlgorithm(t),void 0,(t=>{throw xp(e._controlledTransformStream,t),t}))}function Bp(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function Tp(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(Cp.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof rd.toStringTag&&Object.defineProperty(Cp.prototype,rd.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});var qp=function(e,t){return qp=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);},qp(e,t)};
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function Fp(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+t+" is not a constructor or null");function r(){this.constructor=e;}qp(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}function Op(e){if(!e)throw new TypeError("Assertion failed")}function Lp(){}function Vp(e){try{return e.getReader({mode:"byob"}).releaseLock(),!0}catch(e){return !1}}var Xp=function(){function e(e){this._underlyingReader=void 0,this._readerMode=void 0,this._readableStreamController=void 0,this._pendingRead=void 0,this._underlyingStream=e,this._attachDefaultReader();}return e.prototype.start=function(e){this._readableStreamController=e;},e.prototype.cancel=function(e){return Op(void 0!==this._underlyingReader),this._underlyingReader.cancel(e)},e.prototype._attachDefaultReader=function(){if("default"!==this._readerMode){this._detachReader();var e=this._underlyingStream.getReader();this._readerMode="default",this._attachReader(e);}},e.prototype._attachReader=function(e){var t=this;Op(void 0===this._underlyingReader),this._underlyingReader=e;var r=this._underlyingReader.closed;r&&r.then((function(){return t._finishPendingRead()})).then((function(){e===t._underlyingReader&&t._readableStreamController.close();}),(function(r){e===t._underlyingReader&&t._readableStreamController.error(r);})).catch(Lp);},e.prototype._detachReader=function(){void 0!==this._underlyingReader&&(this._underlyingReader.releaseLock(),this._underlyingReader=void 0,this._readerMode=void 0);},e.prototype._pullWithDefaultReader=function(){var e=this;this._attachDefaultReader();var t=this._underlyingReader.read().then((function(t){var r=e._readableStreamController;t.done?e._tryClose():r.enqueue(t.value);}));return this._setPendingRead(t),t},e.prototype._tryClose=function(){try{this._readableStreamController.close();}catch(e){}},e.prototype._setPendingRead=function(e){var t,r=this,i=function(){r._pendingRead===t&&(r._pendingRead=void 0);};this._pendingRead=t=e.then(i,i);},e.prototype._finishPendingRead=function(){var e=this;if(this._pendingRead){var t=function(){return e._finishPendingRead()};return this._pendingRead.then(t,t)}},e}();(function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return Fp(t,e),t.prototype.pull=function(){return this._pullWithDefaultReader()},t})(Xp);function Qp(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}(function(e){function t(t){var r=this,i=Vp(t);return (r=e.call(this,t)||this)._supportsByob=i,r}return Fp(t,e),Object.defineProperty(t.prototype,"type",{get:function(){return "bytes"},enumerable:!1,configurable:!0}),t.prototype._attachByobReader=function(){if("byob"!==this._readerMode){Op(this._supportsByob),this._detachReader();var e=this._underlyingStream.getReader({mode:"byob"});this._readerMode="byob",this._attachReader(e);}},t.prototype.pull=function(){if(this._supportsByob){var e=this._readableStreamController.byobRequest;if(e)return this._pullWithByobRequest(e)}return this._pullWithDefaultReader()},t.prototype._pullWithByobRequest=function(e){var t=this;this._attachByobReader();var r=new Uint8Array(e.view.byteLength),i=this._underlyingReader.read(r).then((function(r){var i,n,a;t._readableStreamController,r.done?(t._tryClose(),e.respond(0)):(i=r.value,n=e.view,a=Qp(i),Qp(n).set(a,0),e.respond(r.value.byteLength));}));return this._setPendingRead(i),i},t})(Xp);var ay=it((function(e){!function(e,t){function r(e,t){if(!e)throw Error(t||"Assertion failed")}function i(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e;}function n(e,t,r){if(n.isBN(e))return e;this.negative=0,this.words=null,this.length=0,this.red=null,null!==e&&("le"!==t&&"be"!==t||(r=t,t=10),this._init(e||0,t||10,r||"be"));}var a;"object"==typeof e?e.exports=n:t.BN=n,n.BN=n,n.wordSize=26;try{a=void 0;}catch(e){}function s(e,t,r){for(var i=0,n=Math.min(e.length,r),a=t;a<n;a++){var s=e.charCodeAt(a)-48;i<<=4,i|=s>=49&&s<=54?s-49+10:s>=17&&s<=22?s-17+10:15&s;}return i}function o(e,t,r,i){for(var n=0,a=Math.min(e.length,r),s=t;s<a;s++){var o=e.charCodeAt(s)-48;n*=i,n+=o>=49?o-49+10:o>=17?o-17+10:o;}return n}n.isBN=function(e){return e instanceof n||null!==e&&"object"==typeof e&&e.constructor.wordSize===n.wordSize&&Array.isArray(e.words)},n.max=function(e,t){return e.cmp(t)>0?e:t},n.min=function(e,t){return e.cmp(t)<0?e:t},n.prototype._init=function(e,t,i){if("number"==typeof e)return this._initNumber(e,t,i);if("object"==typeof e)return this._initArray(e,t,i);"hex"===t&&(t=16),r(t===(0|t)&&t>=2&&t<=36);var n=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&n++,16===t?this._parseHex(e,n):this._parseBase(e,t,n),"-"===e[0]&&(this.negative=1),this.strip(),"le"===i&&this._initArray(this.toArray(),t,i);},n.prototype._initNumber=function(e,t,i){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(r(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===i&&this._initArray(this.toArray(),t,i);},n.prototype._initArray=function(e,t,i){if(r("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=Array(this.length);for(var n=0;n<this.length;n++)this.words[n]=0;var a,s,o=0;if("be"===i)for(n=e.length-1,a=0;n>=0;n-=3)s=e[n]|e[n-1]<<8|e[n-2]<<16,this.words[a]|=s<<o&67108863,this.words[a+1]=s>>>26-o&67108863,(o+=24)>=26&&(o-=26,a++);else if("le"===i)for(n=0,a=0;n<e.length;n+=3)s=e[n]|e[n+1]<<8|e[n+2]<<16,this.words[a]|=s<<o&67108863,this.words[a+1]=s>>>26-o&67108863,(o+=24)>=26&&(o-=26,a++);return this.strip()},n.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=Array(this.length);for(var r=0;r<this.length;r++)this.words[r]=0;var i,n,a=0;for(r=e.length-6,i=0;r>=t;r-=6)n=s(e,r,r+6),this.words[i]|=n<<a&67108863,this.words[i+1]|=n>>>26-a&4194303,(a+=24)>=26&&(a-=26,i++);r+6!==t&&(n=s(e,t,r+6),this.words[i]|=n<<a&67108863,this.words[i+1]|=n>>>26-a&4194303),this.strip();},n.prototype._parseBase=function(e,t,r){this.words=[0],this.length=1;for(var i=0,n=1;n<=67108863;n*=t)i++;i--,n=n/t|0;for(var a=e.length-r,s=a%i,c=Math.min(a,a-s)+r,u=0,h=r;h<c;h+=i)u=o(e,h,h+i,t),this.imuln(n),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u);if(0!==s){var d=1;for(u=o(e,h,e.length,t),h=0;h<s;h++)d*=t;this.imuln(d),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u);}},n.prototype.copy=function(e){e.words=Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red;},n.prototype.clone=function(){var e=new n(null);return this.copy(e),e},n.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},n.prototype.strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign()},n.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},n.prototype.inspect=function(){return (this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],u=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],h=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function d(e,t,r){r.negative=t.negative^e.negative;var i=e.length+t.length|0;r.length=i,i=i-1|0;var n=0|e.words[0],a=0|t.words[0],s=n*a,o=67108863&s,c=s/67108864|0;r.words[0]=o;for(var u=1;u<i;u++){for(var h=c>>>26,d=67108863&c,f=Math.min(u,t.length-1),l=Math.max(0,u-e.length+1);l<=f;l++){var p=u-l|0;h+=(s=(n=0|e.words[p])*(a=0|t.words[l])+d)/67108864|0,d=67108863&s;}r.words[u]=0|d,c=0|h;}return 0!==c?r.words[u]=0|c:r.length--,r.strip()}n.prototype.toString=function(e,t){var i;if(t=0|t||1,16===(e=e||10)||"hex"===e){i="";for(var n=0,a=0,s=0;s<this.length;s++){var o=this.words[s],d=(16777215&(o<<n|a)).toString(16);i=0!==(a=o>>>24-n&16777215)||s!==this.length-1?c[6-d.length]+d+i:d+i,(n+=2)>=26&&(n-=26,s--);}for(0!==a&&(i=a.toString(16)+i);i.length%t!=0;)i="0"+i;return 0!==this.negative&&(i="-"+i),i}if(e===(0|e)&&e>=2&&e<=36){var f=u[e],l=h[e];i="";var p=this.clone();for(p.negative=0;!p.isZero();){var y=p.modn(l).toString(e);i=(p=p.idivn(l)).isZero()?y+i:c[f-y.length]+y+i;}for(this.isZero()&&(i="0"+i);i.length%t!=0;)i="0"+i;return 0!==this.negative&&(i="-"+i),i}r(!1,"Base should be between 2 and 36");},n.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:this.length>2&&r(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},n.prototype.toJSON=function(){return this.toString(16)},n.prototype.toBuffer=function(e,t){return r(void 0!==a),this.toArrayLike(a,e,t)},n.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},n.prototype.toArrayLike=function(e,t,i){var n=this.byteLength(),a=i||Math.max(1,n);r(n<=a,"byte array longer than desired length"),r(a>0,"Requested array length <= 0"),this.strip();var s,o,c="le"===t,u=new e(a),h=this.clone();if(c){for(o=0;!h.isZero();o++)s=h.andln(255),h.iushrn(8),u[o]=s;for(;o<a;o++)u[o]=0;}else {for(o=0;o<a-n;o++)u[o]=0;for(o=0;!h.isZero();o++)s=h.andln(255),h.iushrn(8),u[a-o-1]=s;}return u},n.prototype._countBits=Math.clz32?function(e){return 32-Math.clz32(e)}:function(e){var t=e,r=0;return t>=4096&&(r+=13,t>>>=13),t>=64&&(r+=7,t>>>=7),t>=8&&(r+=4,t>>>=4),t>=2&&(r+=2,t>>>=2),r+t},n.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,r=0;return 0==(8191&t)&&(r+=13,t>>>=13),0==(127&t)&&(r+=7,t>>>=7),0==(15&t)&&(r+=4,t>>>=4),0==(3&t)&&(r+=2,t>>>=2),0==(1&t)&&r++,r},n.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},n.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var r=this._zeroBits(this.words[t]);if(e+=r,26!==r)break}return e},n.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},n.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},n.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},n.prototype.isNeg=function(){return 0!==this.negative},n.prototype.neg=function(){return this.clone().ineg()},n.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},n.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},n.prototype.ior=function(e){return r(0==(this.negative|e.negative)),this.iuor(e)},n.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},n.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},n.prototype.iuand=function(e){var t;t=this.length>e.length?e:this;for(var r=0;r<t.length;r++)this.words[r]=this.words[r]&e.words[r];return this.length=t.length,this.strip()},n.prototype.iand=function(e){return r(0==(this.negative|e.negative)),this.iuand(e)},n.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},n.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},n.prototype.iuxor=function(e){var t,r;this.length>e.length?(t=this,r=e):(t=e,r=this);for(var i=0;i<r.length;i++)this.words[i]=t.words[i]^r.words[i];if(this!==t)for(;i<t.length;i++)this.words[i]=t.words[i];return this.length=t.length,this.strip()},n.prototype.ixor=function(e){return r(0==(this.negative|e.negative)),this.iuxor(e)},n.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},n.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},n.prototype.inotn=function(e){r("number"==typeof e&&e>=0);var t=0|Math.ceil(e/26),i=e%26;this._expand(t),i>0&&t--;for(var n=0;n<t;n++)this.words[n]=67108863&~this.words[n];return i>0&&(this.words[n]=~this.words[n]&67108863>>26-i),this.strip()},n.prototype.notn=function(e){return this.clone().inotn(e)},n.prototype.setn=function(e,t){r("number"==typeof e&&e>=0);var i=e/26|0,n=e%26;return this._expand(i+1),this.words[i]=t?this.words[i]|1<<n:this.words[i]&~(1<<n),this.strip()},n.prototype.iadd=function(e){var t,r,i;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();this.length>e.length?(r=this,i=e):(r=e,i=this);for(var n=0,a=0;a<i.length;a++)t=(0|r.words[a])+(0|i.words[a])+n,this.words[a]=67108863&t,n=t>>>26;for(;0!==n&&a<r.length;a++)t=(0|r.words[a])+n,this.words[a]=67108863&t,n=t>>>26;if(this.length=r.length,0!==n)this.words[this.length]=n,this.length++;else if(r!==this)for(;a<r.length;a++)this.words[a]=r.words[a];return this},n.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},n.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var r,i,n=this.cmp(e);if(0===n)return this.negative=0,this.length=1,this.words[0]=0,this;n>0?(r=this,i=e):(r=e,i=this);for(var a=0,s=0;s<i.length;s++)a=(t=(0|r.words[s])-(0|i.words[s])+a)>>26,this.words[s]=67108863&t;for(;0!==a&&s<r.length;s++)a=(t=(0|r.words[s])+a)>>26,this.words[s]=67108863&t;if(0===a&&s<r.length&&r!==this)for(;s<r.length;s++)this.words[s]=r.words[s];return this.length=Math.max(this.length,s),r!==this&&(this.negative=1),this.strip()},n.prototype.sub=function(e){return this.clone().isub(e)};var f=function(e,t,r){var i,n,a,s=e.words,o=t.words,c=r.words,u=0,h=0|s[0],d=8191&h,f=h>>>13,l=0|s[1],p=8191&l,y=l>>>13,b=0|s[2],m=8191&b,g=b>>>13,w=0|s[3],v=8191&w,_=w>>>13,k=0|s[4],A=8191&k,S=k>>>13,E=0|s[5],P=8191&E,x=E>>>13,M=0|s[6],K=8191&M,C=M>>>13,D=0|s[7],U=8191&D,R=D>>>13,I=0|s[8],B=8191&I,T=I>>>13,z=0|s[9],q=8191&z,F=z>>>13,O=0|o[0],L=8191&O,N=O>>>13,j=0|o[1],H=8191&j,W=j>>>13,G=0|o[2],V=8191&G,$=G>>>13,Z=0|o[3],X=8191&Z,Y=Z>>>13,Q=0|o[4],J=8191&Q,ee=Q>>>13,te=0|o[5],re=8191&te,ie=te>>>13,ne=0|o[6],ae=8191&ne,se=ne>>>13,oe=0|o[7],ce=8191&oe,ue=oe>>>13,he=0|o[8],de=8191&he,fe=he>>>13,le=0|o[9],pe=8191&le,ye=le>>>13;r.negative=e.negative^t.negative,r.length=19;var be=(u+(i=Math.imul(d,L))|0)+((8191&(n=(n=Math.imul(d,N))+Math.imul(f,L)|0))<<13)|0;u=((a=Math.imul(f,N))+(n>>>13)|0)+(be>>>26)|0,be&=67108863,i=Math.imul(p,L),n=(n=Math.imul(p,N))+Math.imul(y,L)|0,a=Math.imul(y,N);var me=(u+(i=i+Math.imul(d,H)|0)|0)+((8191&(n=(n=n+Math.imul(d,W)|0)+Math.imul(f,H)|0))<<13)|0;u=((a=a+Math.imul(f,W)|0)+(n>>>13)|0)+(me>>>26)|0,me&=67108863,i=Math.imul(m,L),n=(n=Math.imul(m,N))+Math.imul(g,L)|0,a=Math.imul(g,N),i=i+Math.imul(p,H)|0,n=(n=n+Math.imul(p,W)|0)+Math.imul(y,H)|0,a=a+Math.imul(y,W)|0;var ge=(u+(i=i+Math.imul(d,V)|0)|0)+((8191&(n=(n=n+Math.imul(d,$)|0)+Math.imul(f,V)|0))<<13)|0;u=((a=a+Math.imul(f,$)|0)+(n>>>13)|0)+(ge>>>26)|0,ge&=67108863,i=Math.imul(v,L),n=(n=Math.imul(v,N))+Math.imul(_,L)|0,a=Math.imul(_,N),i=i+Math.imul(m,H)|0,n=(n=n+Math.imul(m,W)|0)+Math.imul(g,H)|0,a=a+Math.imul(g,W)|0,i=i+Math.imul(p,V)|0,n=(n=n+Math.imul(p,$)|0)+Math.imul(y,V)|0,a=a+Math.imul(y,$)|0;var we=(u+(i=i+Math.imul(d,X)|0)|0)+((8191&(n=(n=n+Math.imul(d,Y)|0)+Math.imul(f,X)|0))<<13)|0;u=((a=a+Math.imul(f,Y)|0)+(n>>>13)|0)+(we>>>26)|0,we&=67108863,i=Math.imul(A,L),n=(n=Math.imul(A,N))+Math.imul(S,L)|0,a=Math.imul(S,N),i=i+Math.imul(v,H)|0,n=(n=n+Math.imul(v,W)|0)+Math.imul(_,H)|0,a=a+Math.imul(_,W)|0,i=i+Math.imul(m,V)|0,n=(n=n+Math.imul(m,$)|0)+Math.imul(g,V)|0,a=a+Math.imul(g,$)|0,i=i+Math.imul(p,X)|0,n=(n=n+Math.imul(p,Y)|0)+Math.imul(y,X)|0,a=a+Math.imul(y,Y)|0;var ve=(u+(i=i+Math.imul(d,J)|0)|0)+((8191&(n=(n=n+Math.imul(d,ee)|0)+Math.imul(f,J)|0))<<13)|0;u=((a=a+Math.imul(f,ee)|0)+(n>>>13)|0)+(ve>>>26)|0,ve&=67108863,i=Math.imul(P,L),n=(n=Math.imul(P,N))+Math.imul(x,L)|0,a=Math.imul(x,N),i=i+Math.imul(A,H)|0,n=(n=n+Math.imul(A,W)|0)+Math.imul(S,H)|0,a=a+Math.imul(S,W)|0,i=i+Math.imul(v,V)|0,n=(n=n+Math.imul(v,$)|0)+Math.imul(_,V)|0,a=a+Math.imul(_,$)|0,i=i+Math.imul(m,X)|0,n=(n=n+Math.imul(m,Y)|0)+Math.imul(g,X)|0,a=a+Math.imul(g,Y)|0,i=i+Math.imul(p,J)|0,n=(n=n+Math.imul(p,ee)|0)+Math.imul(y,J)|0,a=a+Math.imul(y,ee)|0;var _e=(u+(i=i+Math.imul(d,re)|0)|0)+((8191&(n=(n=n+Math.imul(d,ie)|0)+Math.imul(f,re)|0))<<13)|0;u=((a=a+Math.imul(f,ie)|0)+(n>>>13)|0)+(_e>>>26)|0,_e&=67108863,i=Math.imul(K,L),n=(n=Math.imul(K,N))+Math.imul(C,L)|0,a=Math.imul(C,N),i=i+Math.imul(P,H)|0,n=(n=n+Math.imul(P,W)|0)+Math.imul(x,H)|0,a=a+Math.imul(x,W)|0,i=i+Math.imul(A,V)|0,n=(n=n+Math.imul(A,$)|0)+Math.imul(S,V)|0,a=a+Math.imul(S,$)|0,i=i+Math.imul(v,X)|0,n=(n=n+Math.imul(v,Y)|0)+Math.imul(_,X)|0,a=a+Math.imul(_,Y)|0,i=i+Math.imul(m,J)|0,n=(n=n+Math.imul(m,ee)|0)+Math.imul(g,J)|0,a=a+Math.imul(g,ee)|0,i=i+Math.imul(p,re)|0,n=(n=n+Math.imul(p,ie)|0)+Math.imul(y,re)|0,a=a+Math.imul(y,ie)|0;var ke=(u+(i=i+Math.imul(d,ae)|0)|0)+((8191&(n=(n=n+Math.imul(d,se)|0)+Math.imul(f,ae)|0))<<13)|0;u=((a=a+Math.imul(f,se)|0)+(n>>>13)|0)+(ke>>>26)|0,ke&=67108863,i=Math.imul(U,L),n=(n=Math.imul(U,N))+Math.imul(R,L)|0,a=Math.imul(R,N),i=i+Math.imul(K,H)|0,n=(n=n+Math.imul(K,W)|0)+Math.imul(C,H)|0,a=a+Math.imul(C,W)|0,i=i+Math.imul(P,V)|0,n=(n=n+Math.imul(P,$)|0)+Math.imul(x,V)|0,a=a+Math.imul(x,$)|0,i=i+Math.imul(A,X)|0,n=(n=n+Math.imul(A,Y)|0)+Math.imul(S,X)|0,a=a+Math.imul(S,Y)|0,i=i+Math.imul(v,J)|0,n=(n=n+Math.imul(v,ee)|0)+Math.imul(_,J)|0,a=a+Math.imul(_,ee)|0,i=i+Math.imul(m,re)|0,n=(n=n+Math.imul(m,ie)|0)+Math.imul(g,re)|0,a=a+Math.imul(g,ie)|0,i=i+Math.imul(p,ae)|0,n=(n=n+Math.imul(p,se)|0)+Math.imul(y,ae)|0,a=a+Math.imul(y,se)|0;var Ae=(u+(i=i+Math.imul(d,ce)|0)|0)+((8191&(n=(n=n+Math.imul(d,ue)|0)+Math.imul(f,ce)|0))<<13)|0;u=((a=a+Math.imul(f,ue)|0)+(n>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,i=Math.imul(B,L),n=(n=Math.imul(B,N))+Math.imul(T,L)|0,a=Math.imul(T,N),i=i+Math.imul(U,H)|0,n=(n=n+Math.imul(U,W)|0)+Math.imul(R,H)|0,a=a+Math.imul(R,W)|0,i=i+Math.imul(K,V)|0,n=(n=n+Math.imul(K,$)|0)+Math.imul(C,V)|0,a=a+Math.imul(C,$)|0,i=i+Math.imul(P,X)|0,n=(n=n+Math.imul(P,Y)|0)+Math.imul(x,X)|0,a=a+Math.imul(x,Y)|0,i=i+Math.imul(A,J)|0,n=(n=n+Math.imul(A,ee)|0)+Math.imul(S,J)|0,a=a+Math.imul(S,ee)|0,i=i+Math.imul(v,re)|0,n=(n=n+Math.imul(v,ie)|0)+Math.imul(_,re)|0,a=a+Math.imul(_,ie)|0,i=i+Math.imul(m,ae)|0,n=(n=n+Math.imul(m,se)|0)+Math.imul(g,ae)|0,a=a+Math.imul(g,se)|0,i=i+Math.imul(p,ce)|0,n=(n=n+Math.imul(p,ue)|0)+Math.imul(y,ce)|0,a=a+Math.imul(y,ue)|0;var Se=(u+(i=i+Math.imul(d,de)|0)|0)+((8191&(n=(n=n+Math.imul(d,fe)|0)+Math.imul(f,de)|0))<<13)|0;u=((a=a+Math.imul(f,fe)|0)+(n>>>13)|0)+(Se>>>26)|0,Se&=67108863,i=Math.imul(q,L),n=(n=Math.imul(q,N))+Math.imul(F,L)|0,a=Math.imul(F,N),i=i+Math.imul(B,H)|0,n=(n=n+Math.imul(B,W)|0)+Math.imul(T,H)|0,a=a+Math.imul(T,W)|0,i=i+Math.imul(U,V)|0,n=(n=n+Math.imul(U,$)|0)+Math.imul(R,V)|0,a=a+Math.imul(R,$)|0,i=i+Math.imul(K,X)|0,n=(n=n+Math.imul(K,Y)|0)+Math.imul(C,X)|0,a=a+Math.imul(C,Y)|0,i=i+Math.imul(P,J)|0,n=(n=n+Math.imul(P,ee)|0)+Math.imul(x,J)|0,a=a+Math.imul(x,ee)|0,i=i+Math.imul(A,re)|0,n=(n=n+Math.imul(A,ie)|0)+Math.imul(S,re)|0,a=a+Math.imul(S,ie)|0,i=i+Math.imul(v,ae)|0,n=(n=n+Math.imul(v,se)|0)+Math.imul(_,ae)|0,a=a+Math.imul(_,se)|0,i=i+Math.imul(m,ce)|0,n=(n=n+Math.imul(m,ue)|0)+Math.imul(g,ce)|0,a=a+Math.imul(g,ue)|0,i=i+Math.imul(p,de)|0,n=(n=n+Math.imul(p,fe)|0)+Math.imul(y,de)|0,a=a+Math.imul(y,fe)|0;var Ee=(u+(i=i+Math.imul(d,pe)|0)|0)+((8191&(n=(n=n+Math.imul(d,ye)|0)+Math.imul(f,pe)|0))<<13)|0;u=((a=a+Math.imul(f,ye)|0)+(n>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,i=Math.imul(q,H),n=(n=Math.imul(q,W))+Math.imul(F,H)|0,a=Math.imul(F,W),i=i+Math.imul(B,V)|0,n=(n=n+Math.imul(B,$)|0)+Math.imul(T,V)|0,a=a+Math.imul(T,$)|0,i=i+Math.imul(U,X)|0,n=(n=n+Math.imul(U,Y)|0)+Math.imul(R,X)|0,a=a+Math.imul(R,Y)|0,i=i+Math.imul(K,J)|0,n=(n=n+Math.imul(K,ee)|0)+Math.imul(C,J)|0,a=a+Math.imul(C,ee)|0,i=i+Math.imul(P,re)|0,n=(n=n+Math.imul(P,ie)|0)+Math.imul(x,re)|0,a=a+Math.imul(x,ie)|0,i=i+Math.imul(A,ae)|0,n=(n=n+Math.imul(A,se)|0)+Math.imul(S,ae)|0,a=a+Math.imul(S,se)|0,i=i+Math.imul(v,ce)|0,n=(n=n+Math.imul(v,ue)|0)+Math.imul(_,ce)|0,a=a+Math.imul(_,ue)|0,i=i+Math.imul(m,de)|0,n=(n=n+Math.imul(m,fe)|0)+Math.imul(g,de)|0,a=a+Math.imul(g,fe)|0;var Pe=(u+(i=i+Math.imul(p,pe)|0)|0)+((8191&(n=(n=n+Math.imul(p,ye)|0)+Math.imul(y,pe)|0))<<13)|0;u=((a=a+Math.imul(y,ye)|0)+(n>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,i=Math.imul(q,V),n=(n=Math.imul(q,$))+Math.imul(F,V)|0,a=Math.imul(F,$),i=i+Math.imul(B,X)|0,n=(n=n+Math.imul(B,Y)|0)+Math.imul(T,X)|0,a=a+Math.imul(T,Y)|0,i=i+Math.imul(U,J)|0,n=(n=n+Math.imul(U,ee)|0)+Math.imul(R,J)|0,a=a+Math.imul(R,ee)|0,i=i+Math.imul(K,re)|0,n=(n=n+Math.imul(K,ie)|0)+Math.imul(C,re)|0,a=a+Math.imul(C,ie)|0,i=i+Math.imul(P,ae)|0,n=(n=n+Math.imul(P,se)|0)+Math.imul(x,ae)|0,a=a+Math.imul(x,se)|0,i=i+Math.imul(A,ce)|0,n=(n=n+Math.imul(A,ue)|0)+Math.imul(S,ce)|0,a=a+Math.imul(S,ue)|0,i=i+Math.imul(v,de)|0,n=(n=n+Math.imul(v,fe)|0)+Math.imul(_,de)|0,a=a+Math.imul(_,fe)|0;var xe=(u+(i=i+Math.imul(m,pe)|0)|0)+((8191&(n=(n=n+Math.imul(m,ye)|0)+Math.imul(g,pe)|0))<<13)|0;u=((a=a+Math.imul(g,ye)|0)+(n>>>13)|0)+(xe>>>26)|0,xe&=67108863,i=Math.imul(q,X),n=(n=Math.imul(q,Y))+Math.imul(F,X)|0,a=Math.imul(F,Y),i=i+Math.imul(B,J)|0,n=(n=n+Math.imul(B,ee)|0)+Math.imul(T,J)|0,a=a+Math.imul(T,ee)|0,i=i+Math.imul(U,re)|0,n=(n=n+Math.imul(U,ie)|0)+Math.imul(R,re)|0,a=a+Math.imul(R,ie)|0,i=i+Math.imul(K,ae)|0,n=(n=n+Math.imul(K,se)|0)+Math.imul(C,ae)|0,a=a+Math.imul(C,se)|0,i=i+Math.imul(P,ce)|0,n=(n=n+Math.imul(P,ue)|0)+Math.imul(x,ce)|0,a=a+Math.imul(x,ue)|0,i=i+Math.imul(A,de)|0,n=(n=n+Math.imul(A,fe)|0)+Math.imul(S,de)|0,a=a+Math.imul(S,fe)|0;var Me=(u+(i=i+Math.imul(v,pe)|0)|0)+((8191&(n=(n=n+Math.imul(v,ye)|0)+Math.imul(_,pe)|0))<<13)|0;u=((a=a+Math.imul(_,ye)|0)+(n>>>13)|0)+(Me>>>26)|0,Me&=67108863,i=Math.imul(q,J),n=(n=Math.imul(q,ee))+Math.imul(F,J)|0,a=Math.imul(F,ee),i=i+Math.imul(B,re)|0,n=(n=n+Math.imul(B,ie)|0)+Math.imul(T,re)|0,a=a+Math.imul(T,ie)|0,i=i+Math.imul(U,ae)|0,n=(n=n+Math.imul(U,se)|0)+Math.imul(R,ae)|0,a=a+Math.imul(R,se)|0,i=i+Math.imul(K,ce)|0,n=(n=n+Math.imul(K,ue)|0)+Math.imul(C,ce)|0,a=a+Math.imul(C,ue)|0,i=i+Math.imul(P,de)|0,n=(n=n+Math.imul(P,fe)|0)+Math.imul(x,de)|0,a=a+Math.imul(x,fe)|0;var Ke=(u+(i=i+Math.imul(A,pe)|0)|0)+((8191&(n=(n=n+Math.imul(A,ye)|0)+Math.imul(S,pe)|0))<<13)|0;u=((a=a+Math.imul(S,ye)|0)+(n>>>13)|0)+(Ke>>>26)|0,Ke&=67108863,i=Math.imul(q,re),n=(n=Math.imul(q,ie))+Math.imul(F,re)|0,a=Math.imul(F,ie),i=i+Math.imul(B,ae)|0,n=(n=n+Math.imul(B,se)|0)+Math.imul(T,ae)|0,a=a+Math.imul(T,se)|0,i=i+Math.imul(U,ce)|0,n=(n=n+Math.imul(U,ue)|0)+Math.imul(R,ce)|0,a=a+Math.imul(R,ue)|0,i=i+Math.imul(K,de)|0,n=(n=n+Math.imul(K,fe)|0)+Math.imul(C,de)|0,a=a+Math.imul(C,fe)|0;var Ce=(u+(i=i+Math.imul(P,pe)|0)|0)+((8191&(n=(n=n+Math.imul(P,ye)|0)+Math.imul(x,pe)|0))<<13)|0;u=((a=a+Math.imul(x,ye)|0)+(n>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,i=Math.imul(q,ae),n=(n=Math.imul(q,se))+Math.imul(F,ae)|0,a=Math.imul(F,se),i=i+Math.imul(B,ce)|0,n=(n=n+Math.imul(B,ue)|0)+Math.imul(T,ce)|0,a=a+Math.imul(T,ue)|0,i=i+Math.imul(U,de)|0,n=(n=n+Math.imul(U,fe)|0)+Math.imul(R,de)|0,a=a+Math.imul(R,fe)|0;var De=(u+(i=i+Math.imul(K,pe)|0)|0)+((8191&(n=(n=n+Math.imul(K,ye)|0)+Math.imul(C,pe)|0))<<13)|0;u=((a=a+Math.imul(C,ye)|0)+(n>>>13)|0)+(De>>>26)|0,De&=67108863,i=Math.imul(q,ce),n=(n=Math.imul(q,ue))+Math.imul(F,ce)|0,a=Math.imul(F,ue),i=i+Math.imul(B,de)|0,n=(n=n+Math.imul(B,fe)|0)+Math.imul(T,de)|0,a=a+Math.imul(T,fe)|0;var Ue=(u+(i=i+Math.imul(U,pe)|0)|0)+((8191&(n=(n=n+Math.imul(U,ye)|0)+Math.imul(R,pe)|0))<<13)|0;u=((a=a+Math.imul(R,ye)|0)+(n>>>13)|0)+(Ue>>>26)|0,Ue&=67108863,i=Math.imul(q,de),n=(n=Math.imul(q,fe))+Math.imul(F,de)|0,a=Math.imul(F,fe);var Re=(u+(i=i+Math.imul(B,pe)|0)|0)+((8191&(n=(n=n+Math.imul(B,ye)|0)+Math.imul(T,pe)|0))<<13)|0;u=((a=a+Math.imul(T,ye)|0)+(n>>>13)|0)+(Re>>>26)|0,Re&=67108863;var Ie=(u+(i=Math.imul(q,pe))|0)+((8191&(n=(n=Math.imul(q,ye))+Math.imul(F,pe)|0))<<13)|0;return u=((a=Math.imul(F,ye))+(n>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,c[0]=be,c[1]=me,c[2]=ge,c[3]=we,c[4]=ve,c[5]=_e,c[6]=ke,c[7]=Ae,c[8]=Se,c[9]=Ee,c[10]=Pe,c[11]=xe,c[12]=Me,c[13]=Ke,c[14]=Ce,c[15]=De,c[16]=Ue,c[17]=Re,c[18]=Ie,0!==u&&(c[19]=u,r.length++),r};function l(e,t,r){return (new p).mulp(e,t,r)}function p(e,t){this.x=e,this.y=t;}Math.imul||(f=d),n.prototype.mulTo=function(e,t){var r,i=this.length+e.length;return r=10===this.length&&10===e.length?f(this,e,t):i<63?d(this,e,t):i<1024?function(e,t,r){r.negative=t.negative^e.negative,r.length=e.length+t.length;for(var i=0,n=0,a=0;a<r.length-1;a++){var s=n;n=0;for(var o=67108863&i,c=Math.min(a,t.length-1),u=Math.max(0,a-e.length+1);u<=c;u++){var h=a-u,d=(0|e.words[h])*(0|t.words[u]),f=67108863&d;o=67108863&(f=f+o|0),n+=(s=(s=s+(d/67108864|0)|0)+(f>>>26)|0)>>>26,s&=67108863;}r.words[a]=o,i=s,s=n;}return 0!==i?r.words[a]=i:r.length--,r.strip()}(this,e,t):l(this,e,t),r},p.prototype.makeRBT=function(e){for(var t=Array(e),r=n.prototype._countBits(e)-1,i=0;i<e;i++)t[i]=this.revBin(i,r,e);return t},p.prototype.revBin=function(e,t,r){if(0===e||e===r-1)return e;for(var i=0,n=0;n<t;n++)i|=(1&e)<<t-n-1,e>>=1;return i},p.prototype.permute=function(e,t,r,i,n,a){for(var s=0;s<a;s++)i[s]=t[e[s]],n[s]=r[e[s]];},p.prototype.transform=function(e,t,r,i,n,a){this.permute(a,e,t,r,i,n);for(var s=1;s<n;s<<=1)for(var o=s<<1,c=Math.cos(2*Math.PI/o),u=Math.sin(2*Math.PI/o),h=0;h<n;h+=o)for(var d=c,f=u,l=0;l<s;l++){var p=r[h+l],y=i[h+l],b=r[h+l+s],m=i[h+l+s],g=d*b-f*m;m=d*m+f*b,b=g,r[h+l]=p+b,i[h+l]=y+m,r[h+l+s]=p-b,i[h+l+s]=y-m,l!==o&&(g=c*d-u*f,f=c*f+u*d,d=g);}},p.prototype.guessLen13b=function(e,t){var r=1|Math.max(t,e),i=1&r,n=0;for(r=r/2|0;r;r>>>=1)n++;return 1<<n+1+i},p.prototype.conjugate=function(e,t,r){if(!(r<=1))for(var i=0;i<r/2;i++){var n=e[i];e[i]=e[r-i-1],e[r-i-1]=n,n=t[i],t[i]=-t[r-i-1],t[r-i-1]=-n;}},p.prototype.normalize13b=function(e,t){for(var r=0,i=0;i<t/2;i++){var n=8192*Math.round(e[2*i+1]/t)+Math.round(e[2*i]/t)+r;e[i]=67108863&n,r=n<67108864?0:n/67108864|0;}return e},p.prototype.convert13b=function(e,t,i,n){for(var a=0,s=0;s<t;s++)a+=0|e[s],i[2*s]=8191&a,a>>>=13,i[2*s+1]=8191&a,a>>>=13;for(s=2*t;s<n;++s)i[s]=0;r(0===a),r(0==(-8192&a));},p.prototype.stub=function(e){for(var t=Array(e),r=0;r<e;r++)t[r]=0;return t},p.prototype.mulp=function(e,t,r){var i=2*this.guessLen13b(e.length,t.length),n=this.makeRBT(i),a=this.stub(i),s=Array(i),o=Array(i),c=Array(i),u=Array(i),h=Array(i),d=Array(i),f=r.words;f.length=i,this.convert13b(e.words,e.length,s,i),this.convert13b(t.words,t.length,u,i),this.transform(s,a,o,c,i,n),this.transform(u,a,h,d,i,n);for(var l=0;l<i;l++){var p=o[l]*h[l]-c[l]*d[l];c[l]=o[l]*d[l]+c[l]*h[l],o[l]=p;}return this.conjugate(o,c,i),this.transform(o,c,f,a,i,n),this.conjugate(f,a,i),this.normalize13b(f,i),r.negative=e.negative^t.negative,r.length=e.length+t.length,r.strip()},n.prototype.mul=function(e){var t=new n(null);return t.words=Array(this.length+e.length),this.mulTo(e,t)},n.prototype.mulf=function(e){var t=new n(null);return t.words=Array(this.length+e.length),l(this,e,t)},n.prototype.imul=function(e){return this.clone().mulTo(e,this)},n.prototype.imuln=function(e){r("number"==typeof e),r(e<67108864);for(var t=0,i=0;i<this.length;i++){var n=(0|this.words[i])*e,a=(67108863&n)+(67108863&t);t>>=26,t+=n/67108864|0,t+=a>>>26,this.words[i]=67108863&a;}return 0!==t&&(this.words[i]=t,this.length++),this},n.prototype.muln=function(e){return this.clone().imuln(e)},n.prototype.sqr=function(){return this.mul(this)},n.prototype.isqr=function(){return this.imul(this.clone())},n.prototype.pow=function(e){var t=function(e){for(var t=Array(e.bitLength()),r=0;r<t.length;r++){var i=r/26|0,n=r%26;t[r]=(e.words[i]&1<<n)>>>n;}return t}(e);if(0===t.length)return new n(1);for(var r=this,i=0;i<t.length&&0===t[i];i++,r=r.sqr());if(++i<t.length)for(var a=r.sqr();i<t.length;i++,a=a.sqr())0!==t[i]&&(r=r.mul(a));return r},n.prototype.iushln=function(e){r("number"==typeof e&&e>=0);var t,i=e%26,n=(e-i)/26,a=67108863>>>26-i<<26-i;if(0!==i){var s=0;for(t=0;t<this.length;t++){var o=this.words[t]&a,c=(0|this.words[t])-o<<i;this.words[t]=c|s,s=o>>>26-i;}s&&(this.words[t]=s,this.length++);}if(0!==n){for(t=this.length-1;t>=0;t--)this.words[t+n]=this.words[t];for(t=0;t<n;t++)this.words[t]=0;this.length+=n;}return this.strip()},n.prototype.ishln=function(e){return r(0===this.negative),this.iushln(e)},n.prototype.iushrn=function(e,t,i){var n;r("number"==typeof e&&e>=0),n=t?(t-t%26)/26:0;var a=e%26,s=Math.min((e-a)/26,this.length),o=67108863^67108863>>>a<<a,c=i;if(n=Math.max(0,n-=s),c){for(var u=0;u<s;u++)c.words[u]=this.words[u];c.length=s;}if(0===s);else if(this.length>s)for(this.length-=s,u=0;u<this.length;u++)this.words[u]=this.words[u+s];else this.words[0]=0,this.length=1;var h=0;for(u=this.length-1;u>=0&&(0!==h||u>=n);u--){var d=0|this.words[u];this.words[u]=h<<26-a|d>>>a,h=d&o;}return c&&0!==h&&(c.words[c.length++]=h),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},n.prototype.ishrn=function(e,t,i){return r(0===this.negative),this.iushrn(e,t,i)},n.prototype.shln=function(e){return this.clone().ishln(e)},n.prototype.ushln=function(e){return this.clone().iushln(e)},n.prototype.shrn=function(e){return this.clone().ishrn(e)},n.prototype.ushrn=function(e){return this.clone().iushrn(e)},n.prototype.testn=function(e){r("number"==typeof e&&e>=0);var t=e%26,i=(e-t)/26,n=1<<t;return !(this.length<=i)&&!!(this.words[i]&n)},n.prototype.imaskn=function(e){r("number"==typeof e&&e>=0);var t=e%26,i=(e-t)/26;if(r(0===this.negative,"imaskn works only with positive numbers"),this.length<=i)return this;if(0!==t&&i++,this.length=Math.min(i,this.length),0!==t){var n=67108863^67108863>>>t<<t;this.words[this.length-1]&=n;}return this.strip()},n.prototype.maskn=function(e){return this.clone().imaskn(e)},n.prototype.iaddn=function(e){return r("number"==typeof e),r(e<67108864),e<0?this.isubn(-e):0!==this.negative?1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(e),this.negative=1,this):this._iaddn(e)},n.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&this.words[t]>=67108864;t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},n.prototype.isubn=function(e){if(r("number"==typeof e),r(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this.strip()},n.prototype.addn=function(e){return this.clone().iaddn(e)},n.prototype.subn=function(e){return this.clone().isubn(e)},n.prototype.iabs=function(){return this.negative=0,this},n.prototype.abs=function(){return this.clone().iabs()},n.prototype._ishlnsubmul=function(e,t,i){var n,a,s=e.length+i;this._expand(s);var o=0;for(n=0;n<e.length;n++){a=(0|this.words[n+i])+o;var c=(0|e.words[n])*t;o=((a-=67108863&c)>>26)-(c/67108864|0),this.words[n+i]=67108863&a;}for(;n<this.length-i;n++)o=(a=(0|this.words[n+i])+o)>>26,this.words[n+i]=67108863&a;if(0===o)return this.strip();for(r(-1===o),o=0,n=0;n<this.length;n++)o=(a=-(0|this.words[n])+o)>>26,this.words[n]=67108863&a;return this.negative=1,this.strip()},n.prototype._wordDiv=function(e,t){var r=(this.length,e.length),i=this.clone(),a=e,s=0|a.words[a.length-1];0!==(r=26-this._countBits(s))&&(a=a.ushln(r),i.iushln(r),s=0|a.words[a.length-1]);var o,c=i.length-a.length;if("mod"!==t){(o=new n(null)).length=c+1,o.words=Array(o.length);for(var u=0;u<o.length;u++)o.words[u]=0;}var h=i.clone()._ishlnsubmul(a,1,c);0===h.negative&&(i=h,o&&(o.words[c]=1));for(var d=c-1;d>=0;d--){var f=67108864*(0|i.words[a.length+d])+(0|i.words[a.length+d-1]);for(f=Math.min(f/s|0,67108863),i._ishlnsubmul(a,f,d);0!==i.negative;)f--,i.negative=0,i._ishlnsubmul(a,1,d),i.isZero()||(i.negative^=1);o&&(o.words[d]=f);}return o&&o.strip(),i.strip(),"div"!==t&&0!==r&&i.iushrn(r),{div:o||null,mod:i}},n.prototype.divmod=function(e,t,i){return r(!e.isZero()),this.isZero()?{div:new n(0),mod:new n(0)}:0!==this.negative&&0===e.negative?(o=this.neg().divmod(e,t),"mod"!==t&&(a=o.div.neg()),"div"!==t&&(s=o.mod.neg(),i&&0!==s.negative&&s.iadd(e)),{div:a,mod:s}):0===this.negative&&0!==e.negative?(o=this.divmod(e.neg(),t),"mod"!==t&&(a=o.div.neg()),{div:a,mod:o.mod}):0!=(this.negative&e.negative)?(o=this.neg().divmod(e.neg(),t),"div"!==t&&(s=o.mod.neg(),i&&0!==s.negative&&s.isub(e)),{div:o.div,mod:s}):e.length>this.length||this.cmp(e)<0?{div:new n(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new n(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new n(this.modn(e.words[0]))}:this._wordDiv(e,t);var a,s,o;},n.prototype.div=function(e){return this.divmod(e,"div",!1).div},n.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},n.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},n.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var r=0!==t.div.negative?t.mod.isub(e):t.mod,i=e.ushrn(1),n=e.andln(1),a=r.cmp(i);return a<0||1===n&&0===a?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},n.prototype.modn=function(e){r(e<=67108863);for(var t=(1<<26)%e,i=0,n=this.length-1;n>=0;n--)i=(t*i+(0|this.words[n]))%e;return i},n.prototype.idivn=function(e){r(e<=67108863);for(var t=0,i=this.length-1;i>=0;i--){var n=(0|this.words[i])+67108864*t;this.words[i]=n/e|0,t=n%e;}return this.strip()},n.prototype.divn=function(e){return this.clone().idivn(e)},n.prototype.egcd=function(e){r(0===e.negative),r(!e.isZero());var t=this,i=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var a=new n(1),s=new n(0),o=new n(0),c=new n(1),u=0;t.isEven()&&i.isEven();)t.iushrn(1),i.iushrn(1),++u;for(var h=i.clone(),d=t.clone();!t.isZero();){for(var f=0,l=1;0==(t.words[0]&l)&&f<26;++f,l<<=1);if(f>0)for(t.iushrn(f);f-- >0;)(a.isOdd()||s.isOdd())&&(a.iadd(h),s.isub(d)),a.iushrn(1),s.iushrn(1);for(var p=0,y=1;0==(i.words[0]&y)&&p<26;++p,y<<=1);if(p>0)for(i.iushrn(p);p-- >0;)(o.isOdd()||c.isOdd())&&(o.iadd(h),c.isub(d)),o.iushrn(1),c.iushrn(1);t.cmp(i)>=0?(t.isub(i),a.isub(o),s.isub(c)):(i.isub(t),o.isub(a),c.isub(s));}return {a:o,b:c,gcd:i.iushln(u)}},n.prototype._invmp=function(e){r(0===e.negative),r(!e.isZero());var t=this,i=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var a,s=new n(1),o=new n(0),c=i.clone();t.cmpn(1)>0&&i.cmpn(1)>0;){for(var u=0,h=1;0==(t.words[0]&h)&&u<26;++u,h<<=1);if(u>0)for(t.iushrn(u);u-- >0;)s.isOdd()&&s.iadd(c),s.iushrn(1);for(var d=0,f=1;0==(i.words[0]&f)&&d<26;++d,f<<=1);if(d>0)for(i.iushrn(d);d-- >0;)o.isOdd()&&o.iadd(c),o.iushrn(1);t.cmp(i)>=0?(t.isub(i),s.isub(o)):(i.isub(t),o.isub(s));}return (a=0===t.cmpn(1)?s:o).cmpn(0)<0&&a.iadd(e),a},n.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),r=e.clone();t.negative=0,r.negative=0;for(var i=0;t.isEven()&&r.isEven();i++)t.iushrn(1),r.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;r.isEven();)r.iushrn(1);var n=t.cmp(r);if(n<0){var a=t;t=r,r=a;}else if(0===n||0===r.cmpn(1))break;t.isub(r);}return r.iushln(i)},n.prototype.invm=function(e){return this.egcd(e).a.umod(e)},n.prototype.isEven=function(){return 0==(1&this.words[0])},n.prototype.isOdd=function(){return 1==(1&this.words[0])},n.prototype.andln=function(e){return this.words[0]&e},n.prototype.bincn=function(e){r("number"==typeof e);var t=e%26,i=(e-t)/26,n=1<<t;if(this.length<=i)return this._expand(i+1),this.words[i]|=n,this;for(var a=n,s=i;0!==a&&s<this.length;s++){var o=0|this.words[s];a=(o+=a)>>>26,o&=67108863,this.words[s]=o;}return 0!==a&&(this.words[s]=a,this.length++),this},n.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},n.prototype.cmpn=function(e){var t,i=e<0;if(0!==this.negative&&!i)return -1;if(0===this.negative&&i)return 1;if(this.strip(),this.length>1)t=1;else {i&&(e=-e),r(e<=67108863,"Number is too big");var n=0|this.words[0];t=n===e?0:n<e?-1:1;}return 0!==this.negative?0|-t:t},n.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return -1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},n.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return -1;for(var t=0,r=this.length-1;r>=0;r--){var i=0|this.words[r],n=0|e.words[r];if(i!==n){i<n?t=-1:i>n&&(t=1);break}}return t},n.prototype.gtn=function(e){return 1===this.cmpn(e)},n.prototype.gt=function(e){return 1===this.cmp(e)},n.prototype.gten=function(e){return this.cmpn(e)>=0},n.prototype.gte=function(e){return this.cmp(e)>=0},n.prototype.ltn=function(e){return -1===this.cmpn(e)},n.prototype.lt=function(e){return -1===this.cmp(e)},n.prototype.lten=function(e){return this.cmpn(e)<=0},n.prototype.lte=function(e){return this.cmp(e)<=0},n.prototype.eqn=function(e){return 0===this.cmpn(e)},n.prototype.eq=function(e){return 0===this.cmp(e)},n.red=function(e){return new _(e)},n.prototype.toRed=function(e){return r(!this.red,"Already a number in reduction context"),r(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},n.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},n.prototype._forceRed=function(e){return this.red=e,this},n.prototype.forceRed=function(e){return r(!this.red,"Already a number in reduction context"),this._forceRed(e)},n.prototype.redAdd=function(e){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},n.prototype.redIAdd=function(e){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},n.prototype.redSub=function(e){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},n.prototype.redISub=function(e){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},n.prototype.redShl=function(e){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},n.prototype.redMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},n.prototype.redIMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},n.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},n.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},n.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},n.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},n.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},n.prototype.redPow=function(e){return r(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var y={k256:null,p224:null,p192:null,p25519:null};function b(e,t){this.name=e,this.p=new n(t,16),this.n=this.p.bitLength(),this.k=new n(1).iushln(this.n).isub(this.p),this.tmp=this._tmp();}function m(){b.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");}function g(){b.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");}function w(){b.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");}function v(){b.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");}function _(e){if("string"==typeof e){var t=n._prime(e);this.m=t.p,this.prime=t;}else r(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null;}function k(e){_.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new n(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv);}b.prototype._tmp=function(){var e=new n(null);return e.words=Array(Math.ceil(this.n/13)),e},b.prototype.ireduce=function(e){var t,r=e;do{this.split(r,this.tmp),t=(r=(r=this.imulK(r)).iadd(this.tmp)).bitLength();}while(t>this.n);var i=t<this.n?-1:r.ucmp(this.p);return 0===i?(r.words[0]=0,r.length=1):i>0?r.isub(this.p):r.strip(),r},b.prototype.split=function(e,t){e.iushrn(this.n,0,t);},b.prototype.imulK=function(e){return e.imul(this.k)},i(m,b),m.prototype.split=function(e,t){for(var r=4194303,i=Math.min(e.length,9),n=0;n<i;n++)t.words[n]=e.words[n];if(t.length=i,e.length<=9)return e.words[0]=0,void(e.length=1);var a=e.words[9];for(t.words[t.length++]=a&r,n=10;n<e.length;n++){var s=0|e.words[n];e.words[n-10]=(s&r)<<4|a>>>22,a=s;}a>>>=22,e.words[n-10]=a,0===a&&e.length>10?e.length-=10:e.length-=9;},m.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,r=0;r<e.length;r++){var i=0|e.words[r];t+=977*i,e.words[r]=67108863&t,t=64*i+(t/67108864|0);}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},i(g,b),i(w,b),i(v,b),v.prototype.imulK=function(e){for(var t=0,r=0;r<e.length;r++){var i=19*(0|e.words[r])+t,n=67108863&i;i>>>=26,e.words[r]=n,t=i;}return 0!==t&&(e.words[e.length++]=t),e},n._prime=function(e){if(y[e])return y[e];var t;if("k256"===e)t=new m;else if("p224"===e)t=new g;else if("p192"===e)t=new w;else {if("p25519"!==e)throw Error("Unknown prime "+e);t=new v;}return y[e]=t,t},_.prototype._verify1=function(e){r(0===e.negative,"red works only with positives"),r(e.red,"red works only with red numbers");},_.prototype._verify2=function(e,t){r(0==(e.negative|t.negative),"red works only with positives"),r(e.red&&e.red===t.red,"red works only with red numbers");},_.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):e.umod(this.m)._forceRed(this)},_.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},_.prototype.add=function(e,t){this._verify2(e,t);var r=e.add(t);return r.cmp(this.m)>=0&&r.isub(this.m),r._forceRed(this)},_.prototype.iadd=function(e,t){this._verify2(e,t);var r=e.iadd(t);return r.cmp(this.m)>=0&&r.isub(this.m),r},_.prototype.sub=function(e,t){this._verify2(e,t);var r=e.sub(t);return r.cmpn(0)<0&&r.iadd(this.m),r._forceRed(this)},_.prototype.isub=function(e,t){this._verify2(e,t);var r=e.isub(t);return r.cmpn(0)<0&&r.iadd(this.m),r},_.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},_.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},_.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},_.prototype.isqr=function(e){return this.imul(e,e.clone())},_.prototype.sqr=function(e){return this.mul(e,e)},_.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(r(t%2==1),3===t){var i=this.m.add(new n(1)).iushrn(2);return this.pow(e,i)}for(var a=this.m.subn(1),s=0;!a.isZero()&&0===a.andln(1);)s++,a.iushrn(1);r(!a.isZero());var o=new n(1).toRed(this),c=o.redNeg(),u=this.m.subn(1).iushrn(1),h=this.m.bitLength();for(h=new n(2*h*h).toRed(this);0!==this.pow(h,u).cmp(c);)h.redIAdd(c);for(var d=this.pow(h,a),f=this.pow(e,a.addn(1).iushrn(1)),l=this.pow(e,a),p=s;0!==l.cmp(o);){for(var y=l,b=0;0!==y.cmp(o);b++)y=y.redSqr();r(b<p);var m=this.pow(d,new n(1).iushln(p-b-1));f=f.redMul(m),d=m.redSqr(),l=l.redMul(d),p=b;}return f},_.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},_.prototype.pow=function(e,t){if(t.isZero())return new n(1).toRed(this);if(0===t.cmpn(1))return e.clone();var r=Array(16);r[0]=new n(1).toRed(this),r[1]=e;for(var i=2;i<r.length;i++)r[i]=this.mul(r[i-1],e);var a=r[0],s=0,o=0,c=t.bitLength()%26;for(0===c&&(c=26),i=t.length-1;i>=0;i--){for(var u=t.words[i],h=c-1;h>=0;h--){var d=u>>h&1;a!==r[0]&&(a=this.sqr(a)),0!==d||0!==s?(s<<=1,s|=d,(4===++o||0===i&&0===h)&&(a=this.mul(a,r[s]),o=0,s=0)):o=0;}c=26;}return a},_.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},_.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},n.mont=function(e){return new k(e)},i(k,_),k.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},k.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},k.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var r=e.imul(t),i=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),n=r.isub(i).iushrn(this.shift),a=n;return n.cmp(this.m)>=0?a=n.isub(this.m):n.cmpn(0)<0&&(a=n.iadd(this.m)),a._forceRed(this)},k.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new n(0)._forceRed(this);var r=e.mul(t),i=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),a=r.isub(i).iushrn(this.shift),s=a;return a.cmp(this.m)>=0?s=a.isub(this.m):a.cmpn(0)<0&&(s=a.iadd(this.m)),s._forceRed(this)},k.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)};}(e,rt);})),sy=/*#__PURE__*/Object.freeze({__proto__:null,default:ay,__moduleExports:ay});class oy{constructor(e){if(void 0===e)throw Error("Invalid BigInteger input");this.value=new ay(e);}clone(){const e=new oy(null);return this.value.copy(e.value),e}iinc(){return this.value.iadd(new ay(1)),this}inc(){return this.clone().iinc()}idec(){return this.value.isub(new ay(1)),this}dec(){return this.clone().idec()}iadd(e){return this.value.iadd(e.value),this}add(e){return this.clone().iadd(e)}isub(e){return this.value.isub(e.value),this}sub(e){return this.clone().isub(e)}imul(e){return this.value.imul(e.value),this}mul(e){return this.clone().imul(e)}imod(e){return this.value=this.value.umod(e.value),this}mod(e){return this.clone().imod(e)}modExp(e,t){const r=t.isEven()?ay.red(t.value):ay.mont(t.value),i=this.clone();return i.value=i.value.toRed(r).redPow(e.value).fromRed(),i}modInv(e){if(!this.gcd(e).isOne())throw Error("Inverse does not exist");return new oy(this.value.invm(e.value))}gcd(e){return new oy(this.value.gcd(e.value))}ileftShift(e){return this.value.ishln(e.value.toNumber()),this}leftShift(e){return this.clone().ileftShift(e)}irightShift(e){return this.value.ishrn(e.value.toNumber()),this}rightShift(e){return this.clone().irightShift(e)}equal(e){return this.value.eq(e.value)}lt(e){return this.value.lt(e.value)}lte(e){return this.value.lte(e.value)}gt(e){return this.value.gt(e.value)}gte(e){return this.value.gte(e.value)}isZero(){return this.value.isZero()}isOne(){return this.value.eq(new ay(1))}isNegative(){return this.value.isNeg()}isEven(){return this.value.isEven()}abs(){const e=this.clone();return e.value=e.value.abs(),e}toString(){return this.value.toString()}toNumber(){return this.value.toNumber()}getBit(e){return this.value.testn(e)?1:0}bitLength(){return this.value.bitLength()}byteLength(){return this.value.byteLength()}toUint8Array(e="be",t){return this.value.toArrayLike(Uint8Array,e,t)}}var cy,uy=/*#__PURE__*/Object.freeze({__proto__:null,default:oy}),hy=it((function(e,t){var r=t;function i(e){return 1===e.length?"0"+e:e}function n(e){for(var t="",r=0;r<e.length;r++)t+=i(e[r].toString(16));return t}r.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return [];var r=[];if("string"!=typeof e){for(var i=0;i<e.length;i++)r[i]=0|e[i];return r}if("hex"===t){(e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e);for(i=0;i<e.length;i+=2)r.push(parseInt(e[i]+e[i+1],16));}else for(i=0;i<e.length;i++){var n=e.charCodeAt(i),a=n>>8,s=255&n;a?r.push(a,s):r.push(s);}return r},r.zero2=i,r.toHex=n,r.encode=function(e,t){return "hex"===t?n(e):e};})),dy=it((function(e,t){var r=t;r.assert=et,r.toArray=hy.toArray,r.zero2=hy.zero2,r.toHex=hy.toHex,r.encode=hy.encode,r.getNAF=function(e,t){for(var r=[],i=1<<t+1,n=e.clone();n.cmpn(1)>=0;){var a;if(n.isOdd()){var s=n.andln(i-1);a=s>(i>>1)-1?(i>>1)-s:s,n.isubn(a);}else a=0;r.push(a);for(var o=0!==n.cmpn(0)&&0===n.andln(i-1)?t+1:1,c=1;c<o;c++)r.push(0);n.iushrn(o);}return r},r.getJSF=function(e,t){var r=[[],[]];e=e.clone(),t=t.clone();for(var i=0,n=0;e.cmpn(-i)>0||t.cmpn(-n)>0;){var a,s,o,c=e.andln(3)+i&3,u=t.andln(3)+n&3;if(3===c&&(c=-1),3===u&&(u=-1),0==(1&c))a=0;else a=3!==(o=e.andln(7)+i&7)&&5!==o||2!==u?c:-c;if(r[0].push(a),0==(1&u))s=0;else s=3!==(o=t.andln(7)+n&7)&&5!==o||2!==c?u:-u;r[1].push(s),2*i===a+1&&(i=1-i),2*n===s+1&&(n=1-n),e.iushrn(1),t.iushrn(1);}return r},r.cachedProperty=function(e,t,r){var i="_"+t;e.prototype[t]=function(){return void 0!==this[i]?this[i]:this[i]=r.call(this)};},r.parseBytes=function(e){return "string"==typeof e?r.toArray(e,"hex"):e},r.intFromLE=function(e){return new ay(e,"hex","le")};})),fy=function(e){return cy||(cy=new ly(null)),cy.generate(e)};function ly(e){this.rand=e;}var py=ly;if(ly.prototype.generate=function(e){return this._rand(e)},ly.prototype._rand=function(e){if(this.rand.getBytes)return this.rand.getBytes(e);for(var t=new Uint8Array(e),r=0;r<t.length;r++)t[r]=this.rand.getByte();return t},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?ly.prototype._rand=function(e){var t=new Uint8Array(e);return self.crypto.getRandomValues(t),t}:self.msCrypto&&self.msCrypto.getRandomValues?ly.prototype._rand=function(e){var t=new Uint8Array(e);return self.msCrypto.getRandomValues(t),t}:"object"==typeof window&&(ly.prototype._rand=function(){throw Error("Not implemented yet")});else try{var yy=void 0;if("function"!=typeof yy.randomBytes)throw Error("Not supported");ly.prototype._rand=function(e){return yy.randomBytes(e)};}catch(e){}fy.Rand=py;var by=dy.getNAF,my=dy.getJSF,gy=dy.assert;function wy(e,t){this.type=e,this.p=new ay(t.p,16),this.red=t.prime?ay.red(t.prime):ay.mont(this.p),this.zero=new ay(0).toRed(this.red),this.one=new ay(1).toRed(this.red),this.two=new ay(2).toRed(this.red),this.n=t.n&&new ay(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=[,,,,],this._wnafT2=[,,,,],this._wnafT3=[,,,,],this._wnafT4=[,,,,];var r=this.n&&this.p.div(this.n);!r||r.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red));}var vy=wy;function _y(e,t){this.curve=e,this.type=t,this.precomputed=null;}wy.prototype.point=function(){throw Error("Not implemented")},wy.prototype.validate=function(){throw Error("Not implemented")},wy.prototype._fixedNafMul=function(e,t){gy(e.precomputed);var r=e._getDoubles(),i=by(t,1),n=(1<<r.step+1)-(r.step%2==0?2:1);n/=3;for(var a=[],s=0;s<i.length;s+=r.step){var o=0;for(t=s+r.step-1;t>=s;t--)o=(o<<1)+i[t];a.push(o);}for(var c=this.jpoint(null,null,null),u=this.jpoint(null,null,null),h=n;h>0;h--){for(s=0;s<a.length;s++){(o=a[s])===h?u=u.mixedAdd(r.points[s]):o===-h&&(u=u.mixedAdd(r.points[s].neg()));}c=c.add(u);}return c.toP()},wy.prototype._wnafMul=function(e,t){var r=4,i=e._getNAFPoints(r);r=i.wnd;for(var n=i.points,a=by(t,r),s=this.jpoint(null,null,null),o=a.length-1;o>=0;o--){for(t=0;o>=0&&0===a[o];o--)t++;if(o>=0&&t++,s=s.dblp(t),o<0)break;var c=a[o];gy(0!==c),s="affine"===e.type?c>0?s.mixedAdd(n[c-1>>1]):s.mixedAdd(n[-c-1>>1].neg()):c>0?s.add(n[c-1>>1]):s.add(n[-c-1>>1].neg());}return "affine"===e.type?s.toP():s},wy.prototype._wnafMulAdd=function(e,t,r,i,n){for(var a=this._wnafT1,s=this._wnafT2,o=this._wnafT3,c=0,u=0;u<i;u++){var h=(A=t[u])._getNAFPoints(e);a[u]=h.wnd,s[u]=h.points;}for(u=i-1;u>=1;u-=2){var d=u-1,f=u;if(1===a[d]&&1===a[f]){var l=[t[d],null,null,t[f]];0===t[d].y.cmp(t[f].y)?(l[1]=t[d].add(t[f]),l[2]=t[d].toJ().mixedAdd(t[f].neg())):0===t[d].y.cmp(t[f].y.redNeg())?(l[1]=t[d].toJ().mixedAdd(t[f]),l[2]=t[d].add(t[f].neg())):(l[1]=t[d].toJ().mixedAdd(t[f]),l[2]=t[d].toJ().mixedAdd(t[f].neg()));var p=[-3,-1,-5,-7,0,7,5,1,3],y=my(r[d],r[f]);c=Math.max(y[0].length,c),o[d]=Array(c),o[f]=Array(c);for(var b=0;b<c;b++){var m=0|y[0][b],g=0|y[1][b];o[d][b]=p[3*(m+1)+(g+1)],o[f][b]=0,s[d]=l;}}else o[d]=by(r[d],a[d]),o[f]=by(r[f],a[f]),c=Math.max(o[d].length,c),c=Math.max(o[f].length,c);}var w=this.jpoint(null,null,null),v=this._wnafT4;for(u=c;u>=0;u--){for(var _=0;u>=0;){var k=!0;for(b=0;b<i;b++)v[b]=0|o[b][u],0!==v[b]&&(k=!1);if(!k)break;_++,u--;}if(u>=0&&_++,w=w.dblp(_),u<0)break;for(b=0;b<i;b++){var A,S=v[b];0!==S&&(S>0?A=s[b][S-1>>1]:S<0&&(A=s[b][-S-1>>1].neg()),w="affine"===A.type?w.mixedAdd(A):w.add(A));}}for(u=0;u<i;u++)s[u]=null;return n?w:w.toP()},wy.BasePoint=_y,_y.prototype.eq=function(){throw Error("Not implemented")},_y.prototype.validate=function(){return this.curve.validate(this)},wy.prototype.decodePoint=function(e,t){e=dy.toArray(e,t);var r=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*r)return 6===e[0]?gy(e[e.length-1]%2==0):7===e[0]&&gy(e[e.length-1]%2==1),this.point(e.slice(1,1+r),e.slice(1+r,1+2*r));if((2===e[0]||3===e[0])&&e.length-1===r)return this.pointFromX(e.slice(1,1+r),3===e[0]);throw Error("Unknown point format")},_y.prototype.encodeCompressed=function(e){return this.encode(e,!0)},_y.prototype._encode=function(e){var t=this.curve.p.byteLength(),r=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(r):[4].concat(r,this.getY().toArray("be",t))},_y.prototype.encode=function(e,t){return dy.encode(this._encode(t),e)},_y.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},_y.prototype._hasDoubles=function(e){if(!this.precomputed)return !1;var t=this.precomputed.doubles;return !!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},_y.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var r=[this],i=this,n=0;n<t;n+=e){for(var a=0;a<e;a++)i=i.dbl();r.push(i);}return {step:e,points:r}},_y.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],r=(1<<e)-1,i=1===r?null:this.dbl(),n=1;n<r;n++)t[n]=t[n-1].add(i);return {wnd:e,points:t}},_y.prototype._getBeta=function(){return null},_y.prototype.dblp=function(e){for(var t=this,r=0;r<e;r++)t=t.dbl();return t};var ky=dy.assert;function Ay(e){vy.call(this,"short",e),this.a=new ay(e.a,16).toRed(this.red),this.b=new ay(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=[,,,,],this._endoWnafT2=[,,,,];}at(Ay,vy);var Sy=Ay;function Ey(e,t,r,i){vy.BasePoint.call(this,e,"affine"),null===t&&null===r?(this.x=null,this.y=null,this.inf=!0):(this.x=new ay(t,16),this.y=new ay(r,16),i&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1);}function Py(e,t,r,i){vy.BasePoint.call(this,e,"jacobian"),null===t&&null===r&&null===i?(this.x=this.curve.one,this.y=this.curve.one,this.z=new ay(0)):(this.x=new ay(t,16),this.y=new ay(r,16),this.z=new ay(i,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one;}function xy(e){vy.call(this,"mont",e),this.a=new ay(e.a,16).toRed(this.red),this.b=new ay(e.b,16).toRed(this.red),this.i4=new ay(4).toRed(this.red).redInvm(),this.two=new ay(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two));}Ay.prototype._getEndomorphism=function(e){if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3)){var t,r;if(e.beta)t=new ay(e.beta,16).toRed(this.red);else {var i=this._getEndoRoots(this.p);t=(t=i[0].cmp(i[1])<0?i[0]:i[1]).toRed(this.red);}if(e.lambda)r=new ay(e.lambda,16);else {var n=this._getEndoRoots(this.n);0===this.g.mul(n[0]).x.cmp(this.g.x.redMul(t))?r=n[0]:(r=n[1],ky(0===this.g.mul(r).x.cmp(this.g.x.redMul(t))));}return {beta:t,lambda:r,basis:e.basis?e.basis.map((function(e){return {a:new ay(e.a,16),b:new ay(e.b,16)}})):this._getEndoBasis(r)}}},Ay.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:ay.mont(e),r=new ay(2).toRed(t).redInvm(),i=r.redNeg(),n=new ay(3).toRed(t).redNeg().redSqrt().redMul(r);return [i.redAdd(n).fromRed(),i.redSub(n).fromRed()]},Ay.prototype._getEndoBasis=function(e){for(var t,r,i,n,a,s,o,c,u,h=this.n.ushrn(Math.floor(this.n.bitLength()/2)),d=e,f=this.n.clone(),l=new ay(1),p=new ay(0),y=new ay(0),b=new ay(1),m=0;0!==d.cmpn(0);){var g=f.div(d);c=f.sub(g.mul(d)),u=y.sub(g.mul(l));var w=b.sub(g.mul(p));if(!i&&c.cmp(h)<0)t=o.neg(),r=l,i=c.neg(),n=u;else if(i&&2==++m)break;o=c,f=d,d=c,y=l,l=u,b=p,p=w;}a=c.neg(),s=u;var v=i.sqr().add(n.sqr());return a.sqr().add(s.sqr()).cmp(v)>=0&&(a=t,s=r),i.negative&&(i=i.neg(),n=n.neg()),a.negative&&(a=a.neg(),s=s.neg()),[{a:i,b:n},{a,b:s}]},Ay.prototype._endoSplit=function(e){var t=this.endo.basis,r=t[0],i=t[1],n=i.b.mul(e).divRound(this.n),a=r.b.neg().mul(e).divRound(this.n),s=n.mul(r.a),o=a.mul(i.a),c=n.mul(r.b),u=a.mul(i.b);return {k1:e.sub(s).sub(o),k2:c.add(u).neg()}},Ay.prototype.pointFromX=function(e,t){(e=new ay(e,16)).red||(e=e.toRed(this.red));var r=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),i=r.redSqrt();if(0!==i.redSqr().redSub(r).cmp(this.zero))throw Error("invalid point");var n=i.fromRed().isOdd();return (t&&!n||!t&&n)&&(i=i.redNeg()),this.point(e,i)},Ay.prototype.validate=function(e){if(e.inf)return !0;var t=e.x,r=e.y,i=this.a.redMul(t),n=t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);return 0===r.redSqr().redISub(n).cmpn(0)},Ay.prototype._endoWnafMulAdd=function(e,t,r){for(var i=this._endoWnafT1,n=this._endoWnafT2,a=0;a<e.length;a++){var s=this._endoSplit(t[a]),o=e[a],c=o._getBeta();s.k1.negative&&(s.k1.ineg(),o=o.neg(!0)),s.k2.negative&&(s.k2.ineg(),c=c.neg(!0)),i[2*a]=o,i[2*a+1]=c,n[2*a]=s.k1,n[2*a+1]=s.k2;}for(var u=this._wnafMulAdd(1,i,n,2*a,r),h=0;h<2*a;h++)i[h]=null,n[h]=null;return u},at(Ey,vy.BasePoint),Ay.prototype.point=function(e,t,r){return new Ey(this,e,t,r)},Ay.prototype.pointFromJSON=function(e,t){return Ey.fromJSON(this,e,t)},Ey.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(e){var r=this.curve,i=function(e){return r.point(e.x.redMul(r.endo.beta),e.y)};e.beta=t,t.precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(i)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(i)}};}return t}},Ey.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},Ey.fromJSON=function(e,t,r){"string"==typeof t&&(t=JSON.parse(t));var i=e.point(t[0],t[1],r);if(!t[2])return i;function n(t){return e.point(t[0],t[1],r)}var a=t[2];return i.precomputed={beta:null,doubles:a.doubles&&{step:a.doubles.step,points:[i].concat(a.doubles.points.map(n))},naf:a.naf&&{wnd:a.naf.wnd,points:[i].concat(a.naf.points.map(n))}},i},Ey.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},Ey.prototype.isInfinity=function(){return this.inf},Ey.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y);0!==t.cmpn(0)&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var r=t.redSqr().redISub(this.x).redISub(e.x),i=t.redMul(this.x.redSub(r)).redISub(this.y);return this.curve.point(r,i)},Ey.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,r=this.x.redSqr(),i=e.redInvm(),n=r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i),a=n.redSqr().redISub(this.x.redAdd(this.x)),s=n.redMul(this.x.redSub(a)).redISub(this.y);return this.curve.point(a,s)},Ey.prototype.getX=function(){return this.x.fromRed()},Ey.prototype.getY=function(){return this.y.fromRed()},Ey.prototype.mul=function(e){return e=new ay(e,16),this.isInfinity()?this:this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},Ey.prototype.mulAdd=function(e,t,r){var i=[this,t],n=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(i,n):this.curve._wnafMulAdd(1,i,n,2)},Ey.prototype.jmulAdd=function(e,t,r){var i=[this,t],n=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(i,n,!0):this.curve._wnafMulAdd(1,i,n,2,!0)},Ey.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},Ey.prototype.neg=function(e){if(this.inf)return this;var t=this.curve.point(this.x,this.y.redNeg());if(e&&this.precomputed){var r=this.precomputed,i=function(e){return e.neg()};t.precomputed={naf:r.naf&&{wnd:r.naf.wnd,points:r.naf.points.map(i)},doubles:r.doubles&&{step:r.doubles.step,points:r.doubles.points.map(i)}};}return t},Ey.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},at(Py,vy.BasePoint),Ay.prototype.jpoint=function(e,t,r){return new Py(this,e,t,r)},Py.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),r=this.x.redMul(t),i=this.y.redMul(t).redMul(e);return this.curve.point(r,i)},Py.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},Py.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),r=this.z.redSqr(),i=this.x.redMul(t),n=e.x.redMul(r),a=this.y.redMul(t.redMul(e.z)),s=e.y.redMul(r.redMul(this.z)),o=i.redSub(n),c=a.redSub(s);if(0===o.cmpn(0))return 0!==c.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var u=o.redSqr(),h=u.redMul(o),d=i.redMul(u),f=c.redSqr().redIAdd(h).redISub(d).redISub(d),l=c.redMul(d.redISub(f)).redISub(a.redMul(h)),p=this.z.redMul(e.z).redMul(o);return this.curve.jpoint(f,l,p)},Py.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),r=this.x,i=e.x.redMul(t),n=this.y,a=e.y.redMul(t).redMul(this.z),s=r.redSub(i),o=n.redSub(a);if(0===s.cmpn(0))return 0!==o.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var c=s.redSqr(),u=c.redMul(s),h=r.redMul(c),d=o.redSqr().redIAdd(u).redISub(h).redISub(h),f=o.redMul(h.redISub(d)).redISub(n.redMul(u)),l=this.z.redMul(s);return this.curve.jpoint(d,f,l)},Py.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,r=0;r<e;r++)t=t.dbl();return t}var i=this.curve.a,n=this.curve.tinv,a=this.x,s=this.y,o=this.z,c=o.redSqr().redSqr(),u=s.redAdd(s);for(r=0;r<e;r++){var h=a.redSqr(),d=u.redSqr(),f=d.redSqr(),l=h.redAdd(h).redIAdd(h).redIAdd(i.redMul(c)),p=a.redMul(d),y=l.redSqr().redISub(p.redAdd(p)),b=p.redISub(y),m=l.redMul(b);m=m.redIAdd(m).redISub(f);var g=u.redMul(o);r+1<e&&(c=c.redMul(f)),a=y,o=g,u=m;}return this.curve.jpoint(a,u.redMul(n),o)},Py.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},Py.prototype._zeroDbl=function(){var e,t,r;if(this.zOne){var i=this.x.redSqr(),n=this.y.redSqr(),a=n.redSqr(),s=this.x.redAdd(n).redSqr().redISub(i).redISub(a);s=s.redIAdd(s);var o=i.redAdd(i).redIAdd(i),c=o.redSqr().redISub(s).redISub(s),u=a.redIAdd(a);u=(u=u.redIAdd(u)).redIAdd(u),e=c,t=o.redMul(s.redISub(c)).redISub(u),r=this.y.redAdd(this.y);}else {var h=this.x.redSqr(),d=this.y.redSqr(),f=d.redSqr(),l=this.x.redAdd(d).redSqr().redISub(h).redISub(f);l=l.redIAdd(l);var p=h.redAdd(h).redIAdd(h),y=p.redSqr(),b=f.redIAdd(f);b=(b=b.redIAdd(b)).redIAdd(b),e=y.redISub(l).redISub(l),t=p.redMul(l.redISub(e)).redISub(b),r=(r=this.y.redMul(this.z)).redIAdd(r);}return this.curve.jpoint(e,t,r)},Py.prototype._threeDbl=function(){var e,t,r;if(this.zOne){var i=this.x.redSqr(),n=this.y.redSqr(),a=n.redSqr(),s=this.x.redAdd(n).redSqr().redISub(i).redISub(a);s=s.redIAdd(s);var o=i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),c=o.redSqr().redISub(s).redISub(s);e=c;var u=a.redIAdd(a);u=(u=u.redIAdd(u)).redIAdd(u),t=o.redMul(s.redISub(c)).redISub(u),r=this.y.redAdd(this.y);}else {var h=this.z.redSqr(),d=this.y.redSqr(),f=this.x.redMul(d),l=this.x.redSub(h).redMul(this.x.redAdd(h));l=l.redAdd(l).redIAdd(l);var p=f.redIAdd(f),y=(p=p.redIAdd(p)).redAdd(p);e=l.redSqr().redISub(y),r=this.y.redAdd(this.z).redSqr().redISub(d).redISub(h);var b=d.redSqr();b=(b=(b=b.redIAdd(b)).redIAdd(b)).redIAdd(b),t=l.redMul(p.redISub(e)).redISub(b);}return this.curve.jpoint(e,t,r)},Py.prototype._dbl=function(){var e=this.curve.a,t=this.x,r=this.y,i=this.z,n=i.redSqr().redSqr(),a=t.redSqr(),s=r.redSqr(),o=a.redAdd(a).redIAdd(a).redIAdd(e.redMul(n)),c=t.redAdd(t),u=(c=c.redIAdd(c)).redMul(s),h=o.redSqr().redISub(u.redAdd(u)),d=u.redISub(h),f=s.redSqr();f=(f=(f=f.redIAdd(f)).redIAdd(f)).redIAdd(f);var l=o.redMul(d).redISub(f),p=r.redAdd(r).redMul(i);return this.curve.jpoint(h,l,p)},Py.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr(),i=t.redSqr(),n=e.redAdd(e).redIAdd(e),a=n.redSqr(),s=this.x.redAdd(t).redSqr().redISub(e).redISub(i),o=(s=(s=(s=s.redIAdd(s)).redAdd(s).redIAdd(s)).redISub(a)).redSqr(),c=i.redIAdd(i);c=(c=(c=c.redIAdd(c)).redIAdd(c)).redIAdd(c);var u=n.redIAdd(s).redSqr().redISub(a).redISub(o).redISub(c),h=t.redMul(u);h=(h=h.redIAdd(h)).redIAdd(h);var d=this.x.redMul(o).redISub(h);d=(d=d.redIAdd(d)).redIAdd(d);var f=this.y.redMul(u.redMul(c.redISub(u)).redISub(s.redMul(o)));f=(f=(f=f.redIAdd(f)).redIAdd(f)).redIAdd(f);var l=this.z.redAdd(s).redSqr().redISub(r).redISub(o);return this.curve.jpoint(d,f,l)},Py.prototype.mul=function(e,t){return e=new ay(e,t),this.curve._wnafMul(this,e)},Py.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return !0;var t=this.z.redSqr(),r=e.z.redSqr();if(0!==this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0))return !1;var i=t.redMul(this.z),n=r.redMul(e.z);return 0===this.y.redMul(n).redISub(e.y.redMul(i)).cmpn(0)},Py.prototype.eqXToP=function(e){var t=this.z.redSqr(),r=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(r))return !0;for(var i=e.clone(),n=this.curve.redN.redMul(t);;){if(i.iadd(this.curve.n),i.cmp(this.curve.p)>=0)return !1;if(r.redIAdd(n),0===this.x.cmp(r))return !0}},Py.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},Py.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},at(xy,vy);var My=xy;function Ky(e,t,r){vy.BasePoint.call(this,e,"projective"),null===t&&null===r?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new ay(t,16),this.z=new ay(r,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)));}xy.prototype.validate=function(e){var t=e.normalize().x,r=t.redSqr(),i=r.redMul(t).redAdd(r.redMul(this.a)).redAdd(t);return 0===i.redSqrt().redSqr().cmp(i)},at(Ky,vy.BasePoint),xy.prototype.decodePoint=function(e,t){if(33===(e=dy.toArray(e,t)).length&&64===e[0]&&(e=e.slice(1,33).reverse()),32!==e.length)throw Error("Unknown point compression format");return this.point(e,1)},xy.prototype.point=function(e,t){return new Ky(this,e,t)},xy.prototype.pointFromJSON=function(e){return Ky.fromJSON(this,e)},Ky.prototype.precompute=function(){},Ky.prototype._encode=function(e){var t=this.curve.p.byteLength();return e?[64].concat(this.getX().toArray("le",t)):this.getX().toArray("be",t)},Ky.fromJSON=function(e,t){return new Ky(e,t[0],t[1]||e.one)},Ky.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},Ky.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},Ky.prototype.dbl=function(){var e=this.x.redAdd(this.z).redSqr(),t=this.x.redSub(this.z).redSqr(),r=e.redSub(t),i=e.redMul(t),n=r.redMul(t.redAdd(this.curve.a24.redMul(r)));return this.curve.point(i,n)},Ky.prototype.add=function(){throw Error("Not supported on Montgomery curve")},Ky.prototype.diffAdd=function(e,t){var r=this.x.redAdd(this.z),i=this.x.redSub(this.z),n=e.x.redAdd(e.z),a=e.x.redSub(e.z).redMul(r),s=n.redMul(i),o=t.z.redMul(a.redAdd(s).redSqr()),c=t.x.redMul(a.redISub(s).redSqr());return this.curve.point(o,c)},Ky.prototype.mul=function(e){for(var t=(e=new ay(e,16)).clone(),r=this,i=this.curve.point(null,null),n=[];0!==t.cmpn(0);t.iushrn(1))n.push(t.andln(1));for(var a=n.length-1;a>=0;a--)0===n[a]?(r=r.diffAdd(i,this),i=i.dbl()):(i=r.diffAdd(i,this),r=r.dbl());return i},Ky.prototype.mulAdd=function(){throw Error("Not supported on Montgomery curve")},Ky.prototype.jumlAdd=function(){throw Error("Not supported on Montgomery curve")},Ky.prototype.eq=function(e){return 0===this.getX().cmp(e.getX())},Ky.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},Ky.prototype.getX=function(){return this.normalize(),this.x.fromRed()};var Cy=dy.assert;function Dy(e){this.twisted=1!=(0|e.a),this.mOneA=this.twisted&&-1==(0|e.a),this.extended=this.mOneA,vy.call(this,"edwards",e),this.a=new ay(e.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new ay(e.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new ay(e.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),Cy(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1==(0|e.c);}at(Dy,vy);var Uy=Dy;function Ry(e,t,r,i,n){vy.BasePoint.call(this,e,"projective"),null===t&&null===r&&null===i?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new ay(t,16),this.y=new ay(r,16),this.z=i?new ay(i,16):this.curve.one,this.t=n&&new ay(n,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))));}Dy.prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)},Dy.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)},Dy.prototype.jpoint=function(e,t,r,i){return this.point(e,t,r,i)},Dy.prototype.pointFromX=function(e,t){(e=new ay(e,16)).red||(e=e.toRed(this.red));var r=e.redSqr(),i=this.c2.redSub(this.a.redMul(r)),n=this.one.redSub(this.c2.redMul(this.d).redMul(r)),a=i.redMul(n.redInvm()),s=a.redSqrt();if(0!==s.redSqr().redSub(a).cmp(this.zero))throw Error("invalid point");var o=s.fromRed().isOdd();return (t&&!o||!t&&o)&&(s=s.redNeg()),this.point(e,s)},Dy.prototype.pointFromY=function(e,t){(e=new ay(e,16)).red||(e=e.toRed(this.red));var r=e.redSqr(),i=r.redSub(this.c2),n=r.redMul(this.d).redMul(this.c2).redSub(this.a),a=i.redMul(n.redInvm());if(0===a.cmp(this.zero)){if(t)throw Error("invalid point");return this.point(this.zero,e)}var s=a.redSqrt();if(0!==s.redSqr().redSub(a).cmp(this.zero))throw Error("invalid point");return s.fromRed().isOdd()!==t&&(s=s.redNeg()),this.point(s,e)},Dy.prototype.validate=function(e){if(e.isInfinity())return !0;e.normalize();var t=e.x.redSqr(),r=e.y.redSqr(),i=t.redMul(this.a).redAdd(r),n=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(r)));return 0===i.cmp(n)},at(Ry,vy.BasePoint),Dy.prototype.pointFromJSON=function(e){return Ry.fromJSON(this,e)},Dy.prototype.point=function(e,t,r,i){return new Ry(this,e,t,r,i)},Ry.fromJSON=function(e,t){return new Ry(e,t[0],t[1],t[2])},Ry.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},Ry.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&(0===this.y.cmp(this.z)||this.zOne&&0===this.y.cmp(this.curve.c))},Ry.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr();r=r.redIAdd(r);var i=this.curve._mulA(e),n=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),a=i.redAdd(t),s=a.redSub(r),o=i.redSub(t),c=n.redMul(s),u=a.redMul(o),h=n.redMul(o),d=s.redMul(a);return this.curve.point(c,u,d,h)},Ry.prototype._projDbl=function(){var e,t,r,i=this.x.redAdd(this.y).redSqr(),n=this.x.redSqr(),a=this.y.redSqr();if(this.curve.twisted){var s=(u=this.curve._mulA(n)).redAdd(a);if(this.zOne)e=i.redSub(n).redSub(a).redMul(s.redSub(this.curve.two)),t=s.redMul(u.redSub(a)),r=s.redSqr().redSub(s).redSub(s);else {var o=this.z.redSqr(),c=s.redSub(o).redISub(o);e=i.redSub(n).redISub(a).redMul(c),t=s.redMul(u.redSub(a)),r=s.redMul(c);}}else {var u=n.redAdd(a);o=this.curve._mulC(this.z).redSqr(),c=u.redSub(o).redSub(o);e=this.curve._mulC(i.redISub(u)).redMul(c),t=this.curve._mulC(u).redMul(n.redISub(a)),r=u.redMul(c);}return this.curve.point(e,t,r)},Ry.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},Ry.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),r=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),i=this.t.redMul(this.curve.dd).redMul(e.t),n=this.z.redMul(e.z.redAdd(e.z)),a=r.redSub(t),s=n.redSub(i),o=n.redAdd(i),c=r.redAdd(t),u=a.redMul(s),h=o.redMul(c),d=a.redMul(c),f=s.redMul(o);return this.curve.point(u,h,f,d)},Ry.prototype._projAdd=function(e){var t,r,i=this.z.redMul(e.z),n=i.redSqr(),a=this.x.redMul(e.x),s=this.y.redMul(e.y),o=this.curve.d.redMul(a).redMul(s),c=n.redSub(o),u=n.redAdd(o),h=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(a).redISub(s),d=i.redMul(c).redMul(h);return this.curve.twisted?(t=i.redMul(u).redMul(s.redSub(this.curve._mulA(a))),r=c.redMul(u)):(t=i.redMul(u).redMul(s.redSub(a)),r=this.curve._mulC(c).redMul(u)),this.curve.point(d,t,r)},Ry.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)},Ry.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)},Ry.prototype.mulAdd=function(e,t,r){return this.curve._wnafMulAdd(1,[this,t],[e,r],2,!1)},Ry.prototype.jmulAdd=function(e,t,r){return this.curve._wnafMulAdd(1,[this,t],[e,r],2,!0)},Ry.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this},Ry.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},Ry.prototype.getX=function(){return this.normalize(),this.x.fromRed()},Ry.prototype.getY=function(){return this.normalize(),this.y.fromRed()},Ry.prototype.eq=function(e){return this===e||0===this.getX().cmp(e.getX())&&0===this.getY().cmp(e.getY())},Ry.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(t))return !0;for(var r=e.clone(),i=this.curve.redN.redMul(this.z);;){if(r.iadd(this.curve.n),r.cmp(this.curve.p)>=0)return !1;if(t.redIAdd(i),0===this.x.cmp(t))return !0}},Ry.prototype.toP=Ry.prototype.normalize,Ry.prototype.mixedAdd=Ry.prototype.add;var Iy=it((function(e,t){var r=t;r.base=vy,r.short=Sy,r.mont=My,r.edwards=Uy;})),By=pt.rotl32,Ty=pt.sum32,zy=pt.sum32_5,qy=At.ft_1,Fy=mt.BlockHash,Oy=[1518500249,1859775393,2400959708,3395469782];function Ly(){if(!(this instanceof Ly))return new Ly;Fy.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=Array(80);}pt.inherits(Ly,Fy);var Ny=Ly;Ly.blockSize=512,Ly.outSize=160,Ly.hmacStrength=80,Ly.padLength=64,Ly.prototype._update=function(e,t){for(var r=this.W,i=0;i<16;i++)r[i]=e[t+i];for(;i<r.length;i++)r[i]=By(r[i-3]^r[i-8]^r[i-14]^r[i-16],1);var n=this.h[0],a=this.h[1],s=this.h[2],o=this.h[3],c=this.h[4];for(i=0;i<r.length;i++){var u=~~(i/20),h=zy(By(n,5),qy(u,a,s,o),c,r[i],Oy[u]);c=o,o=s,s=By(a,30),a=n,n=h;}this.h[0]=Ty(this.h[0],n),this.h[1]=Ty(this.h[1],a),this.h[2]=Ty(this.h[2],s),this.h[3]=Ty(this.h[3],o),this.h[4]=Ty(this.h[4],c);},Ly.prototype._digest=function(e){return "hex"===e?pt.toHex32(this.h,"big"):pt.split32(this.h,"big")};var jy={sha1:Ny,sha224:qt,sha256:Tt,sha384:lr,sha512:Jt};function Hy(e,t,r){if(!(this instanceof Hy))return new Hy(e,t,r);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(pt.toArray(t,r));}var Wy=Hy;Hy.prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),et(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e);},Hy.prototype.update=function(e,t){return this.inner.update(e,t),this},Hy.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)};var Gy=it((function(e,t){var r=t;r.utils=pt,r.common=mt,r.sha=jy,r.ripemd=Mr,r.hmac=Wy,r.sha1=r.sha.sha1,r.sha256=r.sha.sha256,r.sha224=r.sha.sha224,r.sha384=r.sha.sha384,r.sha512=r.sha.sha512,r.ripemd160=r.ripemd.ripemd160;})),Vy={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}},$y=it((function(e,t){var r,i=t,n=dy.assert;function a(e){if("short"===e.type)this.curve=new Iy.short(e);else if("edwards"===e.type)this.curve=new Iy.edwards(e);else {if("mont"!==e.type)throw Error("Unknown curve type.");this.curve=new Iy.mont(e);}this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,n(this.g.validate(),"Invalid curve"),n(this.g.mul(this.n).isInfinity(),"Invalid curve, n*G != O");}function s(e,t){Object.defineProperty(i,e,{configurable:!0,enumerable:!0,get:function(){var r=new a(t);return Object.defineProperty(i,e,{configurable:!0,enumerable:!0,value:r}),r}});}i.PresetCurve=a,s("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:Gy.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),s("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:Gy.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),s("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:Gy.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),s("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:Gy.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),s("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:Gy.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),s("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",cofactor:"8",hash:Gy.sha256,gRed:!1,g:["9"]}),s("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",cofactor:"8",hash:Gy.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]}),s("brainpoolP256r1",{type:"short",prime:null,p:"A9FB57DB A1EEA9BC 3E660A90 9D838D72 6E3BF623 D5262028 2013481D 1F6E5377",a:"7D5A0975 FC2C3057 EEF67530 417AFFE7 FB8055C1 26DC5C6C E94A4B44 F330B5D9",b:"26DC5C6C E94A4B44 F330B5D9 BBD77CBF 95841629 5CF7E1CE 6BCCDC18 FF8C07B6",n:"A9FB57DB A1EEA9BC 3E660A90 9D838D71 8C397AA3 B561A6F7 901E0E82 974856A7",hash:Gy.sha256,gRed:!1,g:["8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262","547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997"]}),s("brainpoolP384r1",{type:"short",prime:null,p:"8CB91E82 A3386D28 0F5D6F7E 50E641DF 152F7109 ED5456B4 12B1DA19 7FB71123ACD3A729 901D1A71 87470013 3107EC53",a:"7BC382C6 3D8C150C 3C72080A CE05AFA0 C2BEA28E 4FB22787 139165EF BA91F90F8AA5814A 503AD4EB 04A8C7DD 22CE2826",b:"04A8C7DD 22CE2826 8B39B554 16F0447C 2FB77DE1 07DCD2A6 2E880EA5 3EEB62D57CB43902 95DBC994 3AB78696 FA504C11",n:"8CB91E82 A3386D28 0F5D6F7E 50E641DF 152F7109 ED5456B3 1F166E6C AC0425A7CF3AB6AF 6B7FC310 3B883202 E9046565",hash:Gy.sha384,gRed:!1,g:["1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E","8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315"]}),s("brainpoolP512r1",{type:"short",prime:null,p:"AADD9DB8 DBE9C48B 3FD4E6AE 33C9FC07 CB308DB3 B3C9D20E D6639CCA 703308717D4D9B00 9BC66842 AECDA12A E6A380E6 2881FF2F 2D82C685 28AA6056 583A48F3",a:"7830A331 8B603B89 E2327145 AC234CC5 94CBDD8D 3DF91610 A83441CA EA9863BC2DED5D5A A8253AA1 0A2EF1C9 8B9AC8B5 7F1117A7 2BF2C7B9 E7C1AC4D 77FC94CA",b:"3DF91610 A83441CA EA9863BC 2DED5D5A A8253AA1 0A2EF1C9 8B9AC8B5 7F1117A72BF2C7B9 E7C1AC4D 77FC94CA DC083E67 984050B7 5EBAE5DD 2809BD63 8016F723",n:"AADD9DB8 DBE9C48B 3FD4E6AE 33C9FC07 CB308DB3 B3C9D20E D6639CCA 70330870553E5C41 4CA92619 41866119 7FAC1047 1DB1D381 085DDADD B5879682 9CA90069",hash:Gy.sha512,gRed:!1,g:["81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822","7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892"]});try{r=Vy;}catch(e){r=void 0;}s("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:Gy.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]});}));function Zy(e){if(!(this instanceof Zy))return new Zy(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=hy.toArray(e.entropy,e.entropyEnc||"hex"),r=hy.toArray(e.nonce,e.nonceEnc||"hex"),i=hy.toArray(e.pers,e.persEnc||"hex");et(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,r,i);}var Xy=Zy;Zy.prototype._init=function(e,t,r){var i=e.concat(t).concat(r);this.K=Array(this.outLen/8),this.V=Array(this.outLen/8);for(var n=0;n<this.V.length;n++)this.K[n]=0,this.V[n]=1;this._update(i),this._reseed=1,this.reseedInterval=281474976710656;},Zy.prototype._hmac=function(){return new Gy.hmac(this.hash,this.K)},Zy.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest());},Zy.prototype.reseed=function(e,t,r,i){"string"!=typeof t&&(i=r,r=t,t=null),e=hy.toArray(e,t),r=hy.toArray(r,i),et(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(r||[])),this._reseed=1;},Zy.prototype.generate=function(e,t,r,i){if(this._reseed>this.reseedInterval)throw Error("Reseed is required");"string"!=typeof t&&(i=r,r=t,t=null),r&&(r=hy.toArray(r,i||"hex"),this._update(r));for(var n=[];n.length<e;)this.V=this._hmac().update(this.V).digest(),n=n.concat(this.V);var a=n.slice(0,e);return this._update(r),this._reseed++,hy.encode(a,t)};var Yy=dy.assert;function Qy(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc);}var Jy=Qy;Qy.fromPublic=function(e,t,r){return t instanceof Qy?t:new Qy(e,{pub:t,pubEnc:r})},Qy.fromPrivate=function(e,t,r){return t instanceof Qy?t:new Qy(e,{priv:t,privEnc:r})},Qy.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},Qy.prototype.getPublic=function(e,t){return this.pub||(this.pub=this.ec.g.mul(this.priv)),e?this.pub.encode(e,t):this.pub},Qy.prototype.getPrivate=function(e){return "hex"===e?this.priv.toString(16,2):this.priv},Qy.prototype._importPrivate=function(e,t){if(this.priv=new ay(e,t||16),"mont"===this.ec.curve.type){var r=this.ec.curve.one,i=r.ushln(252).sub(r).ushln(3);this.priv=this.priv.or(r.ushln(254)),this.priv=this.priv.and(i);}else this.priv=this.priv.umod(this.ec.curve.n);},Qy.prototype._importPublic=function(e,t){if(e.x||e.y)return "mont"===this.ec.curve.type?Yy(e.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||Yy(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y));this.pub=this.ec.curve.decodePoint(e,t);},Qy.prototype.derive=function(e){return e.mul(this.priv).getX()},Qy.prototype.sign=function(e,t,r){return this.ec.sign(e,this,t,r)},Qy.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},Qy.prototype.inspect=function(){return "<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"};var eb=dy.assert;function tb(e,t){if(e instanceof tb)return e;this._importDER(e,t)||(eb(e.r&&e.s,"Signature without r or s"),this.r=new ay(e.r,16),this.s=new ay(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam);}var rb=tb;function ib(){this.place=0;}function nb(e,t){var r=e[t.place++];if(!(128&r))return r;for(var i=15&r,n=0,a=0,s=t.place;a<i;a++,s++)n<<=8,n|=e[s];return t.place=s,n}function ab(e){for(var t=0,r=e.length-1;!e[t]&&!(128&e[t+1])&&t<r;)t++;return 0===t?e:e.slice(t)}function sb(e,t){if(t<128)e.push(t);else {var r=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|r);--r;)e.push(t>>>(r<<3)&255);e.push(t);}}tb.prototype._importDER=function(e,t){e=dy.toArray(e,t);var r=new ib;if(48!==e[r.place++])return !1;if(nb(e,r)+r.place!==e.length)return !1;if(2!==e[r.place++])return !1;var i=nb(e,r),n=e.slice(r.place,i+r.place);if(r.place+=i,2!==e[r.place++])return !1;var a=nb(e,r);if(e.length!==a+r.place)return !1;var s=e.slice(r.place,a+r.place);return 0===n[0]&&128&n[1]&&(n=n.slice(1)),0===s[0]&&128&s[1]&&(s=s.slice(1)),this.r=new ay(n),this.s=new ay(s),this.recoveryParam=null,!0},tb.prototype.toDER=function(e){var t=this.r.toArray(),r=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&r[0]&&(r=[0].concat(r)),t=ab(t),r=ab(r);!(r[0]||128&r[1]);)r=r.slice(1);var i=[2];sb(i,t.length),(i=i.concat(t)).push(2),sb(i,r.length);var n=i.concat(r),a=[48];return sb(a,n.length),a=a.concat(n),dy.encode(a,e)};var ob=dy.assert;function cb(e){if(!(this instanceof cb))return new cb(e);"string"==typeof e&&(ob($y.hasOwnProperty(e),"Unknown curve "+e),e=$y[e]),e instanceof $y.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash;}var ub=cb;cb.prototype.keyPair=function(e){return new Jy(this,e)},cb.prototype.keyFromPrivate=function(e,t){return Jy.fromPrivate(this,e,t)},cb.prototype.keyFromPublic=function(e,t){return Jy.fromPublic(this,e,t)},cb.prototype.genKeyPair=function(e){e||(e={});var t=new Xy({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||fy(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()});if("mont"===this.curve.type){var r=new ay(t.generate(32));return this.keyFromPrivate(r)}for(var i=this.n.byteLength(),n=this.n.sub(new ay(2));;){if(!((r=new ay(t.generate(i))).cmp(n)>0))return r.iaddn(1),this.keyFromPrivate(r)}},cb.prototype._truncateToN=function(e,t,r){var i=(r=r||8*e.byteLength())-this.n.bitLength();return i>0&&(e=e.ushrn(i)),!t&&e.cmp(this.n)>=0?e.sub(this.n):e},cb.prototype.truncateMsg=function(e){var t;return e instanceof Uint8Array?(t=8*e.byteLength,e=this._truncateToN(new ay(e,16),!1,t)):"string"==typeof e?(t=4*e.length,e=this._truncateToN(new ay(e,16),!1,t)):e=this._truncateToN(new ay(e,16)),e},cb.prototype.sign=function(e,t,r,i){"object"==typeof r&&(i=r,r=null),i||(i={}),t=this.keyFromPrivate(t,r),e=this.truncateMsg(e);for(var n=this.n.byteLength(),a=t.getPrivate().toArray("be",n),s=e.toArray("be",n),o=new Xy({hash:this.hash,entropy:a,nonce:s,pers:i.pers,persEnc:i.persEnc||"utf8"}),c=this.n.sub(new ay(1)),u=0;;u++){var h=i.k?i.k(u):new ay(o.generate(this.n.byteLength()));if(!((h=this._truncateToN(h,!0)).cmpn(1)<=0||h.cmp(c)>=0)){var d=this.g.mul(h);if(!d.isInfinity()){var f=d.getX(),l=f.umod(this.n);if(0!==l.cmpn(0)){var p=h.invm(this.n).mul(l.mul(t.getPrivate()).iadd(e));if(0!==(p=p.umod(this.n)).cmpn(0)){var y=(d.getY().isOdd()?1:0)|(0!==f.cmp(l)?2:0);return i.canonical&&p.cmp(this.nh)>0&&(p=this.n.sub(p),y^=1),new rb({r:l,s:p,recoveryParam:y})}}}}}},cb.prototype.verify=function(e,t,r,i){return r=this.keyFromPublic(r,i),t=new rb(t,"hex"),this._verify(this.truncateMsg(e),t,r)||this._verify(this._truncateToN(new ay(e,16)),t,r)},cb.prototype._verify=function(e,t,r){var i=t.r,n=t.s;if(i.cmpn(1)<0||i.cmp(this.n)>=0)return !1;if(n.cmpn(1)<0||n.cmp(this.n)>=0)return !1;var a,s=n.invm(this.n),o=s.mul(e).umod(this.n),c=s.mul(i).umod(this.n);return this.curve._maxwellTrick?!(a=this.g.jmulAdd(o,r.getPublic(),c)).isInfinity()&&a.eqXToP(i):!(a=this.g.mulAdd(o,r.getPublic(),c)).isInfinity()&&0===a.getX().umod(this.n).cmp(i)},cb.prototype.recoverPubKey=function(e,t,r,i){ob((3&r)===r,"The recovery param is more than two bits"),t=new rb(t,i);var n=this.n,a=new ay(e),s=t.r,o=t.s,c=1&r,u=r>>1;if(s.cmp(this.curve.p.umod(this.curve.n))>=0&&u)throw Error("Unable to find sencond key candinate");s=u?this.curve.pointFromX(s.add(this.curve.n),c):this.curve.pointFromX(s,c);var h=t.r.invm(n),d=n.sub(a).mul(h).umod(n),f=o.mul(h).umod(n);return this.g.mulAdd(d,s,f)},cb.prototype.getKeyRecoveryParam=function(e,t,r,i){if(null!==(t=new rb(t,i)).recoveryParam)return t.recoveryParam;for(var n=0;n<4;n++){var a;try{a=this.recoverPubKey(e,t,n);}catch(e){continue}if(a.eq(r))return n}throw Error("Unable to find valid recovery factor")};var hb=dy.assert,db=dy.parseBytes,fb=dy.cachedProperty;function lb(e,t){if(this.eddsa=e,t.hasOwnProperty("secret")&&(this._secret=db(t.secret)),e.isPoint(t.pub))this._pub=t.pub;else if(this._pubBytes=db(t.pub),this._pubBytes&&33===this._pubBytes.length&&64===this._pubBytes[0]&&(this._pubBytes=this._pubBytes.slice(1,33)),this._pubBytes&&32!==this._pubBytes.length)throw Error("Unknown point compression format")}lb.fromPublic=function(e,t){return t instanceof lb?t:new lb(e,{pub:t})},lb.fromSecret=function(e,t){return t instanceof lb?t:new lb(e,{secret:t})},lb.prototype.secret=function(){return this._secret},fb(lb,"pubBytes",(function(){return this.eddsa.encodePoint(this.pub())})),fb(lb,"pub",(function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())})),fb(lb,"privBytes",(function(){var e=this.eddsa,t=this.hash(),r=e.encodingLength-1,i=t.slice(0,e.encodingLength);return i[0]&=248,i[r]&=127,i[r]|=64,i})),fb(lb,"priv",(function(){return this.eddsa.decodeInt(this.privBytes())})),fb(lb,"hash",(function(){return this.eddsa.hash().update(this.secret()).digest()})),fb(lb,"messagePrefix",(function(){return this.hash().slice(this.eddsa.encodingLength)})),lb.prototype.sign=function(e){return hb(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)},lb.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)},lb.prototype.getSecret=function(e){return hb(this._secret,"KeyPair is public only"),dy.encode(this.secret(),e)},lb.prototype.getPublic=function(e,t){return dy.encode((t?[64]:[]).concat(this.pubBytes()),e)};var pb=lb,yb=dy.assert,bb=dy.cachedProperty,mb=dy.parseBytes;function gb(e,t){this.eddsa=e,"object"!=typeof t&&(t=mb(t)),Array.isArray(t)&&(t={R:t.slice(0,e.encodingLength),S:t.slice(e.encodingLength)}),yb(t.R&&t.S,"Signature without R or S"),e.isPoint(t.R)&&(this._R=t.R),t.S instanceof ay&&(this._S=t.S),this._Rencoded=Array.isArray(t.R)?t.R:t.Rencoded,this._Sencoded=Array.isArray(t.S)?t.S:t.Sencoded;}bb(gb,"S",(function(){return this.eddsa.decodeInt(this.Sencoded())})),bb(gb,"R",(function(){return this.eddsa.decodePoint(this.Rencoded())})),bb(gb,"Rencoded",(function(){return this.eddsa.encodePoint(this.R())})),bb(gb,"Sencoded",(function(){return this.eddsa.encodeInt(this.S())})),gb.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())},gb.prototype.toHex=function(){return dy.encode(this.toBytes(),"hex").toUpperCase()};var wb=gb,vb=dy.assert,_b=dy.parseBytes;function kb(e){if(vb("ed25519"===e,"only tested with ed25519 so far"),!(this instanceof kb))return new kb(e);e=$y[e].curve;this.curve=e,this.g=e.g,this.g.precompute(e.n.bitLength()+1),this.pointClass=e.point().constructor,this.encodingLength=Math.ceil(e.n.bitLength()/8),this.hash=Gy.sha512;}var Ab=kb;kb.prototype.sign=function(e,t){e=_b(e);var r=this.keyFromSecret(t),i=this.hashInt(r.messagePrefix(),e),n=this.g.mul(i),a=this.encodePoint(n),s=this.hashInt(a,r.pubBytes(),e).mul(r.priv()),o=i.add(s).umod(this.curve.n);return this.makeSignature({R:n,S:o,Rencoded:a})},kb.prototype.verify=function(e,t,r){e=_b(e),t=this.makeSignature(t);var i=this.keyFromPublic(r),n=this.hashInt(t.Rencoded(),i.pubBytes(),e),a=this.g.mul(t.S());return t.R().add(i.pub().mul(n)).eq(a)},kb.prototype.hashInt=function(){for(var e=this.hash(),t=0;t<arguments.length;t++)e.update(arguments[t]);return dy.intFromLE(e.digest()).umod(this.curve.n)},kb.prototype.keyPair=function(e){return new pb(this,e)},kb.prototype.keyFromPublic=function(e){return pb.fromPublic(this,e)},kb.prototype.keyFromSecret=function(e){return pb.fromSecret(this,e)},kb.prototype.genKeyPair=function(e){e||(e={});var t=new Xy({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||fy(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.curve.n.toArray()});return this.keyFromSecret(t.generate(32))},kb.prototype.makeSignature=function(e){return e instanceof wb?e:new wb(this,e)},kb.prototype.encodePoint=function(e){var t=e.getY().toArray("le",this.encodingLength);return t[this.encodingLength-1]|=e.getX().isOdd()?128:0,t},kb.prototype.decodePoint=function(e){var t=(e=dy.parseBytes(e)).length-1,r=e.slice(0,t).concat(-129&e[t]),i=0!=(128&e[t]),n=dy.intFromLE(r);return this.curve.pointFromY(n,i)},kb.prototype.encodeInt=function(e){return e.toArray("le",this.encodingLength)},kb.prototype.decodeInt=function(e){return dy.intFromLE(e)},kb.prototype.isPoint=function(e){return e instanceof this.pointClass};var Sb=it((function(e,t){var r=t;r.utils=dy,r.rand=fy,r.curve=Iy,r.curves=$y,r.ec=ub,r.eddsa=Ab;})),Eb=/*#__PURE__*/Object.freeze({__proto__:null,default:Sb,__moduleExports:Sb});

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  });

  var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * Process a public key to get a profile
   * @function
   * @param {PublicKey} publicKey - The public key to parse
   * @returns {Promise<Profile>} The profile from the processed OpenPGP key
   * @example
   * const key = doip.keys.fetchURI('hkp:alice@domain.tld');
   * const profile = doip.keys.parsePublicKey(key);
   * profile.personas[0].claims.forEach(claim => {
   *   console.log(claim.uri);
   * });
   */
  async function parsePublicKey (publicKey) {
    if (!(publicKey && (publicKey instanceof ph))) {
      throw new Error('Invalid public key')
    }

    const fingerprint = publicKey.getFingerprint();
    const primaryUser = await publicKey.getPrimaryUser();
    const users = publicKey.users;
    const personas = [];

    users.forEach((user, i) => {
      if (!user.userID) return

      const pe = new Persona(user.userID.name, []);
      pe.setIdentifier(user.userID.userID);
      pe.setDescription(user.userID.comment);
      pe.setEmailAddress(user.userID.email);

      if ('selfCertifications' in user && user.selfCertifications.length > 0) {
        const selfCertification = user.selfCertifications.sort((e1, e2) => e2.created.getTime() - e1.created.getTime())[0];

        if (selfCertification.revoked) {
          pe.revoke();
        }
        const notations = selfCertification.rawNotations;
        pe.claims = notations
          .filter(
            ({ name, humanReadable }) =>
              humanReadable && (name === 'proof@ariadne.id' || name === 'proof@metacode.biz')
          )
          .map(
            ({ value }) =>
              new Claim(new TextDecoder().decode(value), `openpgp4fpr:${fingerprint}`)
          );
      }

      personas.push(pe);
    });

    const profile = new Profile(ProfileType.OPENPGP, `openpgp4fpr:${fingerprint}`, personas);
    profile.primaryPersonaIndex = primaryUser.index;

    profile.publicKey.keyType = PublicKeyType.OPENPGP;
    profile.publicKey.fingerprint = fingerprint;
    profile.publicKey.encoding = PublicKeyEncoding.ARMORED_PGP;
    profile.publicKey.encodedKey = publicKey.armor();
    profile.publicKey.key = publicKey;

    return profile
  }

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * Contains default values
   * @module defaults
   */

  /**
   * The default claim verification config used throughout the library
   * @type {import('./types').VerificationConfig}
   */
  const opts = {
    proxy: {
      hostname: null,
      policy: ProxyPolicy.NEVER
    },
    claims: {
      activitypub: {
        url: null,
        privateKey: null
      },
      irc: {
        nick: null
      },
      matrix: {
        instance: null,
        accessToken: null
      },
      telegram: {
        token: null
      },
      xmpp: {
        service: null,
        username: null,
        password: null
      }
    }
  };

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * @module utils
   */

  /**
   * Generate an URL to request data from a proxy server
   * @param {string} type - The name of the fetcher the proxy must use
   * @param {object} data - The data the proxy must provide to the fetcher
   * @param {import('./types').VerificationConfig} opts - Options to enable the request
   * @returns {string} Generated proxy URL
   */
  function generateProxyURL (type, data, opts) {
    try {
      isFQDN(opts.proxy.hostname);
    } catch (err) {
      throw new Error('Invalid proxy hostname')
    }

    const queryStrings = [];

    Object.keys(data).forEach((key) => {
      queryStrings.push(`${key}=${encodeURIComponent(data[key])}`);
    });

    const scheme = opts.proxy.scheme ?? 'https';

    return `${scheme}://${opts.proxy.hostname}/api/3/get/${type}?${queryStrings.join(
    '&'
  )}`
  }

  /**
   * Generate the string that must be found in the proof to verify a claim
   * @param {string} fingerprint - The fingerprint of the claim
   * @param {ClaimFormat} format - The claim's format
   * @returns {string} Generate claim
   */
  function generateClaim (fingerprint, format) {
    switch (format) {
      case ClaimFormat.URI:
        if (fingerprint.match(/^(openpgp4fpr|aspe):/)) {
          return fingerprint
        }
        return `openpgp4fpr:${fingerprint}`
      case ClaimFormat.FINGERPRINT:
        return fingerprint
      default:
        throw new Error('No valid claim format')
    }
  }

  /**
   * Get the URIs from a string and return them as an array
   * @param {string} text - The text that may contain URIs
   * @returns {Array<string>} List of URIs extracted from input
   */
  function getUriFromString (text) {
    const re = /((([A-Za-z0-9]+:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www\.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w\-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[.!/\\\w]*))?)/gi;
    const res = text.match(re);

    const urls = [];

    if (!res) {
      return []
    }

    res.forEach(url => {
      // Remove bad trailing characters
      let hasBadTrailingChars = true;

      while (hasBadTrailingChars) {
        const lastChar = url.charAt(url.length - 1);
        if ('?!.'.indexOf(lastChar) === -1) {
          hasBadTrailingChars = false;
          continue
        }
        url = url.substring(0, url.length - 1);
      }

      urls.push(url);
    });

    return urls
  }

  /*!
   * hash-wasm (https://www.npmjs.com/package/hash-wasm)
   * (c) Dani Biro
   * @license MIT
   */

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol */


  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  class Mutex {
      constructor() {
          this.mutex = Promise.resolve();
      }
      lock() {
          let begin = () => { };
          this.mutex = this.mutex.then(() => new Promise(begin));
          return new Promise((res) => {
              begin = res;
          });
      }
      dispatch(fn) {
          return __awaiter(this, void 0, void 0, function* () {
              const unlock = yield this.lock();
              try {
                  return yield Promise.resolve(fn());
              }
              finally {
                  unlock();
              }
          });
      }
  }

  /* eslint-disable import/prefer-default-export */
  /* eslint-disable no-bitwise */
  var _a$1;
  function getGlobal() {
      if (typeof globalThis !== 'undefined')
          return globalThis;
      // eslint-disable-next-line no-restricted-globals
      if (typeof self !== 'undefined')
          return self;
      if (typeof window !== 'undefined')
          return window;
      return global$1;
  }
  const globalObject = getGlobal();
  const nodeBuffer = (_a$1 = globalObject.Buffer) !== null && _a$1 !== void 0 ? _a$1 : null;
  const textEncoder = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
  function hexCharCodesToInt(a, b) {
      return (((a & 0xF) + ((a >> 6) | ((a >> 3) & 0x8))) << 4) | ((b & 0xF) + ((b >> 6) | ((b >> 3) & 0x8)));
  }
  function writeHexToUInt8(buf, str) {
      const size = str.length >> 1;
      for (let i = 0; i < size; i++) {
          const index = i << 1;
          buf[i] = hexCharCodesToInt(str.charCodeAt(index), str.charCodeAt(index + 1));
      }
  }
  function hexStringEqualsUInt8(str, buf) {
      if (str.length !== buf.length * 2) {
          return false;
      }
      for (let i = 0; i < buf.length; i++) {
          const strIndex = i << 1;
          if (buf[i] !== hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) {
              return false;
          }
      }
      return true;
  }
  const alpha = 'a'.charCodeAt(0) - 10;
  const digit = '0'.charCodeAt(0);
  function getDigestHex(tmpBuffer, input, hashLength) {
      let p = 0;
      /* eslint-disable no-plusplus */
      for (let i = 0; i < hashLength; i++) {
          let nibble = input[i] >>> 4;
          tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
          nibble = input[i] & 0xF;
          tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
      }
      /* eslint-enable no-plusplus */
      return String.fromCharCode.apply(null, tmpBuffer);
  }
  const getUInt8Buffer = nodeBuffer !== null
      ? (data) => {
          if (typeof data === 'string') {
              const buf = nodeBuffer.from(data, 'utf8');
              return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
          }
          if (nodeBuffer.isBuffer(data)) {
              return new Uint8Array(data.buffer, data.byteOffset, data.length);
          }
          if (ArrayBuffer.isView(data)) {
              return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
          }
          throw new Error('Invalid data type!');
      }
      : (data) => {
          if (typeof data === 'string') {
              return textEncoder.encode(data);
          }
          if (ArrayBuffer.isView(data)) {
              return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
          }
          throw new Error('Invalid data type!');
      };
  const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  const base64Lookup = new Uint8Array(256);
  for (let i = 0; i < base64Chars.length; i++) {
      base64Lookup[base64Chars.charCodeAt(i)] = i;
  }
  function encodeBase64(data, pad = true) {
      const len = data.length;
      const extraBytes = len % 3;
      const parts = [];
      const len2 = len - extraBytes;
      for (let i = 0; i < len2; i += 3) {
          const tmp = ((data[i] << 16) & 0xFF0000)
              + ((data[i + 1] << 8) & 0xFF00)
              + (data[i + 2] & 0xFF);
          const triplet = base64Chars.charAt((tmp >> 18) & 0x3F)
              + base64Chars.charAt((tmp >> 12) & 0x3F)
              + base64Chars.charAt((tmp >> 6) & 0x3F)
              + base64Chars.charAt(tmp & 0x3F);
          parts.push(triplet);
      }
      if (extraBytes === 1) {
          const tmp = data[len - 1];
          const a = base64Chars.charAt(tmp >> 2);
          const b = base64Chars.charAt((tmp << 4) & 0x3F);
          parts.push(`${a}${b}`);
          if (pad) {
              parts.push('==');
          }
      }
      else if (extraBytes === 2) {
          const tmp = (data[len - 2] << 8) + data[len - 1];
          const a = base64Chars.charAt(tmp >> 10);
          const b = base64Chars.charAt((tmp >> 4) & 0x3F);
          const c = base64Chars.charAt((tmp << 2) & 0x3F);
          parts.push(`${a}${b}${c}`);
          if (pad) {
              parts.push('=');
          }
      }
      return parts.join('');
  }
  function getDecodeBase64Length(data) {
      let bufferLength = Math.floor(data.length * 0.75);
      const len = data.length;
      if (data[len - 1] === '=') {
          bufferLength -= 1;
          if (data[len - 2] === '=') {
              bufferLength -= 1;
          }
      }
      return bufferLength;
  }
  function decodeBase64(data) {
      const bufferLength = getDecodeBase64Length(data);
      const len = data.length;
      const bytes = new Uint8Array(bufferLength);
      let p = 0;
      for (let i = 0; i < len; i += 4) {
          const encoded1 = base64Lookup[data.charCodeAt(i)];
          const encoded2 = base64Lookup[data.charCodeAt(i + 1)];
          const encoded3 = base64Lookup[data.charCodeAt(i + 2)];
          const encoded4 = base64Lookup[data.charCodeAt(i + 3)];
          bytes[p] = (encoded1 << 2) | (encoded2 >> 4);
          p += 1;
          bytes[p] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          p += 1;
          bytes[p] = ((encoded3 & 3) << 6) | (encoded4 & 63);
          p += 1;
      }
      return bytes;
  }

  const MAX_HEAP = 16 * 1024;
  const WASM_FUNC_HASH_LENGTH = 4;
  const wasmMutex = new Mutex();
  const wasmModuleCache = new Map();
  function WASMInterface(binary, hashLength) {
      return __awaiter(this, void 0, void 0, function* () {
          let wasmInstance = null;
          let memoryView = null;
          let initialized = false;
          if (typeof WebAssembly === 'undefined') {
              throw new Error('WebAssembly is not supported in this environment!');
          }
          const writeMemory = (data, offset = 0) => {
              memoryView.set(data, offset);
          };
          const getMemory = () => memoryView;
          const getExports = () => wasmInstance.exports;
          const setMemorySize = (totalSize) => {
              wasmInstance.exports.Hash_SetMemorySize(totalSize);
              const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
              const memoryBuffer = wasmInstance.exports.memory.buffer;
              memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
          };
          const getStateSize = () => {
              const view = new DataView(wasmInstance.exports.memory.buffer);
              const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
              return stateSize;
          };
          const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
              if (!wasmModuleCache.has(binary.name)) {
                  const asm = decodeBase64(binary.data);
                  const promise = WebAssembly.compile(asm);
                  wasmModuleCache.set(binary.name, promise);
              }
              const module = yield wasmModuleCache.get(binary.name);
              wasmInstance = yield WebAssembly.instantiate(module, {
              // env: {
              //   emscripten_memcpy_big: (dest, src, num) => {
              //     const memoryBuffer = wasmInstance.exports.memory.buffer;
              //     const memView = new Uint8Array(memoryBuffer, 0);
              //     memView.set(memView.subarray(src, src + num), dest);
              //   },
              //   print_memory: (offset, len) => {
              //     const memoryBuffer = wasmInstance.exports.memory.buffer;
              //     const memView = new Uint8Array(memoryBuffer, 0);
              //     console.log('print_int32', memView.subarray(offset, offset + len));
              //   },
              // },
              });
              // wasmInstance.exports._start();
          }));
          const setupInterface = () => __awaiter(this, void 0, void 0, function* () {
              if (!wasmInstance) {
                  yield loadWASMPromise;
              }
              const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
              const memoryBuffer = wasmInstance.exports.memory.buffer;
              memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
          });
          const init = (bits = null) => {
              initialized = true;
              wasmInstance.exports.Hash_Init(bits);
          };
          const updateUInt8Array = (data) => {
              let read = 0;
              while (read < data.length) {
                  const chunk = data.subarray(read, read + MAX_HEAP);
                  read += chunk.length;
                  memoryView.set(chunk);
                  wasmInstance.exports.Hash_Update(chunk.length);
              }
          };
          const update = (data) => {
              if (!initialized) {
                  throw new Error('update() called before init()');
              }
              const Uint8Buffer = getUInt8Buffer(data);
              updateUInt8Array(Uint8Buffer);
          };
          const digestChars = new Uint8Array(hashLength * 2);
          const digest = (outputType, padding = null) => {
              if (!initialized) {
                  throw new Error('digest() called before init()');
              }
              initialized = false;
              wasmInstance.exports.Hash_Final(padding);
              if (outputType === 'binary') {
                  // the data is copied to allow GC of the original memory object
                  return memoryView.slice(0, hashLength);
              }
              return getDigestHex(digestChars, memoryView, hashLength);
          };
          const save = () => {
              if (!initialized) {
                  throw new Error('save() can only be called after init() and before digest()');
              }
              const stateOffset = wasmInstance.exports.Hash_GetState();
              const stateLength = getStateSize();
              const memoryBuffer = wasmInstance.exports.memory.buffer;
              const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
              // prefix is 4 bytes from SHA1 hash of the WASM binary
              // it is used to detect incompatible internal states between different versions of hash-wasm
              const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
              writeHexToUInt8(prefixedState, binary.hash);
              prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
              return prefixedState;
          };
          const load = (state) => {
              if (!(state instanceof Uint8Array)) {
                  throw new Error('load() expects an Uint8Array generated by save()');
              }
              const stateOffset = wasmInstance.exports.Hash_GetState();
              const stateLength = getStateSize();
              const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
              const memoryBuffer = wasmInstance.exports.memory.buffer;
              if (state.length !== overallLength) {
                  throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
              }
              if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
                  throw new Error('This state was written by an incompatible hash implementation');
              }
              const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
              new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
              initialized = true;
          };
          const isDataShort = (data) => {
              if (typeof data === 'string') {
                  // worst case is 4 bytes / char
                  return data.length < MAX_HEAP / 4;
              }
              return data.byteLength < MAX_HEAP;
          };
          let canSimplify = isDataShort;
          switch (binary.name) {
              case 'argon2':
              case 'scrypt':
                  canSimplify = () => true;
                  break;
              case 'blake2b':
              case 'blake2s':
                  // if there is a key at blake2 then cannot simplify
                  canSimplify = (data, initParam) => initParam <= 512 && isDataShort(data);
                  break;
              case 'blake3':
                  // if there is a key at blake3 then cannot simplify
                  canSimplify = (data, initParam) => initParam === 0 && isDataShort(data);
                  break;
              case 'xxhash64': // cannot simplify
              case 'xxhash3':
              case 'xxhash128':
                  canSimplify = () => false;
                  break;
          }
          // shorthand for (init + update + digest) for better performance
          const calculate = (data, initParam = null, digestParam = null) => {
              if (!canSimplify(data, initParam)) {
                  init(initParam);
                  update(data);
                  return digest('hex', digestParam);
              }
              const buffer = getUInt8Buffer(data);
              memoryView.set(buffer);
              wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
              return getDigestHex(digestChars, memoryView, hashLength);
          };
          yield setupInterface();
          return {
              getMemory,
              writeMemory,
              getExports,
              setMemorySize,
              init,
              update,
              digest,
              save,
              load,
              calculate,
              hashLength,
          };
      });
  }

  new Mutex();

  var name$j = "blake2b";
  var data$j = "AGFzbQEAAAABEQRgAAF/YAJ/fwBgAX8AYAAAAwoJAAECAwECAgABBQQBAQICBg4CfwFBsIsFC38AQYAICwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACkhhc2hfRmluYWwAAwlIYXNoX0luaXQABQtIYXNoX1VwZGF0ZQAGDUhhc2hfR2V0U3RhdGUABw5IYXNoX0NhbGN1bGF0ZQAIClNUQVRFX1NJWkUDAQrTOAkFAEGACQvrAgIFfwF+AkAgAUEBSA0AAkACQAJAQYABQQAoAuCKASICayIDIAFIDQAgASEEDAELQQBBADYC4IoBAkAgAkH/AEoNACACQeCJAWohBSAAIQRBACEGA0AgBSAELQAAOgAAIARBAWohBCAFQQFqIQUgAyAGQQFqIgZB/wFxSg0ACwtBAEEAKQPAiQEiB0KAAXw3A8CJAUEAQQApA8iJASAHQv9+Vq18NwPIiQFB4IkBEAIgACADaiEAAkAgASADayIEQYEBSA0AIAIgAWohBQNAQQBBACkDwIkBIgdCgAF8NwPAiQFBAEEAKQPIiQEgB0L/flatfDcDyIkBIAAQAiAAQYABaiEAIAVBgH9qIgVBgAJLDQALIAVBgH9qIQQMAQsgBEEATA0BC0EAIQUDQCAFQQAoAuCKAWpB4IkBaiAAIAVqLQAAOgAAIAQgBUEBaiIFQf8BcUoNAAsLQQBBACgC4IoBIARqNgLgigELC78uASR+QQBBACkD0IkBQQApA7CJASIBQQApA5CJAXwgACkDICICfCIDhULr+obav7X2wR+FQiCJIgRCq/DT9K/uvLc8fCIFIAGFQiiJIgYgA3wgACkDKCIBfCIHIASFQjCJIgggBXwiCSAGhUIBiSIKQQApA8iJAUEAKQOoiQEiBEEAKQOIiQF8IAApAxAiA3wiBYVCn9j52cKR2oKbf4VCIIkiC0K7zqqm2NDrs7t/fCIMIASFQiiJIg0gBXwgACkDGCIEfCIOfCAAKQNQIgV8Ig9BACkDwIkBQQApA6CJASIQQQApA4CJASIRfCAAKQMAIgZ8IhKFQtGFmu/6z5SH0QCFQiCJIhNCiJLznf/M+YTqAHwiFCAQhUIoiSIVIBJ8IAApAwgiEHwiFiAThUIwiSIXhUIgiSIYQQApA9iJAUEAKQO4iQEiE0EAKQOYiQF8IAApAzAiEnwiGYVC+cL4m5Gjs/DbAIVCIIkiGkLx7fT4paf9p6V/fCIbIBOFQiiJIhwgGXwgACkDOCITfCIZIBqFQjCJIhogG3wiG3wiHSAKhUIoiSIeIA98IAApA1giCnwiDyAYhUIwiSIYIB18Ih0gDiALhUIwiSIOIAx8Ih8gDYVCAYkiDCAWfCAAKQNAIgt8Ig0gGoVCIIkiFiAJfCIaIAyFQiiJIiAgDXwgACkDSCIJfCIhIBaFQjCJIhYgGyAchUIBiSIMIAd8IAApA2AiB3wiDSAOhUIgiSIOIBcgFHwiFHwiFyAMhUIoiSIbIA18IAApA2giDHwiHCAOhUIwiSIOIBd8IhcgG4VCAYkiGyAZIBQgFYVCAYkiFHwgACkDcCINfCIVIAiFQiCJIhkgH3wiHyAUhUIoiSIUIBV8IAApA3giCHwiFXwgDHwiIoVCIIkiI3wiJCAbhUIoiSIbICJ8IBJ8IiIgFyAYIBUgGYVCMIkiFSAffCIZIBSFQgGJIhQgIXwgDXwiH4VCIIkiGHwiFyAUhUIoiSIUIB98IAV8Ih8gGIVCMIkiGCAXfCIXIBSFQgGJIhR8IAF8IiEgFiAafCIWIBUgHSAehUIBiSIaIBx8IAl8IhyFQiCJIhV8Ih0gGoVCKIkiGiAcfCAIfCIcIBWFQjCJIhWFQiCJIh4gGSAOIBYgIIVCAYkiFiAPfCACfCIPhUIgiSIOfCIZIBaFQiiJIhYgD3wgC3wiDyAOhUIwiSIOIBl8Ihl8IiAgFIVCKIkiFCAhfCAEfCIhIB6FQjCJIh4gIHwiICAiICOFQjCJIiIgJHwiIyAbhUIBiSIbIBx8IAp8IhwgDoVCIIkiDiAXfCIXIBuFQiiJIhsgHHwgE3wiHCAOhUIwiSIOIBkgFoVCAYkiFiAffCAQfCIZICKFQiCJIh8gFSAdfCIVfCIdIBaFQiiJIhYgGXwgB3wiGSAfhUIwiSIfIB18Ih0gFoVCAYkiFiAVIBqFQgGJIhUgD3wgBnwiDyAYhUIgiSIYICN8IhogFYVCKIkiFSAPfCADfCIPfCAHfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgBnwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAOIBd8Ig4gDyAYhUIwiSIPICAgFIVCAYkiFCAZfCAKfCIXhUIgiSIYfCIZIBSFQiiJIhQgF3wgC3wiF3wgBXwiICAPIBp8Ig8gHyAOIBuFQgGJIg4gIXwgCHwiGoVCIIkiG3wiHyAOhUIoiSIOIBp8IAx8IhogG4VCMIkiG4VCIIkiISAdIB4gDyAVhUIBiSIPIBx8IAF8IhWFQiCJIhx8Ih0gD4VCKIkiDyAVfCADfCIVIByFQjCJIhwgHXwiHXwiHiAWhUIoiSIWICB8IA18IiAgIYVCMIkiISAefCIeIBogFyAYhUIwiSIXIBl8IhggFIVCAYkiFHwgCXwiGSAchUIgiSIaICR8IhwgFIVCKIkiFCAZfCACfCIZIBqFQjCJIhogHSAPhUIBiSIPICJ8IAR8Ih0gF4VCIIkiFyAbIB98Iht8Ih8gD4VCKIkiDyAdfCASfCIdIBeFQjCJIhcgH3wiHyAPhUIBiSIPIBsgDoVCAYkiDiAVfCATfCIVICOFQiCJIhsgGHwiGCAOhUIoiSIOIBV8IBB8IhV8IAx8IiKFQiCJIiN8IiQgD4VCKIkiDyAifCAHfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBogHHwiGiAVIBuFQjCJIhUgHiAWhUIBiSIWIB18IAR8IhuFQiCJIhx8Ih0gFoVCKIkiFiAbfCAQfCIbfCABfCIeIBUgGHwiFSAXIBogFIVCAYkiFCAgfCATfCIYhUIgiSIXfCIaIBSFQiiJIhQgGHwgCXwiGCAXhUIwiSIXhUIgiSIgIB8gISAVIA6FQgGJIg4gGXwgCnwiFYVCIIkiGXwiHyAOhUIoiSIOIBV8IA18IhUgGYVCMIkiGSAffCIffCIhIA+FQiiJIg8gHnwgBXwiHiAghUIwiSIgICF8IiEgGyAchUIwiSIbIB18IhwgFoVCAYkiFiAYfCADfCIYIBmFQiCJIhkgJHwiHSAWhUIoiSIWIBh8IBJ8IhggGYVCMIkiGSAfIA6FQgGJIg4gInwgAnwiHyAbhUIgiSIbIBcgGnwiF3wiGiAOhUIoiSIOIB98IAZ8Ih8gG4VCMIkiGyAafCIaIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAh8IhUgI4VCIIkiFyAcfCIcIBSFQiiJIhQgFXwgC3wiFXwgBXwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IAh8IiIgGiAgIBUgF4VCMIkiFSAcfCIXIBSFQgGJIhQgGHwgCXwiGIVCIIkiHHwiGiAUhUIoiSIUIBh8IAZ8IhggHIVCMIkiHCAafCIaIBSFQgGJIhR8IAR8IiAgGSAdfCIZIBUgISAPhUIBiSIPIB98IAN8Ih2FQiCJIhV8Ih8gD4VCKIkiDyAdfCACfCIdIBWFQjCJIhWFQiCJIiEgFyAbIBkgFoVCAYkiFiAefCABfCIZhUIgiSIbfCIXIBaFQiiJIhYgGXwgE3wiGSAbhUIwiSIbIBd8Ihd8Ih4gFIVCKIkiFCAgfCAMfCIgICGFQjCJIiEgHnwiHiAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIB18IBJ8Ih0gG4VCIIkiGyAafCIaIA6FQiiJIg4gHXwgC3wiHSAbhUIwiSIbIBcgFoVCAYkiFiAYfCANfCIXICKFQiCJIhggFSAffCIVfCIfIBaFQiiJIhYgF3wgEHwiFyAYhUIwiSIYIB98Ih8gFoVCAYkiFiAVIA+FQgGJIg8gGXwgCnwiFSAchUIgiSIZICN8IhwgD4VCKIkiDyAVfCAHfCIVfCASfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgBXwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAbIBp8IhogFSAZhUIwiSIVIB4gFIVCAYkiFCAXfCADfCIXhUIgiSIZfCIbIBSFQiiJIhQgF3wgB3wiF3wgAnwiHiAVIBx8IhUgGCAaIA6FQgGJIg4gIHwgC3wiGoVCIIkiGHwiHCAOhUIoiSIOIBp8IAR8IhogGIVCMIkiGIVCIIkiICAfICEgFSAPhUIBiSIPIB18IAZ8IhWFQiCJIh18Ih8gD4VCKIkiDyAVfCAKfCIVIB2FQjCJIh0gH3wiH3wiISAWhUIoiSIWIB58IAx8Ih4gIIVCMIkiICAhfCIhIBogFyAZhUIwiSIXIBt8IhkgFIVCAYkiFHwgEHwiGiAdhUIgiSIbICR8Ih0gFIVCKIkiFCAafCAJfCIaIBuFQjCJIhsgHyAPhUIBiSIPICJ8IBN8Ih8gF4VCIIkiFyAYIBx8Ihh8IhwgD4VCKIkiDyAffCABfCIfIBeFQjCJIhcgHHwiHCAPhUIBiSIPIBggDoVCAYkiDiAVfCAIfCIVICOFQiCJIhggGXwiGSAOhUIoiSIOIBV8IA18IhV8IA18IiKFQiCJIiN8IiQgD4VCKIkiDyAifCAMfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBsgHXwiGyAVIBiFQjCJIhUgISAWhUIBiSIWIB98IBB8IhiFQiCJIh18Ih8gFoVCKIkiFiAYfCAIfCIYfCASfCIhIBUgGXwiFSAXIBsgFIVCAYkiFCAefCAHfCIZhUIgiSIXfCIbIBSFQiiJIhQgGXwgAXwiGSAXhUIwiSIXhUIgiSIeIBwgICAVIA6FQgGJIg4gGnwgAnwiFYVCIIkiGnwiHCAOhUIoiSIOIBV8IAV8IhUgGoVCMIkiGiAcfCIcfCIgIA+FQiiJIg8gIXwgBHwiISAehUIwiSIeICB8IiAgGCAdhUIwiSIYIB98Ih0gFoVCAYkiFiAZfCAGfCIZIBqFQiCJIhogJHwiHyAWhUIoiSIWIBl8IBN8IhkgGoVCMIkiGiAcIA6FQgGJIg4gInwgCXwiHCAYhUIgiSIYIBcgG3wiF3wiGyAOhUIoiSIOIBx8IAN8IhwgGIVCMIkiGCAbfCIbIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAt8IhUgI4VCIIkiFyAdfCIdIBSFQiiJIhQgFXwgCnwiFXwgBHwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IAl8IiIgGyAeIBUgF4VCMIkiFSAdfCIXIBSFQgGJIhQgGXwgDHwiGYVCIIkiHXwiGyAUhUIoiSIUIBl8IAp8IhkgHYVCMIkiHSAbfCIbIBSFQgGJIhR8IAN8Ih4gGiAffCIaIBUgICAPhUIBiSIPIBx8IAd8IhyFQiCJIhV8Ih8gD4VCKIkiDyAcfCAQfCIcIBWFQjCJIhWFQiCJIiAgFyAYIBogFoVCAYkiFiAhfCATfCIahUIgiSIYfCIXIBaFQiiJIhYgGnwgDXwiGiAYhUIwiSIYIBd8Ihd8IiEgFIVCKIkiFCAefCAFfCIeICCFQjCJIiAgIXwiISAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIBx8IAt8IhwgGIVCIIkiGCAbfCIbIA6FQiiJIg4gHHwgEnwiHCAYhUIwiSIYIBcgFoVCAYkiFiAZfCABfCIXICKFQiCJIhkgFSAffCIVfCIfIBaFQiiJIhYgF3wgBnwiFyAZhUIwiSIZIB98Ih8gFoVCAYkiFiAVIA+FQgGJIg8gGnwgCHwiFSAdhUIgiSIaICN8Ih0gD4VCKIkiDyAVfCACfCIVfCANfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgCXwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAYIBt8IhggFSAahUIwiSIVICEgFIVCAYkiFCAXfCASfCIXhUIgiSIafCIbIBSFQiiJIhQgF3wgCHwiF3wgB3wiISAVIB18IhUgGSAYIA6FQgGJIg4gHnwgBnwiGIVCIIkiGXwiHSAOhUIoiSIOIBh8IAt8IhggGYVCMIkiGYVCIIkiHiAfICAgFSAPhUIBiSIPIBx8IAp8IhWFQiCJIhx8Ih8gD4VCKIkiDyAVfCAEfCIVIByFQjCJIhwgH3wiH3wiICAWhUIoiSIWICF8IAN8IiEgHoVCMIkiHiAgfCIgIBggFyAahUIwiSIXIBt8IhogFIVCAYkiFHwgBXwiGCAchUIgiSIbICR8IhwgFIVCKIkiFCAYfCABfCIYIBuFQjCJIhsgHyAPhUIBiSIPICJ8IAx8Ih8gF4VCIIkiFyAZIB18Ihl8Ih0gD4VCKIkiDyAffCATfCIfIBeFQjCJIhcgHXwiHSAPhUIBiSIPIBkgDoVCAYkiDiAVfCAQfCIVICOFQiCJIhkgGnwiGiAOhUIoiSIOIBV8IAJ8IhV8IBN8IiKFQiCJIiN8IiQgD4VCKIkiDyAifCASfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBsgHHwiGyAVIBmFQjCJIhUgICAWhUIBiSIWIB98IAt8IhmFQiCJIhx8Ih8gFoVCKIkiFiAZfCACfCIZfCAJfCIgIBUgGnwiFSAXIBsgFIVCAYkiFCAhfCAFfCIahUIgiSIXfCIbIBSFQiiJIhQgGnwgA3wiGiAXhUIwiSIXhUIgiSIhIB0gHiAVIA6FQgGJIg4gGHwgEHwiFYVCIIkiGHwiHSAOhUIoiSIOIBV8IAF8IhUgGIVCMIkiGCAdfCIdfCIeIA+FQiiJIg8gIHwgDXwiICAhhUIwiSIhIB58Ih4gGSAchUIwiSIZIB98IhwgFoVCAYkiFiAafCAIfCIaIBiFQiCJIhggJHwiHyAWhUIoiSIWIBp8IAp8IhogGIVCMIkiGCAdIA6FQgGJIg4gInwgBHwiHSAZhUIgiSIZIBcgG3wiF3wiGyAOhUIoiSIOIB18IAd8Ih0gGYVCMIkiGSAbfCIbIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAx8IhUgI4VCIIkiFyAcfCIcIBSFQiiJIhQgFXwgBnwiFXwgEnwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IBN8IiIgGyAhIBUgF4VCMIkiFSAcfCIXIBSFQgGJIhQgGnwgBnwiGoVCIIkiHHwiGyAUhUIoiSIUIBp8IBB8IhogHIVCMIkiHCAbfCIbIBSFQgGJIhR8IA18IiEgGCAffCIYIBUgHiAPhUIBiSIPIB18IAJ8Ih2FQiCJIhV8Ih4gD4VCKIkiDyAdfCABfCIdIBWFQjCJIhWFQiCJIh8gFyAZIBggFoVCAYkiFiAgfCADfCIYhUIgiSIZfCIXIBaFQiiJIhYgGHwgBHwiGCAZhUIwiSIZIBd8Ihd8IiAgFIVCKIkiFCAhfCAIfCIhIB+FQjCJIh8gIHwiICAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIB18IAd8Ih0gGYVCIIkiGSAbfCIbIA6FQiiJIg4gHXwgDHwiHSAZhUIwiSIZIBcgFoVCAYkiFiAafCALfCIXICKFQiCJIhogFSAefCIVfCIeIBaFQiiJIhYgF3wgCXwiFyAahUIwiSIaIB58Ih4gFoVCAYkiFiAVIA+FQgGJIg8gGHwgBXwiFSAchUIgiSIYICN8IhwgD4VCKIkiDyAVfCAKfCIVfCACfCIChUIgiSIifCIjIBaFQiiJIhYgAnwgC3wiAiAihUIwiSILICN8IiIgFoVCAYkiFiAZIBt8IhkgFSAYhUIwiSIVICAgFIVCAYkiFCAXfCANfCINhUIgiSIXfCIYIBSFQiiJIhQgDXwgBXwiBXwgEHwiECAVIBx8Ig0gGiAZIA6FQgGJIg4gIXwgDHwiDIVCIIkiFXwiGSAOhUIoiSIOIAx8IBJ8IhIgFYVCMIkiDIVCIIkiFSAeIB8gDSAPhUIBiSINIB18IAl8IgmFQiCJIg98IhogDYVCKIkiDSAJfCAIfCIJIA+FQjCJIgggGnwiD3wiGiAWhUIoiSIWIBB8IAd8IhAgEYUgDCAZfCIHIA6FQgGJIgwgCXwgCnwiCiALhUIgiSILIAUgF4VCMIkiBSAYfCIJfCIOIAyFQiiJIgwgCnwgE3wiEyALhUIwiSIKIA58IguFNwOAiQFBACADIAYgDyANhUIBiSINIAJ8fCICIAWFQiCJIgUgB3wiBiANhUIoiSIHIAJ8fCICQQApA4iJAYUgBCABIBIgCSAUhUIBiSIDfHwiASAIhUIgiSISICJ8IgkgA4VCKIkiAyABfHwiASAShUIwiSIEIAl8IhKFNwOIiQFBACATQQApA5CJAYUgECAVhUIwiSIQIBp8IhOFNwOQiQFBACABQQApA5iJAYUgAiAFhUIwiSICIAZ8IgGFNwOYiQFBACASIAOFQgGJQQApA6CJAYUgAoU3A6CJAUEAIBMgFoVCAYlBACkDqIkBhSAKhTcDqIkBQQAgASAHhUIBiUEAKQOwiQGFIASFNwOwiQFBACALIAyFQgGJQQApA7iJAYUgEIU3A7iJAQvdAgUBfwF+AX8BfgJ/IwBBwABrIgAkAAJAQQApA9CJAUIAUg0AQQBBACkDwIkBIgFBACgC4IoBIgKsfCIDNwPAiQFBAEEAKQPIiQEgAyABVK18NwPIiQECQEEALQDoigFFDQBBAEJ/NwPYiQELQQBCfzcD0IkBAkAgAkH/AEoNAEEAIQQDQCACIARqQeCJAWpBADoAACAEQQFqIgRBgAFBACgC4IoBIgJrSA0ACwtB4IkBEAIgAEEAKQOAiQE3AwAgAEEAKQOIiQE3AwggAEEAKQOQiQE3AxAgAEEAKQOYiQE3AxggAEEAKQOgiQE3AyAgAEEAKQOoiQE3AyggAEEAKQOwiQE3AzAgAEEAKQO4iQE3AzhBACgC5IoBIgVBAUgNAEEAIQRBACECA0AgBEGACWogACAEai0AADoAACAEQQFqIQQgBSACQQFqIgJB/wFxSg0ACwsgAEHAAGokAAv9AwMBfwF+AX8jAEGAAWsiAiQAQQBBgQI7AfKKAUEAIAE6APGKAUEAIAA6APCKAUGQfiEAA0AgAEGAiwFqQgA3AAAgAEH4igFqQgA3AAAgAEHwigFqQgA3AAAgAEEYaiIADQALQQAhAEEAQQApA/CKASIDQoiS853/zPmE6gCFNwOAiQFBAEEAKQP4igFCu86qptjQ67O7f4U3A4iJAUEAQQApA4CLAUKr8NP0r+68tzyFNwOQiQFBAEEAKQOIiwFC8e30+KWn/aelf4U3A5iJAUEAQQApA5CLAULRhZrv+s+Uh9EAhTcDoIkBQQBBACkDmIsBQp/Y+dnCkdqCm3+FNwOoiQFBAEEAKQOgiwFC6/qG2r+19sEfhTcDsIkBQQBBACkDqIsBQvnC+JuRo7Pw2wCFNwO4iQFBACADp0H/AXE2AuSKAQJAIAFBAUgNACACQgA3A3ggAkIANwNwIAJCADcDaCACQgA3A2AgAkIANwNYIAJCADcDUCACQgA3A0ggAkIANwNAIAJCADcDOCACQgA3AzAgAkIANwMoIAJCADcDICACQgA3AxggAkIANwMQIAJCADcDCCACQgA3AwBBACEEA0AgAiAAaiAAQYAJai0AADoAACAAQQFqIQAgBEEBaiIEQf8BcSABSA0ACyACQYABEAELIAJBgAFqJAALEgAgAEEDdkH/P3EgAEEQdhAECwkAQYAJIAAQAQsGAEGAiQELGwAgAUEDdkH/P3EgAUEQdhAEQYAJIAAQARADCwsLAQBBgAgLBPAAAAA=";
  var hash$j = "656e0f66";
  var wasmJson$j = {
  	name: name$j,
  	data: data$j,
  	hash: hash$j
  };

  new Mutex();
  function validateBits$4(bits) {
      if (!Number.isInteger(bits) || bits < 8 || bits > 512 || bits % 8 !== 0) {
          return new Error('Invalid variant! Valid values: 8, 16, ..., 512');
      }
      return null;
  }
  function getInitParam$1(outputBits, keyBits) {
      // eslint-disable-next-line no-bitwise
      return outputBits | (keyBits << 16);
  }
  /**
   * Creates a new BLAKE2b hash instance
   * @param bits Number of output bits, which has to be a number
   *             divisible by 8, between 8 and 512. Defaults to 512.
   * @param key Optional key (string, Buffer or TypedArray). Maximum length is 64 bytes.
   */
  function createBLAKE2b(bits = 512, key = null) {
      if (validateBits$4(bits)) {
          return Promise.reject(validateBits$4(bits));
      }
      let keyBuffer = null;
      let initParam = bits;
      if (key !== null) {
          keyBuffer = getUInt8Buffer(key);
          if (keyBuffer.length > 64) {
              return Promise.reject(new Error('Max key length is 64 bytes'));
          }
          initParam = getInitParam$1(bits, keyBuffer.length);
      }
      const outputSize = bits / 8;
      return WASMInterface(wasmJson$j, outputSize).then((wasm) => {
          if (initParam > 512) {
              wasm.writeMemory(keyBuffer);
          }
          wasm.init(initParam);
          const obj = {
              init: initParam > 512
                  ? () => {
                      wasm.writeMemory(keyBuffer);
                      wasm.init(initParam);
                      return obj;
                  }
                  : () => {
                      wasm.init(initParam);
                      return obj;
                  },
              update: (data) => { wasm.update(data); return obj; },
              digest: (outputType) => wasm.digest(outputType),
              save: () => wasm.save(),
              load: (data) => { wasm.load(data); return obj; },
              blockSize: 128,
              digestSize: outputSize,
          };
          return obj;
      });
  }

  var name$i = "argon2";
  var data$i = "AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvkyBVgBAn9BACEBAkBBACgCiAgiAiAARg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkDyAGFNwPYCUEAIAIpA9ABIAEpA9ABhTcD4AlBACACKQPYASABKQPYAYU3A+gJQQAgAikD4AEgASkD4AGFNwPwCUEAIAIpA+gBIAEpA+gBhTcD+AlBACACKQPwASABKQPwAYU3A4AKQQAgAikD+AEgASkD+AGFNwOICkEAIAIpA4ACIAEpA4AChTcDkApBACACKQOIAiABKQOIAoU3A5gKQQAgAikDkAIgASkDkAKFNwOgCkEAIAIpA5gCIAEpA5gChTcDqApBACACKQOgAiABKQOgAoU3A7AKQQAgAikDqAIgASkDqAKFNwO4CkEAIAIpA7ACIAEpA7AChTcDwApBACACKQO4AiABKQO4AoU3A8gKQQAgAikDwAIgASkDwAKFNwPQCkEAIAIpA8gCIAEpA8gChTcD2ApBACACKQPQAiABKQPQAoU3A+AKQQAgAikD2AIgASkD2AKFNwPoCkEAIAIpA+ACIAEpA+AChTcD8ApBACACKQPoAiABKQPoAoU3A/gKQQAgAikD8AIgASkD8AKFNwOAC0EAIAIpA/gCIAEpA/gChTcDiAtBACACKQOAAyABKQOAA4U3A5ALQQAgAikDiAMgASkDiAOFNwOYC0EAIAIpA5ADIAEpA5ADhTcDoAtBACACKQOYAyABKQOYA4U3A6gLQQAgAikDoAMgASkDoAOFNwOwC0EAIAIpA6gDIAEpA6gDhTcDuAtBACACKQOwAyABKQOwA4U3A8ALQQAgAikDuAMgASkDuAOFNwPIC0EAIAIpA8ADIAEpA8ADhTcD0AtBACACKQPIAyABKQPIA4U3A9gLQQAgAikD0AMgASkD0AOFNwPgC0EAIAIpA9gDIAEpA9gDhTcD6AtBACACKQPgAyABKQPgA4U3A/ALQQAgAikD6AMgASkD6AOFNwP4C0EAIAIpA/ADIAEpA/ADhTcDgAxBACACKQP4AyABKQP4A4U3A4gMQQAgAikDgAQgASkDgASFNwOQDEEAIAIpA4gEIAEpA4gEhTcDmAxBACACKQOQBCABKQOQBIU3A6AMQQAgAikDmAQgASkDmASFNwOoDEEAIAIpA6AEIAEpA6AEhTcDsAxBACACKQOoBCABKQOoBIU3A7gMQQAgAikDsAQgASkDsASFNwPADEEAIAIpA7gEIAEpA7gEhTcDyAxBACACKQPABCABKQPABIU3A9AMQQAgAikDyAQgASkDyASFNwPYDEEAIAIpA9AEIAEpA9AEhTcD4AxBACACKQPYBCABKQPYBIU3A+gMQQAgAikD4AQgASkD4ASFNwPwDEEAIAIpA+gEIAEpA+gEhTcD+AxBACACKQPwBCABKQPwBIU3A4ANQQAgAikD+AQgASkD+ASFNwOIDUEAIAIpA4AFIAEpA4AFhTcDkA1BACACKQOIBSABKQOIBYU3A5gNQQAgAikDkAUgASkDkAWFNwOgDUEAIAIpA5gFIAEpA5gFhTcDqA1BACACKQOgBSABKQOgBYU3A7ANQQAgAikDqAUgASkDqAWFNwO4DUEAIAIpA7AFIAEpA7AFhTcDwA1BACACKQO4BSABKQO4BYU3A8gNQQAgAikDwAUgASkDwAWFNwPQDUEAIAIpA8gFIAEpA8gFhTcD2A1BACACKQPQBSABKQPQBYU3A+ANQQAgAikD2AUgASkD2AWFNwPoDUEAIAIpA+AFIAEpA+AFhTcD8A1BACACKQPoBSABKQPoBYU3A/gNQQAgAikD8AUgASkD8AWFNwOADkEAIAIpA/gFIAEpA/gFhTcDiA5BACACKQOABiABKQOABoU3A5AOQQAgAikDiAYgASkDiAaFNwOYDkEAIAIpA5AGIAEpA5AGhTcDoA5BACACKQOYBiABKQOYBoU3A6gOQQAgAikDoAYgASkDoAaFNwOwDkEAIAIpA6gGIAEpA6gGhTcDuA5BACACKQOwBiABKQOwBoU3A8AOQQAgAikDuAYgASkDuAaFNwPIDkEAIAIpA8AGIAEpA8AGhTcD0A5BACACKQPIBiABKQPIBoU3A9gOQQAgAikD0AYgASkD0AaFNwPgDkEAIAIpA9gGIAEpA9gGhTcD6A5BACACKQPgBiABKQPgBoU3A/AOQQAgAikD6AYgASkD6AaFNwP4DkEAIAIpA/AGIAEpA/AGhTcDgA9BACACKQP4BiABKQP4BoU3A4gPQQAgAikDgAcgASkDgAeFNwOQD0EAIAIpA4gHIAEpA4gHhTcDmA9BACACKQOQByABKQOQB4U3A6APQQAgAikDmAcgASkDmAeFNwOoD0EAIAIpA6AHIAEpA6AHhTcDsA9BACACKQOoByABKQOoB4U3A7gPQQAgAikDsAcgASkDsAeFNwPAD0EAIAIpA7gHIAEpA7gHhTcDyA9BACACKQPAByABKQPAB4U3A9APQQAgAikDyAcgASkDyAeFNwPYD0EAIAIpA9AHIAEpA9AHhTcD4A9BACACKQPYByABKQPYB4U3A+gPQQAgAikD4AcgASkD4AeFNwPwD0EAIAIpA+gHIAEpA+gHhTcD+A9BACACKQPwByABKQPwB4U3A4AQQQAgAikD+AcgASkD+AeFNwOIEEGQCEGYCEGgCEGoCEGwCEG4CEHACEHICEHQCEHYCEHgCEHoCEHwCEH4CEGACUGICRACQZAJQZgJQaAJQagJQbAJQbgJQcAJQcgJQdAJQdgJQeAJQegJQfAJQfgJQYAKQYgKEAJBkApBmApBoApBqApBsApBuApBwApByApB0ApB2ApB4ApB6ApB8ApB+ApBgAtBiAsQAkGQC0GYC0GgC0GoC0GwC0G4C0HAC0HIC0HQC0HYC0HgC0HoC0HwC0H4C0GADEGIDBACQZAMQZgMQaAMQagMQbAMQbgMQcAMQcgMQdAMQdgMQeAMQegMQfAMQfgMQYANQYgNEAJBkA1BmA1BoA1BqA1BsA1BuA1BwA1ByA1B0A1B2A1B4A1B6A1B8A1B+A1BgA5BiA4QAkGQDkGYDkGgDkGoDkGwDkG4DkHADkHIDkHQDkHYDkHgDkHoDkHwDkH4DkGAD0GIDxACQZAPQZgPQaAPQagPQbAPQbgPQcAPQcgPQdAPQdgPQeAPQegPQfAPQfgPQYAQQYgQEAJBkAhBmAhBkAlBmAlBkApBmApBkAtBmAtBkAxBmAxBkA1BmA1BkA5BmA5BkA9BmA8QAkGgCEGoCEGgCUGoCUGgCkGoCkGgC0GoC0GgDEGoDEGgDUGoDUGgDkGoDkGgD0GoDxACQbAIQbgIQbAJQbgJQbAKQbgKQbALQbgLQbAMQbgMQbANQbgNQbAOQbgOQbAPQbgPEAJBwAhByAhBwAlByAlBwApByApBwAtByAtBwAxByAxBwA1ByA1BwA5ByA5BwA9ByA8QAkHQCEHYCEHQCUHYCUHQCkHYCkHQC0HYC0HQDEHYDEHQDUHYDUHQDkHYDkHQD0HYDxACQeAIQegIQeAJQegJQeAKQegKQeALQegLQeAMQegMQeANQegNQeAOQegOQeAPQegPEAJB8AhB+AhB8AlB+AlB8ApB+ApB8AtB+AtB8AxB+AxB8A1B+A1B8A5B+A5B8A9B+A8QAkGACUGICUGACkGICkGAC0GIC0GADEGIDEGADUGIDUGADkGIDkGAD0GID0GAEEGIEBACAkACQCADRQ0AA0AgACAEaiIDIAIgBGoiBSkDACABIARqIgYpAwCFIARBkAhqKQMAhSADKQMAhTcDACADQQhqIgMgBUEIaikDACAGQQhqKQMAhSAEQZgIaikDAIUgAykDAIU3AwAgBEEQaiIEQYAIRw0ADAILC0EAIQQDQCAAIARqIgMgAiAEaiIFKQMAIAEgBGoiBikDAIUgBEGQCGopAwCFNwMAIANBCGogBUEIaikDACAGQQhqKQMAhSAEQZgIaikDAIU3AwAgBEEQaiIEQYAIRw0ACwsL7QcMBX8BfgR/An4CfwF+A38BfgZ/AX4DfwF+AkBBACgCgAgiAiABQQp0aiIDKAIIIAFHDQAgAygCDCEEIAMoAgAhBUEAIAMoAhQiBq03A7gQQQAgBK0iBzcDsBBBACAFIAEgBUECdG4iCGwiCUECdK03A6gQAkACQAJAAkAgBEUNAEF/IQogBUUNASAIQQNsIQsgCEECdCIErSEMIAWtIQ0gBkECRiEOIAZBf2pBAkkhD0IAIRADQEEAIBA3A5AQIA4gEFAiEXEhEiAQpyETQgAhFEEAIQEDQEEAIBQ3A6AQIAZBAUYgEiAUQgJUcXIhFSAQIBSEUCIDIA9xIRZBfyABQQFqQQNxIAhsQX9qIBEbIRcgASATciEYIAEgCGwhGSADQQF0IRpCACEbA0BBAEIANwPAEEEAIBs3A5gQIBohAQJAIBZFDQBBAEIBNwPAEEGQGEGQEEGQIEEAEANBkBhBkBhBkCBBABADQQIhAQsCQCABIAhPDQAgBCAbpyIcbCAZaiABaiEDA0AgA0EAIARBACAUUCIdGyABG2pBf2ohHgJAAkAgFQ0AQQAoAoAIIgIgHkEKdCIeaiEKDAELAkAgAUH/AHEiAg0AQQBBACkDwBBCAXw3A8AQQZAYQZAQQZAgQQAQA0GQGEGQGEGQIEEAEAMLIB5BCnQhHiACQQN0QZAYaiEKQQAoAoAIIQILIAIgA0EKdGogAiAeaiACIAopAwAiH0IgiKcgBXAgHCAYGyIeIARsIAEgAUEAIBsgHq1RIh4bIgogHRsgGWogCiALaiARGyABRSAecmsiHSAXaq0gH0L/////D4MiHyAffkIgiCAdrX5CIIh9IAyCp2pBCnRqQQEQAyADQQFqIQMgCCABQQFqIgFHDQALCyAbQgF8IhsgDVINAAsgFEIBfCIUpyEBIBRCBFINAAsgEEIBfCIQIAdSDQALCyAJQQx0QYB4aiEZQQAoAoAIIQIgBUF/aiIKRQ0CDAELQQBCAzcDoBBBACAEQX9qrTcDkBBBgHghGQsgAiAZaiEdIAhBDHQhCEEAIR4DQCAIIB5BAWoiHmxBgHhqIQRBACEBA0AgHSABaiIDIAMpAwAgAiAEIAFqaikDAIU3AwAgA0EIaiIDIAMpAwAgAiAEIAFBCHJqaikDAIU3AwAgAUEIaiEDIAFBEGohASADQfgHSQ0ACyAeIApHDQALCyACIBlqIR1BeCEBA0AgAiABaiIDQQhqIB0gAWoiBEEIaikDADcDACADQRBqIARBEGopAwA3AwAgA0EYaiAEQRhqKQMANwMAIANBIGogBEEgaikDADcDACABQSBqIgFB+AdJDQALCws=";
  var hash$i = "7ab14c91";
  var wasmJson$i = {
  	name: name$i,
  	data: data$i,
  	hash: hash$i
  };

  function encodeResult(salt, options, res) {
      const parameters = [
          `m=${options.memorySize}`,
          `t=${options.iterations}`,
          `p=${options.parallelism}`,
      ].join(',');
      return `$argon2${options.hashType}$v=19$${parameters}$${encodeBase64(salt, false)}$${encodeBase64(res, false)}`;
  }
  const uint32View = new DataView(new ArrayBuffer(4));
  function int32LE(x) {
      uint32View.setInt32(0, x, true);
      return new Uint8Array(uint32View.buffer);
  }
  function hashFunc(blake512, buf, len) {
      return __awaiter(this, void 0, void 0, function* () {
          if (len <= 64) {
              const blake = yield createBLAKE2b(len * 8);
              blake.update(int32LE(len));
              blake.update(buf);
              return blake.digest('binary');
          }
          const r = Math.ceil(len / 32) - 2;
          const ret = new Uint8Array(len);
          blake512.init();
          blake512.update(int32LE(len));
          blake512.update(buf);
          let vp = blake512.digest('binary');
          ret.set(vp.subarray(0, 32), 0);
          for (let i = 1; i < r; i++) {
              blake512.init();
              blake512.update(vp);
              vp = blake512.digest('binary');
              ret.set(vp.subarray(0, 32), i * 32);
          }
          const partialBytesNeeded = len - 32 * r;
          let blakeSmall;
          if (partialBytesNeeded === 64) {
              blakeSmall = blake512;
              blakeSmall.init();
          }
          else {
              blakeSmall = yield createBLAKE2b(partialBytesNeeded * 8);
          }
          blakeSmall.update(vp);
          vp = blakeSmall.digest('binary');
          ret.set(vp.subarray(0, partialBytesNeeded), r * 32);
          return ret;
      });
  }
  function getHashType(type) {
      switch (type) {
          case 'd':
              return 0;
          case 'i':
              return 1;
          default:
              return 2;
      }
  }
  function argon2Internal(options) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
          const { parallelism, iterations, hashLength } = options;
          const password = getUInt8Buffer(options.password);
          const salt = getUInt8Buffer(options.salt);
          const version = 0x13;
          const hashType = getHashType(options.hashType);
          const { memorySize } = options; // in KB
          const secret = getUInt8Buffer((_a = options.secret) !== null && _a !== void 0 ? _a : '');
          const [argon2Interface, blake512] = yield Promise.all([
              WASMInterface(wasmJson$i, 1024),
              createBLAKE2b(512),
          ]);
          // last block is for storing the init vector
          argon2Interface.setMemorySize(memorySize * 1024 + 1024);
          const initVector = new Uint8Array(24);
          const initVectorView = new DataView(initVector.buffer);
          initVectorView.setInt32(0, parallelism, true);
          initVectorView.setInt32(4, hashLength, true);
          initVectorView.setInt32(8, memorySize, true);
          initVectorView.setInt32(12, iterations, true);
          initVectorView.setInt32(16, version, true);
          initVectorView.setInt32(20, hashType, true);
          argon2Interface.writeMemory(initVector, memorySize * 1024);
          blake512.init();
          blake512.update(initVector);
          blake512.update(int32LE(password.length));
          blake512.update(password);
          blake512.update(int32LE(salt.length));
          blake512.update(salt);
          blake512.update(int32LE(secret.length));
          blake512.update(secret);
          blake512.update(int32LE(0)); // associatedData length + associatedData
          const segments = Math.floor(memorySize / (parallelism * 4)); // length of each lane
          const lanes = segments * 4;
          const param = new Uint8Array(72);
          const H0 = blake512.digest('binary');
          param.set(H0);
          for (let lane = 0; lane < parallelism; lane++) {
              param.set(int32LE(0), 64);
              param.set(int32LE(lane), 68);
              let position = lane * lanes;
              let chunk = yield hashFunc(blake512, param, 1024);
              argon2Interface.writeMemory(chunk, position * 1024);
              position += 1;
              param.set(int32LE(1), 64);
              chunk = yield hashFunc(blake512, param, 1024);
              argon2Interface.writeMemory(chunk, position * 1024);
          }
          const C = new Uint8Array(1024);
          writeHexToUInt8(C, argon2Interface.calculate(new Uint8Array([]), memorySize));
          const res = yield hashFunc(blake512, C, hashLength);
          if (options.outputType === 'hex') {
              const digestChars = new Uint8Array(hashLength * 2);
              return getDigestHex(digestChars, res, hashLength);
          }
          if (options.outputType === 'encoded') {
              return encodeResult(salt, options, res);
          }
          // return binary format
          return res;
      });
  }
  const validateOptions$3 = (options) => {
      var _a;
      if (!options || typeof options !== 'object') {
          throw new Error('Invalid options parameter. It requires an object.');
      }
      if (!options.password) {
          throw new Error('Password must be specified');
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
          throw new Error('Password must be specified');
      }
      if (!options.salt) {
          throw new Error('Salt must be specified');
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length < 8) {
          throw new Error('Salt should be at least 8 bytes long');
      }
      options.secret = getUInt8Buffer((_a = options.secret) !== null && _a !== void 0 ? _a : '');
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
          throw new Error('Iterations should be a positive number');
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
          throw new Error('Parallelism should be a positive number');
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 4) {
          throw new Error('Hash length should be at least 4 bytes.');
      }
      if (!Number.isInteger(options.memorySize)) {
          throw new Error('Memory size should be specified.');
      }
      if (options.memorySize < 8 * options.parallelism) {
          throw new Error('Memory size should be at least 8 * parallelism.');
      }
      if (options.outputType === undefined) {
          options.outputType = 'hex';
      }
      if (!['hex', 'binary', 'encoded'].includes(options.outputType)) {
          throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
  };
  const getHashParameters = (password, encoded, secret) => {
      const regex = /^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/;
      const match = encoded.match(regex);
      if (!match) {
          throw new Error('Invalid hash');
      }
      const [, hashType, version, parameters, salt, hash] = match;
      if (version !== '19') {
          throw new Error(`Unsupported version: ${version}`);
      }
      const parsedParameters = {};
      const paramMap = { m: 'memorySize', p: 'parallelism', t: 'iterations' };
      parameters.split(',').forEach((x) => {
          const [n, v] = x.split('=');
          parsedParameters[paramMap[n]] = parseInt(v, 10);
      });
      return Object.assign(Object.assign({}, parsedParameters), { password,
          secret, hashType: hashType, salt: decodeBase64(salt), hashLength: getDecodeBase64Length(hash), outputType: 'encoded' });
  };
  const validateVerifyOptions$1 = (options) => {
      if (!options || typeof options !== 'object') {
          throw new Error('Invalid options parameter. It requires an object.');
      }
      if (options.hash === undefined || typeof options.hash !== 'string') {
          throw new Error('Hash should be specified');
      }
  };
  /**
   * Verifies password using the argon2 password-hashing function
   * @returns True if the encoded hash matches the password
   */
  function argon2Verify(options) {
      return __awaiter(this, void 0, void 0, function* () {
          validateVerifyOptions$1(options);
          const params = getHashParameters(options.password, options.hash, options.secret);
          validateOptions$3(params);
          const hashStart = options.hash.lastIndexOf('$') + 1;
          const result = yield argon2Internal(params);
          return result.substring(hashStart) === options.hash.substring(hashStart);
      });
  }

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  new Mutex();

  var name$2 = "bcrypt";
  var data$2 = "AGFzbQEAAAABFwRgAAF/YAR/f39/AGADf39/AGABfwF/AwUEAAECAwUEAQECAgYIAX8BQZCrBQsHNAQGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAZiY3J5cHQAAg1iY3J5cHRfdmVyaWZ5AAMK+GAEBQBBgCsL3lkEFH8Bfgh/AX4jAEHwAGshBCACQQA6AAIgAkGq4AA7AAACQCABLQAAQSpHDQAgAS0AAUEwRw0AIAJBMToAAQsCQCABLAAFIAEsAARBCmxqQfB7aiIFQQRJDQAgAS0AB0FgaiIGQd8ASw0AIAZBkAlqLQAAIgZBP0sNACABLQAIQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgB0EEdiAGQQJ0cjoACCABLQAJQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAQgBkECdiAHQQR0cjoACSABLQAKQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgByAGQQZ0cjoACiABLQALQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAEtAAxBYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHQQR2IAZBAnRyOgALIAEtAA1BYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgBCAGQQJ2IAdBBHRyOgAMIAEtAA5BYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHIAZBBnRyOgANIAEtAA9BYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgAS0AEEFgaiIHQd8ASw0AIAdBkAlqLQAAIgdBP0sNACAEIAdBBHYgBkECdHI6AA4gAS0AEUFgaiIGQd8ASw0AIAZBkAlqLQAAIgZBP0sNACAEIAZBAnYgB0EEdHI6AA8gAS0AEkFgaiIHQd8ASw0AIAdBkAlqLQAAIgdBP0sNACAEIAcgBkEGdHI6ABAgAS0AE0FgaiIGQd8ASw0AIAZBkAlqLQAAIgZBP0sNACABLQAUQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgB0EEdiAGQQJ0cjoAESABLQAVQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAQgBkECdiAHQQR0cjoAEiABLQAWQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgByAGQQZ0cjoAEyABLQAXQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAEtABhBYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHQQR2IAZBAnRyOgAUIAEtABlBYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgBCAGQQJ2IAdBBHRyOgAVIAEtABpBYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHIAZBBnRyOgAWIAEtABtBYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgAS0AHEFgaiIHQd8ASw0AIAdBkAlqLQAAIgdBP0sNAEEBIAV0IQggBCAHQQR2IAZBAnRyOgAXIAQgBCgCCCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIJNgIIIAQgBCgCDCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIKNgIMIAQgBCgCECIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciILNgIQIAQgBCgCFCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIMNgIUIARB6ABqIAEtAAJBnwdqLQAAIg1BAXFBAnRqIQ5BACEGQQAhD0EAIRAgACEFA0AgBEIANwJoIAUtAAAhByAEQQA2AmwgBCAHNgJoIAQgBSwAACIRNgJsIAUtAAAhEiAEIAdBCHQiBzYCaCAEIAcgBUEBaiAAIBIbIgUtAAByIgc2AmggBCARQQh0IhE2AmwgBCARIAUsAAAiEnIiETYCbCAFLQAAIRMgBCAHQQh0Igc2AmggBCAHIAVBAWogACATGyIFLQAAciIHNgJoIAQgEUEIdCIRNgJsIAQgESAFLAAAIhNyIhE2AmwgBS0AACEUIAQgB0EIdCIHNgJoIAQgByAFQQFqIAAgFBsiBS0AAHIiBzYCaCAEIBFBCHQiETYCbCAEIBEgBSwAACIUciIRNgJsIAUtAAAhFSAEQSBqIAZqIA4oAgAiFjYCACAGQfApaiIXIBYgFygCAHM2AgAgESAHcyAPciEPIAVBAWogACAVGyEFIBQgEyAScnJBgAFxIBByIRAgBkEEaiIGQcgARw0AC0EAQQAoAvApIBBBCXQgDUEPdHFBgIAEIA9B//8DcSAPQRB2cmtxczYC8ClCACEYQX4hBkHwKSEHA0BBACgCrCpBACgCqCpBACgCpCpBACgCoCpBACgCnCpBACgCmCpBACgClCpBACgCkCpBACgCjCpBACgCiCpBACgChCpBACgCgCpBACgC/ClBACgC+ClBACgC9CkgBEEIaiAGQQJqIgZBAnFBAnRqKQMAIBiFIhhCIIinc0EAKALwKSAYp3MiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUH/AXFBAnRB8CFqKAIAIQ8gBUEGdkH8B3FB8BlqKAIAIRAgBUEWdkH8B3FB8AlqKAIAIREgBUEOdkH8B3FB8BFqKAIAIRJBACgCsCohE0EAQQAoArQqIAVzNgKAqwFBACATIA8gECARIBJqc2pzIABzNgKEqwEgB0EAKQOAqwEiGDcCACAHQQhqIQcgBkEQSQ0ACyAYQiCIpyEFIBinIQZB8AkhAANAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpIAVBACgC9ClzIAZBACgC8ClzIAtzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgDHMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZB/wFxQQJ0QfAhaigCACEHIAZBBnZB/AdxQfAZaigCACEPIAZBFnZB/AdxQfAJaigCACEQIAZBDnZB/AdxQfARaigCACERQQAoArAqIRIgAEEAKAK0KiAGcyIGNgIAIABBBGogEiAHIA8gECARanNqcyAFcyIHNgIAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpQQAoAvQpIAlBACgC8ClzIAZzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgCnMgB3MiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZB/wFxQQJ0QfAhaigCACEHIAZBBnZB/AdxQfAZaigCACEPIAZBFnZB/AdxQfAJaigCACEQIAZBDnZB/AdxQfARaigCACERQQAoArAqIRIgAEEIakEAKAK0KiAGcyIGNgIAIABBDGogEiAHIA8gECARanNqcyAFcyIFNgIAIABBEGoiAEHsKUkNAAtBACAFNgKEqwFBACAGNgKAqwEgBCgCZCEUIAQoAmAhFSAEKAJcIRYgBCgCWCEXIAQoAlQhCSAEKAJQIQogBCgCTCELIAQoAkghDCAEKAJEIQ4gBCgCQCENIAQoAjwhGSAEKAI4IRogBCgCNCEbIAQoAjAhHCAEKAIsIR0gBCgCKCEeIAQoAiQhHyAEKAIgISAgBCkDECEhIAQpAwghGANAQQBBACgC8CkgIHM2AvApQQBBACgC9CkgH3M2AvQpQQBBACgC+CkgHnM2AvgpQQBBACgC/CkgHXM2AvwpQQBBACgCgCogHHM2AoAqQQBBACgChCogG3M2AoQqQQBBACgCiCogGnM2AogqQQBBACgCjCogGXM2AowqQQBBACgCkCogDXM2ApAqQQBBACgClCogDnM2ApQqQQBBACgCmCogDHM2ApgqQQBBACgCnCogC3M2ApwqQQBBACgCoCogCnM2AqAqQQBBACgCpCogCXM2AqQqQQBBACgCqCogF3M2AqgqQQBBACgCrCogFnM2AqwqQQBBACgCsCogFXM2ArAqQQBBACgCtCogFHM2ArQqQQEhEwNAQQAhAEEAQgA3A4CrAUHwKSEGQQAhBQNAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpQQAoAvQpIABzQQAoAvApIAVzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVB/wFxQQJ0QfAhaigCACEHIAVBBnZB/AdxQfAZaigCACEPIAVBFnZB/AdxQfAJaigCACEQIAVBDnZB/AdxQfARaigCACERQQAoArAqIRIgBkEAKAK0KiAFcyIFNgIAIAZBBGogEiAHIA8gECARanNqcyAAcyIANgIAIAZBCGoiBkG4KkkNAAtB8AkhBgNAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpQQAoAvQpIABzQQAoAvApIAVzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVB/wFxQQJ0QfAhaigCACEHIAVBBnZB/AdxQfAZaigCACEPIAVBFnZB/AdxQfAJaigCACEQIAVBDnZB/AdxQfARaigCACERQQAoArAqIRIgBkEAKAK0KiAFcyIFNgIAIAZBBGogEiAHIA8gECARanNqcyAAcyIANgIAIAZBCGoiBkHsKUkNAAtBACAANgKEqwFBACAFNgKAqwECQCATQQFxRQ0AQQAhE0EAQQApAvApIBiFNwLwKUEAQQApAvgpICGFNwL4KUEAQQApAoAqIBiFNwKAKkEAQQApAogqICGFNwKIKkEAQQApApAqIBiFNwKQKkEAQQApApgqICGFNwKYKkEAQQApAqAqIBiFNwKgKkEAQQApAqgqICGFNwKoKkEAQQApArAqIBiFNwKwKgwBCwsgCEF/aiIIDQALQQAoArQqIQ9BACgCsCohEEEAKAKsKiERQQAoAqgqIRJBACgCpCohE0EAKAKgKiEIQQAoApwqIRRBACgCmCohFUEAKAKUKiEWQQAoApAqIRdBACgCjCohCUEAKAKIKiEKQQAoAoQqIQtBACgCgCohDEEAKAL8KSEOQQAoAvgpIQ1BACgC9CkhGUEAKALwKSEaQQAhGwNAIBtBAnQiHEGgCGopAwAiGKchACAYQiCIpyEGQUAhBwNAIBAgESASIBMgCCAUIBUgFiAXIAkgCiALIAwgDiANIAYgGXMgACAacyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIQYgBSAPcyEAIAdBAWoiBw0AC0EAIAY2AoSrAUEAIAA2AoCrASAEQQhqIBxqQQApA4CrATcDACAbQQRJIQAgG0ECaiEbIAANAAsgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASwAHEHwCGotAABBMHFBwAhqLQAAOgAcIAQgBCgCCCIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZyciIHNgIIIAQgBCgCDCIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZyciIBNgIMIAQgBCgCECIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZyciIANgIQIAQgBCgCFCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIFNgIUIAQgBCgCGCIGQRh0IAZBgP4DcUEIdHIgBkEIdkGA/gNxIAZBGHZyciIGNgIYIAQgBCgCHCIPQRh0IA9BgP4DcUEIdHIgD0EIdkGA/gNxIA9BGHZyciIPNgIcAkACQCADDQAgAiAEKQMINwMAIAIgBCkDEDcDCCACIAQpAxg3AxAMAQsgAiAPQT9xQcAIai0AADoAOCACIAVBGnZBwAhqLQAAOgAxIAIgAEE/cUHACGotAAA6ACggAiAHQRp2QcAIai0AADoAISACIAQtAAgiBEECdkHACGotAAA6AB0gAiAPQQ52QTxxQcAIai0AADoAOyACIA9BCnZBP3FBwAhqLQAAOgA5IAIgBkESdkE/cUHACGotAAA6ADUgAiAGQQh2QT9xQcAIai0AADoANCACIAVBEHZBP3FBwAhqLQAAOgAwIAIgBUH8AXFBAnZBwAhqLQAAOgAtIAIgAEEYdkE/cUHACGotAAA6ACwgAiAAQQp2QT9xQcAIai0AADoAKSACIAFBEnZBP3FBwAhqLQAAOgAlIAIgAUEIdkE/cUHACGotAAA6ACQgAiAHQRB2QT9xQcAIai0AADoAICACIA9BFHZBD3EgD0EEdkEwcXJBwAhqLQAAOgA6IAIgD0EGdkEDcSAGQRZ2QTxxckHACGotAAA6ADcgAiAGQQx2QTBxIAZBHHZyQcAIai0AADoANiACIAZBAnRBPHEgBkEOdkEDcXJBwAhqLQAAOgAzIAIgBkHwAXFBBHYgBUEUdkEwcXJBwAhqLQAAOgAyIAIgBUEWdkEDcSAFQQZ2QTxxckHACGotAAA6AC8gAiAFQQR0QTBxIAVBDHZBD3FyQcAIai0AADoALiACIABBDnZBPHEgAEEednJBwAhqLQAAOgArIAIgAEEUdkEPcSAAQQR2QTBxckHACGotAAA6ACogAiAAQQZ2QQNxIAFBFnZBPHFyQcAIai0AADoAJyACIAFBDHZBMHEgAUEcdnJBwAhqLQAAOgAmIAIgAUECdEE8cSABQQ52QQNxckHACGotAAA6ACMgAiABQfABcUEEdiAHQRR2QTBxckHACGotAAA6ACIgAiAHQRZ2QQNxIAdBBnZBPHFyQcAIai0AADoAHyACIARBBHRBMHEgB0EMdkEPcXJBwAhqLQAAOgAeCyACQQA6ADwLC4YGAQZ/IwBB4ABrIgMkAEEAIQQgAEGQK2pBADoAACADQSQ6AEYgAyABQQpuIgBBMGo6AEQgA0Gk5ISjAjYCQCADIABB9gFsIAFqQTByOgBFIANBAC0AgCsiAUECdkHACGotAAA6AEcgA0EALQCCKyIAQT9xQcAIai0AADoASiADQQAtAIMrIgVBAnZBwAhqLQAAOgBLIANBAC0AhSsiBkE/cUHACGotAAA6AE4gA0EALQCBKyIHQQR2IAFBBHRBMHFyQcAIai0AADoASCADIABBBnYgB0ECdEE8cXJBwAhqLQAAOgBJIANBAC0AhCsiAUEEdiAFQQR0QTBxckHACGotAAA6AEwgAyAGQQZ2IAFBAnRBPHFyQcAIai0AADoATSADQQAtAIYrIgFBAnZBwAhqLQAAOgBPIANBAC0AiCsiAEE/cUHACGotAAA6AFIgA0EALQCJKyIFQQJ2QcAIai0AADoAUyADQQAtAIsrIgZBP3FBwAhqLQAAOgBWIANBAC0AjCsiB0ECdkHACGotAAA6AFcgA0EALQCHKyIIQQR2IAFBBHRBMHFyQcAIai0AADoAUCADIABBBnYgCEECdEE8cXJBwAhqLQAAOgBRIANBAC0AiisiAUEEdiAFQQR0QTBxckHACGotAAA6AFQgAyAGQQZ2IAFBAnRBPHFyQcAIai0AADoAVSADQQAtAI0rIgFBBHYgB0EEdEEwcXJBwAhqLQAAOgBYIANBADoAXSADQQAtAI4rIgBBP3FBwAhqLQAAOgBaIANBAC0AjysiBUECdkHACGotAAA6AFsgAyAAQQZ2IAFBAnRBPHFyQcAIai0AADoAWSADIAVBBHRBMHFBwAhqLQAAOgBcQZArIANBwABqIAMgAhABA0AgBEGAK2ogAyAEaiIBLQAAOgAAIARBgStqIAFBAWotAAA6AAAgBEGCK2ogAUECai0AADoAACAEQYMraiABQQNqLQAAOgAAIARBhCtqIAFBBGotAAA6AAAgBEEFaiIEQTxHDQALIANB4ABqJAALhwECAX8IfiMAQcAAayIBJAAgAEG8K2pBADoAAEG8K0GAKyABQQEQAUEAKQOkKyECIAEpAyQhA0EAKQOcKyEEIAEpAxwhBUEAKQOsKyEGIAEpAywhB0EAKQO0KyEIIAEpAzQhCSABQcAAaiQAIAUgBFIgAyACUmogByAGUmpBf0EAIAkgCFIbRgsLxyICAEGACAvwAQIEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQAAAAAAAAAaHByT0JuYWVsb2hlU3JlZER5cmN0YnVvAAAAAAAAAAAuL0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5AAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAAAE2Nzg5Ojs8PT4/QEBAQEBAQAIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobQEBAQEBAHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDVAQEBAQABB8AkLyCCmCzHRrLXfmNty/S+33xrQ7a/huJZ+JmpFkHy6mX8s8UeZoST3bJGz4vIBCBb8joXYIGljaU5XcaP+WKR+PZP0j3SVDVi2jnJYzYtx7koVgh2kVHu1WVrCOdUwnBNg8iojsNHF8IVgKBh5QcrvONu4sNx5jg4YOmCLDp5sPooesMF3FdcnSzG92i+veGBcYFXzJVXmlKtVqmKYSFdAFOhjajnKVbYQqyo0XMy0zuhBEa+GVKGT6XJ8ERTusyq8b2Ndxakr9jEYdBY+XM4ek4ebM7rWr1zPJGyBUzJ6d4aVKJhIjzuvuUtrG+i/xJMhKGbMCdhhkakh+2CsfEgygOxdXV2E77F1hekCIybciBtl64E+iSPFrJbT829tDzlC9IOCRAsuBCCEpErwyGlemx+eQmjGIZps6fZhnAxn8IjTq9KgUWpoL1TYKKcPlqMzUatsC+9u5Dt6E1DwO7qYKvt+HWXxoXYBrzk+WcpmiA5DghmG7oy0n29Fw6WEfb5eizvYdW/gcyDBhZ9EGkCmasFWYqrTTgZ3PzZy3/4bPQKbQiTX0DdIEgrQ0+oP25vA8UnJclMHexuZgNh51CX33uj2GlD+4ztMeba94GyXugbABLZPqcHEYJ9Awp5cXmMkahmvb/totVNsPuuyORNv7FI7H1H8bSyVMJtERYHMCb1erwTQ4779SjPeBygPZrNLLhlXqMvAD3TIRTlfC9Lb+9O5vcB5VQoyYBrGAKHWeXIsQP4ln2fMox/7+OmljvgiMtvfFnU8FWth/cgeUC+rUgWt+rU9MmCHI/1IezFTgt8APrtXXJ6gjG/KLlaHGttpF9/2qELVw/9+KMYyZ6xzVU+MsCdbachYyrtdo//hoBHwuJg9+hC4gyH9bLX8SlvT0S155FOaZUX4trxJjtKQl/tL2vLd4TN+y6RBE/ti6MbkztrKIO8BTHc2/p5+0LQf8StN2tuVmJGQrnGOreqg1ZNr0NGO0OAlx68vWzyOt5R1jvvi9o9kKxLyEriIiBzwDZCgXq1PHMOPaJHxz9GtwaizGCIvL3cXDr7+LXXqoR8Ciw/MoOXodG+11vOsGJniic7gT6i0t+AT/YE7xHzZqK3SZqJfFgV3lYAUc8yTdxQaIWUgreaG+rV39UJUx881nfsMr83roIk+e9MbQdZJfh6uLQ4lAF6zcSC7AGgir+C4V5s2ZCQeuQnwHZFjVaqm31mJQ8F4f1Na2aJbfSDFueUCdgMmg6nPlWJoGcgRQUpzTsotR7NKqRR7UgBRGxUpU5o/Vw/W5MabvHakYCsAdOaBtW+6CB/pG1dr7JbyFdkNKiFlY7a2+bnnLgU0/2RWhcVdLbBToY+fqZlHughqB4Vu6XB6S0Qps7UuCXXbIyYZxLCmbq1936dJuGDunGay7Y9xjKrs/xeaaWxSZFbhnrHCpQI2GSlMCXVAE1mgPjoY5JqYVD9lnUJb1uSPa9Y/95kHnNKh9TDo7+Y4LU3BXSXwhiDdTCbrcITG6YJjXsweAj9raAnJ77o+FBiXPKFwamuENX9ohuKgUgVTnLc3B1CqHIQHPlyu3n/sRH2OuPIWVzfaOrANDFDwBB8c8P+zAAIa9QyusnS1PFh6gyW9IQnc+ROR0fYvqXxzRzKUAUf1IoHl5Trc2sI3NHa1yKfd85pGYUSpDgPQDz7HyOxBHnWkmc044i8O6juhu4AyMbM+GDiLVE4IuW1PAw1Cb78ECvaQErgseXyXJHKweVavia+8H3ea3hAIk9kSrouzLj/P3B9yElUkcWsu5t0aUIfNhJ8YR1h6F9oIdLyan7yMfUvpOux67PodhdtmQwlj0sNkxEcYHO8I2RUyNztD3Ra6wiRDTaESUcRlKgIAlFDd5DoTnvjfcVVOMRDWd6yBmxkRX/FWNQRrx6PXOxgRPAmlJFnt5o/y+vvxlyy/up5uPBUecEXjhrFv6eoKXg6Gsyo+WhznH3f6Bj1OudxlKQ8d55nWiT6AJchmUnjJTC5qsxCcug4Vxnjq4pRTPPyl9C0KHqdO9/I9Kx02DyY5GWB5whkIpyNSthIT927+retmH8PqlUW844PIe6bRN3+xKP+MAe/dMsOlWmy+hSFYZQKYq2gPpc7uO5Uv26197yqEL25bKLYhFXBhByl1R93sEBWfYTCozBOWvWHrHv40A89jA6qQXHO1OaJwTAuentUU3qrLvIbM7qcsYmCrXKucboTzsq8ei2TK8L0ZuWkjoFC7WmUyWmhAs7QqPNXpnjH3uCHAGQtUm5mgX4d+mfeVqH09YpqIN/h3LeOXX5PtEYESaBYpiDUO1h/mx6Hf3paZulh4pYT1V2NyIhv/w4OblkbCGusKs81UMC5T5EjZjygxvG3v8utY6v/GNGHtKP5zPHzu2RRKXeO3ZOgUXRBC4BM+ILbi7kXqq6qjFU9s29BPy/pC9ELHtbtq7x07T2UFIc1Bnnke2MdNhYZqR0vkUGKBPfKhYs9GJo1boIOI/KO2x8HDJBV/knTLaQuKhEeFspJWAL9bCZ1IGa10sWIUAA6CIyqNQljq9VUMPvStHWFwPyOS8HIzQX6TjfHsX9bbOyJsWTfefGB07sun8oVAbjJ3zoSAB6aeUPgZVdjv6DWX2WGqp2mpwgYMxfyrBFrcyguALnpEnoQ0RcMFZ9X9yZ4eDtPbc9vNiFUQedpfZ0BDZ+NlNMTF2Dg+cZ74KD0g/23x5yE+FUo9sI8rn+Pm962D22haPen3QIGUHCZM9jQpaZT3IBVB99QCdi5r9LxoAKLUcSQI1Gr0IDO31LdDr2EAUC72OR5GRSSXdE8hFECIi78d/JVNr5G1ltPd9HBFL6Bm7Am8v4WXvQPQbax/BIXLMbMn65ZBOf1V5kcl2poKyqsleFAo9CkEU9qGLAr7bbbpYhTcaABpSNekwA5o7o2hJ6L+P0+MrYfoBuCMtbbW9Hp8Hs6q7F8305mjeM5CKmtANZ7+ILmF89mr1znui04SO/f6yR1WGG1LMWajJrKX4+p0+m46MkNb3ffnQWj7IHjKTvUK+5ez/tisVkBFJ5VIujo6U1WHjYMgt6lr/kuVltC8Z6hVWJoVoWMpqcwz2+GZVkoqpvklMT8cfvRefDEpkALo+P1wLycEXBW7gOMsKAVIFcGVIm3G5D8TwUjchg/H7sn5Bw8fBEGkeUdAF26IXetRXzLRwJvVj8G88mQ1EUE0eHslYJwqYKPo+N8bbGMfwrQSDp4y4QLRT2avFYHRyuCVI2vhkj4zYgskOyK5vu4OorKFmQ265owMct4o96ItRXgS0P2Ut5ViCH1k8PXM52+jSVT6SH2HJ/2dwx6NPvNBY0cKdP8umatubzo3/fj0YNwSqPjd66FM4RuZDWtu2xBVe8Y3LGdtO9RlJwTo0NzHDSnxo/8AzJIPObUL7Q9p+597Zpx9284Lz5Ggo14V2YgvE7skrVtRv3mUe+vWO3azLjk3eVkRzJfiJoAtMS70p61CaDsrasbMTHUSHPEueDdCEmrnUZK35ruhBlBj+0sYEGsa+u3KEdi9JT3Jw+HiWRZCRIYTEgpu7AzZKuqr1U5nr2RfqIbaiOm/vv7D5GRXgLydhsD38Ph7eGBNYANgRoP90bAfOPYErkV3zPw21zNrQoNxqx7wh0GAsF9eADy+V6B3JK7ovZlCRlVhLli/j/RYTqL93fI473T0wr2Jh8P5ZlN0jrPIVfJ1tLnZ/EZhJut6hN8di3kOaoTilV+RjlluRnBXtCCRVdWMTN4CyeGsC7nQBYK7SGKoEZ6pdHW2GX+3Cdyp4KEJLWYzRjLEAh9a6Iy+8AkloJlKEP5uHR09uRrfpKULD/KGoWnxaCiD2rfc/gY5V5vO4qFSf81PAV4RUPqDBqfEtQKgJ9DmDSeM+JpBhj93Bkxgw7UGqGEoehfw4Ib1wKpYYABifdww157mEWPqOCOU3cJTNBbCwlbuy7vetryQoX3863YdWc4J5AVviAF8Sz0KcjkkfJJ8X3LjhrmdTXK0W8Ea/Lie03hVVO21pfwI03w92MQPrU1e71Ae+OZhsdkUhaI8E1Fs58fVb8RO4VbOvyo2N8jG3TQymtcSgmOSjvoOZ+AAYEA3zjk6z/X60zd3wqsbLcVanmewXEI3o09AJ4LTvpu8mZ2OEdUVcw+/fhwt1nvEAMdrG4y3RZChIb6xbrK0bjZqL6tIV3lulLzSdqPGyMJJZe74D1N93o1GHQpz1cZN0EzbuzkpUEa6qegmlawE416+8NX6oZpRLWrijO9jIu6GmrjCicD2LiRDqgMepaTQ8py6YcCDTWrpm1AV5Y/WW2S6+aImKOE6OqeGlalL6WJV79PvL8fa91L3aW8EP1kK+ncVqeSAAYawh63mCZuT5T47Wv2Q6ZfXNJ7Zt/AsUYsrAjqs1ZZ9pn0B1j7P0SgtfXzPJZ8fm7jyrXK01lpM9Yhacawp4OalGeD9rLBHm/qT7Y3E0+jMVzsoKWbV+CguE3mRAV94VWB17UQOlveMXtPj1G0FFbpt9IglYaEDvfBkBRWe68OiV5A87BonlyoHOqmbbT8b9SFjHvtmnPUZ89wmKNkzdfX9VbGCNFYDuzy6ihF3USj42QrCZ1HMq1+SrcxRF+hNjtwwOGJYnTeR+SCTwpB66s57PvtkziFRMr5Pd37jtqhGPSnDaVPeSIDmE2QQCK6iJLJt3f0thWlmIQcJCkaas93ARWTP3mxYrsggHN33vltAjVgbfwHSzLvjtGt+aqLdRf9ZOkQKNT7VzbS8qM7qcruEZPquEmaNR288v2Pkm9KeXS9UG3fCrnBjTvaNDQ50VxNb53EWcvhdfVOvCMtAQMzitE5qRtI0hK8VASgEsOEdOpiVtJ+4Bkigbs6COz9vgqsgNUsdGgH4J3InsWAVYdw/k+creTq7vSVFNOE5iKBLec5Rt8kyL8m6H6B+yBzg9tHHvMMRAc/HquihSYeQGpq9T9TL3trQONoK1SrDOQNnNpHGfDH5jU8rseC3WZ73Orv1Q/8Z1fKcRdknLCKXvyr85hVx/JEPJRWUm2GT5frrnLbOWWSowtGouhJeB8G2DGoF42VQ0hBCpAPLDm7s4DvbmBa+oJhMZOl4MjKVH5/fktPgKzSg0x7ycYlBdAobjDSjSyBxvsXYMnbDjZ813y4vmZtHbwvmHfHjD1TaTOWR2Noez3lizm9+Ps1msRgWBR0s/cXSj4SZIvv2V/Mj9SN2MqYxNaiTAs3MVmKB8Ky163ValzYWbsxz0oiSYpbe0Em5gRuQUEwUVsZxvcfG5goUejIG0OFFmnvyw/1TqskAD6hi4r8lu/bSvTUFaRJxIgIEsnzPy7YrnHbNwD4RU9PjQBZgvas48K1HJZwgOLp2zkb3xaGvd2BgdSBO/suF2I3oirD5qnp+qvlMXMJIGYyK+wLkasMB+eHr1mn41JCg3lymLSUJP5/mCMIyYU63W+J3zuPfj1fmcsM6iGo/JNMIo4UuihkTRHNwAyI4CaTQMZ8pmPouCIlsTuzmIShFdxPQOM9mVL5sDOk0tymswN1QfMm11YQ/FwlHtdnVFpIb+3mJ";
  var hash$2 = "497b89b2";
  var wasmJson$2 = {
  	name: name$2,
  	data: data$2,
  	hash: hash$2
  };
  const validateHashCharacters = (hash) => {
      if (!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(hash)) {
          return false;
      }
      if (hash[4] === '0' && parseInt(hash[5], 10) < 4) {
          return false;
      }
      if (hash[4] === '3' && parseInt(hash[5], 10) > 1) {
          return false;
      }
      return true;
  };
  const validateVerifyOptions = (options) => {
      if (!options || typeof options !== 'object') {
          throw new Error('Invalid options parameter. It requires an object.');
      }
      if (options.hash === undefined || typeof options.hash !== 'string') {
          throw new Error('Hash should be specified');
      }
      if (options.hash.length !== 60) {
          throw new Error('Hash should be 60 bytes long');
      }
      if (!validateHashCharacters(options.hash)) {
          throw new Error('Invalid hash');
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
          throw new Error('Password should be at least 1 byte long');
      }
      if (options.password.length > 72) {
          throw new Error('Password should be at most 72 bytes long');
      }
  };
  /**
   * Verifies password using bcrypt password-hashing function
   * @returns True if the encoded hash matches the password
   */
  function bcryptVerify(options) {
      return __awaiter(this, void 0, void 0, function* () {
          validateVerifyOptions(options);
          const { hash, password } = options;
          const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
          bcryptInterface.writeMemory(getUInt8Buffer(hash), 0);
          const passwordBuffer = getUInt8Buffer(password);
          bcryptInterface.writeMemory(passwordBuffer, 60);
          return !!bcryptInterface.getExports().bcrypt_verify(passwordBuffer.length);
      });
  }

  new Mutex();

  new Mutex();

  // Generated using scripts/write-decode-map.ts
  var htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
      .split("")
      .map((c) => c.charCodeAt(0)));

  // Generated using scripts/write-decode-map.ts
  var xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
      .split("")
      .map((c) => c.charCodeAt(0)));

  // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
  var _a;
  const decodeMap = new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
  ]);
  /**
   * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
   */
  const fromCodePoint = 
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
      let output = "";
      if (codePoint > 0xffff) {
          codePoint -= 0x10000;
          output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
          codePoint = 0xdc00 | (codePoint & 0x3ff);
      }
      output += String.fromCharCode(codePoint);
      return output;
  };
  /**
   * Replace the given code point with a replacement character if it is a
   * surrogate or is outside the valid range. Otherwise return the code
   * point unchanged.
   */
  function replaceCodePoint(codePoint) {
      var _a;
      if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
          return 0xfffd;
      }
      return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
  }

  var CharCodes;
  (function (CharCodes) {
      CharCodes[CharCodes["NUM"] = 35] = "NUM";
      CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
      CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
      CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
      CharCodes[CharCodes["NINE"] = 57] = "NINE";
      CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
      CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
      CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
      CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
      CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
      CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  /** Bit that needs to be set to convert an upper case ASCII character to lower case */
  const TO_LOWER_BIT = 0b100000;
  var BinTrieFlags;
  (function (BinTrieFlags) {
      BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function isNumber$1(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code) {
      return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
          (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
  }
  function isAsciiAlphaNumeric(code) {
      return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
          (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
          isNumber$1(code));
  }
  /**
   * Checks if the given character is a valid end character for an entity in an attribute.
   *
   * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
   * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
   */
  function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  }
  var EntityDecoderState;
  (function (EntityDecoderState) {
      EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function (DecodingMode) {
      /** Entities in text nodes that can end with any character. */
      DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
      /** Only allow entities terminated with a semicolon. */
      DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
      /** Entities in attributes have limitations on ending characters. */
      DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  /**
   * Token decoder with support of writing partial entities.
   */
  class EntityDecoder {
      constructor(
      /** The tree used to decode entities. */
      decodeTree, 
      /**
       * The function that is called when a codepoint is decoded.
       *
       * For multi-byte named entities, this will be called multiple times,
       * with the second codepoint, and the same `consumed` value.
       *
       * @param codepoint The decoded codepoint.
       * @param consumed The number of bytes consumed by the decoder.
       */
      emitCodePoint, 
      /** An object that is used to produce errors. */
      errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          /** The current state of the decoder. */
          this.state = EntityDecoderState.EntityStart;
          /** Characters that were consumed while parsing an entity. */
          this.consumed = 1;
          /**
           * The result of the entity.
           *
           * Either the result index of a numeric entity, or the codepoint of a
           * numeric entity.
           */
          this.result = 0;
          /** The current index in the decode tree. */
          this.treeIndex = 0;
          /** The number of characters that were consumed in excess. */
          this.excess = 1;
          /** The mode in which the decoder is operating. */
          this.decodeMode = DecodingMode.Strict;
      }
      /** Resets the instance to make it reusable. */
      startEntity(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
      }
      /**
       * Write an entity to the decoder. This can be called multiple times with partial entities.
       * If the entity is incomplete, the decoder will return -1.
       *
       * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
       * entity is incomplete, and resume when the next string is written.
       *
       * @param string The string containing the entity (or a continuation of the entity).
       * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      write(str, offset) {
          switch (this.state) {
              case EntityDecoderState.EntityStart: {
                  if (str.charCodeAt(offset) === CharCodes.NUM) {
                      this.state = EntityDecoderState.NumericStart;
                      this.consumed += 1;
                      return this.stateNumericStart(str, offset + 1);
                  }
                  this.state = EntityDecoderState.NamedEntity;
                  return this.stateNamedEntity(str, offset);
              }
              case EntityDecoderState.NumericStart: {
                  return this.stateNumericStart(str, offset);
              }
              case EntityDecoderState.NumericDecimal: {
                  return this.stateNumericDecimal(str, offset);
              }
              case EntityDecoderState.NumericHex: {
                  return this.stateNumericHex(str, offset);
              }
              case EntityDecoderState.NamedEntity: {
                  return this.stateNamedEntity(str, offset);
              }
          }
      }
      /**
       * Switches between the numeric decimal and hexadecimal states.
       *
       * Equivalent to the `Numeric character reference state` in the HTML spec.
       *
       * @param str The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericStart(str, offset) {
          if (offset >= str.length) {
              return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
              this.state = EntityDecoderState.NumericHex;
              this.consumed += 1;
              return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
      }
      addToNumericResult(str, start, end, base) {
          if (start !== end) {
              const digitCount = end - start;
              this.result =
                  this.result * Math.pow(base, digitCount) +
                      parseInt(str.substr(start, digitCount), base);
              this.consumed += digitCount;
          }
      }
      /**
       * Parses a hexadecimal numeric entity.
       *
       * Equivalent to the `Hexademical character reference state` in the HTML spec.
       *
       * @param str The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericHex(str, offset) {
          const startIdx = offset;
          while (offset < str.length) {
              const char = str.charCodeAt(offset);
              if (isNumber$1(char) || isHexadecimalCharacter(char)) {
                  offset += 1;
              }
              else {
                  this.addToNumericResult(str, startIdx, offset, 16);
                  return this.emitNumericEntity(char, 3);
              }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
      }
      /**
       * Parses a decimal numeric entity.
       *
       * Equivalent to the `Decimal character reference state` in the HTML spec.
       *
       * @param str The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericDecimal(str, offset) {
          const startIdx = offset;
          while (offset < str.length) {
              const char = str.charCodeAt(offset);
              if (isNumber$1(char)) {
                  offset += 1;
              }
              else {
                  this.addToNumericResult(str, startIdx, offset, 10);
                  return this.emitNumericEntity(char, 2);
              }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
      }
      /**
       * Validate and emit a numeric entity.
       *
       * Implements the logic from the `Hexademical character reference start
       * state` and `Numeric character reference end state` in the HTML spec.
       *
       * @param lastCp The last code point of the entity. Used to see if the
       *               entity was terminated with a semicolon.
       * @param expectedLength The minimum number of characters that should be
       *                       consumed. Used to validate that at least one digit
       *                       was consumed.
       * @returns The number of characters that were consumed.
       */
      emitNumericEntity(lastCp, expectedLength) {
          var _a;
          // Ensure we consumed at least one digit.
          if (this.consumed <= expectedLength) {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
          }
          // Figure out if this is a legit end of the entity
          if (lastCp === CharCodes.SEMI) {
              this.consumed += 1;
          }
          else if (this.decodeMode === DecodingMode.Strict) {
              return 0;
          }
          this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
          if (this.errors) {
              if (lastCp !== CharCodes.SEMI) {
                  this.errors.missingSemicolonAfterCharacterReference();
              }
              this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
      }
      /**
       * Parses a named entity.
       *
       * Equivalent to the `Named character reference state` in the HTML spec.
       *
       * @param str The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNamedEntity(str, offset) {
          const { decodeTree } = this;
          let current = decodeTree[this.treeIndex];
          // The mask is the number of bytes of the value, including the current byte.
          let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
              const char = str.charCodeAt(offset);
              this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
              if (this.treeIndex < 0) {
                  return this.result === 0 ||
                      // If we are parsing an attribute
                      (this.decodeMode === DecodingMode.Attribute &&
                          // We shouldn't have consumed any characters after the entity,
                          (valueLength === 0 ||
                              // And there should be no invalid characters.
                              isEntityInAttributeInvalidEnd(char)))
                      ? 0
                      : this.emitNotTerminatedNamedEntity();
              }
              current = decodeTree[this.treeIndex];
              valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
              // If the branch is a value, store it and continue
              if (valueLength !== 0) {
                  // If the entity is terminated by a semicolon, we are done.
                  if (char === CharCodes.SEMI) {
                      return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                  }
                  // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                  if (this.decodeMode !== DecodingMode.Strict) {
                      this.result = this.treeIndex;
                      this.consumed += this.excess;
                      this.excess = 0;
                  }
              }
          }
          return -1;
      }
      /**
       * Emit a named entity that was not terminated with a semicolon.
       *
       * @returns The number of characters consumed.
       */
      emitNotTerminatedNamedEntity() {
          var _a;
          const { result, decodeTree } = this;
          const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
      }
      /**
       * Emit a named entity.
       *
       * @param result The index of the entity in the decode tree.
       * @param valueLength The number of bytes in the entity.
       * @param consumed The number of characters consumed.
       *
       * @returns The number of characters consumed.
       */
      emitNamedEntityData(result, valueLength, consumed) {
          const { decodeTree } = this;
          this.emitCodePoint(valueLength === 1
              ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
              : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
              // For multi-byte values, we need to emit the second byte.
              this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
      }
      /**
       * Signal to the parser that the end of the input was reached.
       *
       * Remaining data will be emitted and relevant errors will be produced.
       *
       * @returns The number of characters consumed.
       */
      end() {
          var _a;
          switch (this.state) {
              case EntityDecoderState.NamedEntity: {
                  // Emit a named entity if we have one.
                  return this.result !== 0 &&
                      (this.decodeMode !== DecodingMode.Attribute ||
                          this.result === this.treeIndex)
                      ? this.emitNotTerminatedNamedEntity()
                      : 0;
              }
              // Otherwise, emit a numeric entity if we have one.
              case EntityDecoderState.NumericDecimal: {
                  return this.emitNumericEntity(0, 2);
              }
              case EntityDecoderState.NumericHex: {
                  return this.emitNumericEntity(0, 3);
              }
              case EntityDecoderState.NumericStart: {
                  (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                  return 0;
              }
              case EntityDecoderState.EntityStart: {
                  // Return 0 if we have no entity.
                  return 0;
              }
          }
      }
  }
  /**
   * Creates a function that decodes entities in a string.
   *
   * @param decodeTree The decode tree.
   * @returns A function that decodes entities in a string.
   */
  function getDecoder(decodeTree) {
      let ret = "";
      const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint(str)));
      return function decodeWithTrie(str, decodeMode) {
          let lastIndex = 0;
          let offset = 0;
          while ((offset = str.indexOf("&", offset)) >= 0) {
              ret += str.slice(lastIndex, offset);
              decoder.startEntity(decodeMode);
              const len = decoder.write(str, 
              // Skip the "&"
              offset + 1);
              if (len < 0) {
                  lastIndex = offset + decoder.end();
                  break;
              }
              lastIndex = offset + len;
              // If `len` is 0, skip the current `&` and continue.
              offset = len === 0 ? lastIndex + 1 : lastIndex;
          }
          const result = ret + str.slice(lastIndex);
          // Make sure we don't keep a reference to the final string.
          ret = "";
          return result;
      };
  }
  /**
   * Determines the branch of the current node that is taken given the current
   * character. This function is used to traverse the trie.
   *
   * @param decodeTree The trie.
   * @param current The current node.
   * @param nodeIdx The index right after the current node and its value.
   * @param char The current character.
   * @returns The index of the next node, or -1 if no branch is taken.
   */
  function determineBranch(decodeTree, current, nodeIdx, char) {
      const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      // Case 1: Single branch encoded in jump offset
      if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      // Case 2: Multiple branches encoded in jump table
      if (jumpOffset) {
          const value = char - jumpOffset;
          return value < 0 || value >= branchCount
              ? -1
              : decodeTree[nodeIdx + value] - 1;
      }
      // Case 3: Multiple branches encoded in dictionary
      // Binary search for the character.
      let lo = nodeIdx;
      let hi = lo + branchCount - 1;
      while (lo <= hi) {
          const mid = (lo + hi) >>> 1;
          const midVal = decodeTree[mid];
          if (midVal < char) {
              lo = mid + 1;
          }
          else if (midVal > char) {
              hi = mid - 1;
          }
          else {
              return decodeTree[mid + branchCount];
          }
      }
      return -1;
  }
  const htmlDecoder = getDecoder(htmlDecodeTree);
  const xmlDecoder = getDecoder(xmlDecodeTree);
  /**
   * Decodes an HTML string.
   *
   * @param str The string to decode.
   * @param mode The decoding mode.
   * @returns The decoded string.
   */
  function decodeHTML(str, mode = DecodingMode.Legacy) {
      return htmlDecoder(str, mode);
  }
  /**
   * Decodes an XML string, requiring all entities to be terminated by a semicolon.
   *
   * @param str The string to decode.
   * @returns The decoded string.
   */
  function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
  }

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * @module verifications
   * @ignore
   */

  /**
   * Check if string contains the proof
   * @function
   * @param {string} data - Data potentially containing the proof
   * @param {import('./types').VerificationParams} params - Verification parameters
   * @returns {Promise<boolean>} Whether the proof was found in the string
   */
  const containsProof = async (data, params) => {
    const fingerprintFormatted = generateClaim(params.target, params.claimFormat);
    const fingerprintURI = generateClaim(params.target, ClaimFormat.URI);
    let result = false;

    // Decode eventual special entities
    switch (params.proofEncodingFormat) {
      case EntityEncodingFormat.HTML:
        data = decodeHTML(data);
        break

      case EntityEncodingFormat.XML:
        data = decodeXML(data);
        break
    }
    data = decodeHTML(data);

    // Check for plaintext proof
    result = data
      // remove newlines and carriage returns
      .replace(/\r?\n|\r/g, '')
      // remove spaces
      .replace(/\s/g, '')
      // normalize
      .toLowerCase()
      // search for fingerprint
      .indexOf(fingerprintFormatted.toLowerCase()) !== -1;

    // Check for hashed proof
    if (!result) {
      const hashRe = /\$(argon2(?:id|d|i)|2a|2b|2y)(?:\$[a-zA-Z0-9=+\-,./]+)+/g;
      let match;

      while (!result && (match = hashRe.exec(data)) != null) {
        let timeoutHandle;
        const timeoutPromise = new Promise((resolve, reject) => {
          timeoutHandle = setTimeout(
            () => {
              resolve(false);
            }, 1000
          );
        });

        switch (match[1]) {
          case '2a':
          case '2b':
          case '2y':
            try {
              // Patch until promise.race properly works on WASM
              if (parseInt(match[0].split('$')[2]) > 12) continue

              const hashPromise = bcryptVerify({
                password: fingerprintURI.toLowerCase(),
                hash: match[0]
              })
                .then(result => result)
                .catch(_ => false);

              result = await Promise.race([hashPromise, timeoutPromise]).then((result) => {
                clearTimeout(timeoutHandle);
                return result
              });
            } catch (err) {
              result = false;
            }

            // Accept mixed-case fingerprints until deadline
            if (!result) {
              try {
                // Patch until promise.race properly works on WASM
                if (parseInt(match[0].split('$')[2]) > 12) continue

                const hashPromise = bcryptVerify({
                  password: fingerprintURI,
                  hash: match[0]
                })
                  .then(result => result)
                  .catch(_ => false);

                result = await Promise.race([hashPromise, timeoutPromise]).then((result) => {
                  clearTimeout(timeoutHandle);
                  return result
                });
              } catch (err) {
                result = false;
              }
            }
            break

          case 'argon2':
          case 'argon2i':
          case 'argon2d':
          case 'argon2id':
            try {
              const hashPromise = argon2Verify({
                password: fingerprintURI.toLowerCase(),
                hash: match[0]
              })
                .then(result => result)
                .catch(_ => false);

              result = await Promise.race([hashPromise, timeoutPromise]).then((result) => {
                clearTimeout(timeoutHandle);
                return result
              });
            } catch (err) {
              result = false;
            }

            // Accept mixed-case fingerprints until deadline
            if (!result) {
              try {
                const hashPromise = argon2Verify({
                  password: fingerprintURI,
                  hash: match[0]
                })
                  .then(result => result)
                  .catch(_ => false);

                result = await Promise.race([hashPromise, timeoutPromise]).then((result) => {
                  clearTimeout(timeoutHandle);
                  return result
                });
              } catch (err) {
                result = false;
              }
            }
            break
        }
      }
    }

    // Check for HTTP proof
    if (!result) {
      const uris = getUriFromString(data);

      for (let index = 0; index < uris.length; index++) {
        if (result) continue

        const candidate = uris[index];
        /** @type {URL} */
        let candidateURL;

        try {
          candidateURL = new URL(candidate);
        } catch (_) {
          continue
        }

        if (candidateURL.protocol !== 'https:') {
          continue
        }

        // Using fetch -> axios doesn't find the ariadne-identity-proof header
        /** @type {Response} */
        const response = await fetch(candidate, {
          method: 'HEAD'
        })
          .catch(e => {
            return undefined
          });

        if (!response) continue
        if (response.status !== 200) continue
        if (!response.headers.get('ariadne-identity-proof')) continue

        result = response.headers.get('ariadne-identity-proof')
          .toLowerCase()
          .indexOf(fingerprintURI.toLowerCase()) !== -1;
      }
    }

    return result
  };

  /**
   * Run a JSON object through the verification process
   * @function
   * @param {*} proofData - Data potentially containing the proof
   * @param {Array<string>} checkPath - Paths to check for proof
   * @param {import('./types').VerificationParams} params - Verification parameters
   * @returns {Promise<boolean>} Whether the proof was found in the object
   */
  const runJSON = async (proofData, checkPath, params) => {
    if (!proofData) {
      return false
    }

    if (Array.isArray(proofData)) {
      let result = false;

      for (let index = 0; index < proofData.length; index++) {
        const item = proofData[index];

        if (result) {
          continue
        }

        result = await runJSON(item, checkPath, params);
      }

      return result
    }

    if (checkPath.length === 0) {
      switch (params.claimRelation) {
        case ClaimRelation.ONEOF:
          return await containsProof(proofData.join('|'), params)

        case ClaimRelation.CONTAINS:
        case ClaimRelation.EQUALS:
        default:
          return await containsProof(proofData, params)
      }
    }

    if (typeof proofData === 'object' && !(checkPath[0] in proofData)) {
      throw new Error('err_json_structure_incorrect')
    }

    return await runJSON(
      proofData[checkPath[0]],
      checkPath.slice(1),
      params
    )
  };

  /**
   * Run the verification by searching for the proof in the fetched data
   * @param {object} proofData - The proof data
   * @param {ServiceProvider} claimData - The claim data
   * @param {string} fingerprint - The fingerprint
   * @returns {Promise<import('./types').VerificationResult>} Result of the verification
   */
  async function run (proofData, claimData, fingerprint) {
    /** @type {import('./types').VerificationResult} */
    const res = {
      result: false,
      completed: false,
      errors: []
    };

    switch (claimData.proof.response.format) {
      case ProofFormat.JSON:
        for (let index = 0; index < claimData.proof.target.length; index++) {
          const claimMethod = claimData.proof.target[index];
          try {
            res.result = res.result || await runJSON(
              proofData,
              claimMethod.path,
              {
                target: fingerprint,
                claimFormat: claimMethod.format,
                proofEncodingFormat: claimMethod.encoding,
                claimRelation: claimMethod.relation
              }
            );
          } catch (error) {
            res.errors.push(error.message ? error.message : error);
          }
        }
        res.completed = true;
        break
      case ProofFormat.TEXT:
        for (let index = 0; index < claimData.proof.target.length; index++) {
          const claimMethod = claimData.proof.target[index];
          try {
            res.result = res.result || await containsProof(
              proofData,
              {
                target: fingerprint,
                claimFormat: claimMethod.format,
                proofEncodingFormat: claimMethod.encoding,
                claimRelation: claimMethod.relation
              }
            );
          } catch (error) {
            res.errors.push('err_unknown_text_verification');
          }
        }
        res.completed = true;
        break
    }

    // Reset the errors if one of the claim methods was successful
    if (res.result) {
      res.errors = [];
    }

    return res
  }

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * @module proofs
   */

  /**
   * Delegate the proof request to the correct fetcher.
   * This method uses the current environment (browser/node), certain values from
   * the `data` parameter and the proxy policy set in the `opts` parameter to
   * choose the right approach to fetch the proof. An error will be thrown if no
   * approach is possible.
   * @param {ServiceProvider} data - Data from a claim definition
   * @param {import('./types').VerificationConfig} opts - Options to enable the request
   * @returns {Promise<object|string>} Fetched proof data
   */
  async function fetch$2 (data, opts) {
    if (isNode_1) {
      return handleNodeRequests(data, opts)
    }

    return handleBrowserRequests(data, opts)
  }

  /**
   * @param {ServiceProvider} data - Data from a claim definition
   * @param {object} opts - Options to enable the request
   * @returns {Promise<object|string>} Fetched proof data
   */
  const handleBrowserRequests = (data, opts) => {
    switch (opts.proxy.policy) {
      case ProxyPolicy.ALWAYS:
        return createProxyRequestPromise(data, opts)

      case ProxyPolicy.NEVER:
        switch (data.proof.request.accessRestriction) {
          case ProofAccessRestriction.NONE:
          case ProofAccessRestriction.GRANTED:
            return createDefaultRequestPromise(data, opts)
          case ProofAccessRestriction.NOCORS:
          case ProofAccessRestriction.SERVER:
            throw new Error(
              'Impossible to fetch proof (bad combination of service access and proxy policy)'
            )
          default:
            throw new Error('Invalid proof access value')
        }

      case ProxyPolicy.ADAPTIVE:
        switch (data.proof.request.accessRestriction) {
          case ProofAccessRestriction.NONE:
            return createFallbackRequestPromise(data, opts)
          case ProofAccessRestriction.NOCORS:
            return createProxyRequestPromise(data, opts)
          case ProofAccessRestriction.GRANTED:
            return createFallbackRequestPromise(data, opts)
          case ProofAccessRestriction.SERVER:
            return createProxyRequestPromise(data, opts)
          default:
            throw new Error('Invalid proof access value')
        }

      default:
        throw new Error('Invalid proxy policy')
    }
  };

  /**
   * @param {ServiceProvider} data - Data from a claim definition
   * @param {object} opts - Options to enable the request
   * @returns {Promise<object|string>} Fetched proof data
   */
  const handleNodeRequests = (data, opts) => {
    switch (opts.proxy.policy) {
      case ProxyPolicy.ALWAYS:
        return createProxyRequestPromise(data, opts)

      case ProxyPolicy.NEVER:
        return createDefaultRequestPromise(data, opts)

      case ProxyPolicy.ADAPTIVE:
        return createFallbackRequestPromise(data, opts)

      default:
        throw new Error('Invalid proxy policy')
    }
  };

  /**
   * @param {ServiceProvider} data - Data from a claim definition
   * @param {object} opts - Options to enable the request
   * @returns {Promise<object|string>} Fetched proof data
   */
  const createDefaultRequestPromise = (data, opts) => {
    return new Promise((resolve, reject) => {
      if (!(data.proof.request.fetcher in fetcher)) {
        reject(new Error(`fetcher for ${data.proof.request.fetcher} not found`));
      }
      fetcher[data.proof.request.fetcher]
        .fn(data.proof.request.data, opts)
        .then((res) => {
          return resolve({
            fetcher: data.proof.request.fetcher,
            data,
            viaProxy: false,
            result: res
          })
        })
        .catch((err) => {
          return reject(err)
        });
    })
  };

  /**
   * @param {ServiceProvider} data - Data from a claim definition
   * @param {object} opts - Options to enable the request
   * @returns {Promise<object|string>} Fetched proof data
   */
  const createProxyRequestPromise = (data, opts) => {
    return new Promise((resolve, reject) => {
      let proxyUrl;
      try {
        proxyUrl = generateProxyURL(
          data.proof.request.fetcher,
          data.proof.request.data,
          opts
        );
      } catch (err) {
        reject(err);
      }

      const requestData = {
        url: proxyUrl,
        format: data.proof.response.format,
        fetcherTimeout: data.proof.request.fetcher in fetcher ? fetcher[data.proof.request.fetcher].timeout : 30000
      };
      fn$5(requestData)
        .then((res) => {
          return resolve({
            fetcher: 'http',
            data,
            viaProxy: true,
            result: res
          })
        })
        .catch((err) => {
          return reject(err)
        });
    })
  };

  /**
   * @param {ServiceProvider} data - Data from a claim definition
   * @param {object} opts - Options to enable the request
   * @returns {Promise<object|string>} Fetched proof data
   */
  const createFallbackRequestPromise = (data, opts) => {
    return new Promise((resolve, reject) => {
      createDefaultRequestPromise(data, opts)
        .then((res) => {
          return resolve(res)
        })
        .catch((err1) => {
          createProxyRequestPromise(data, opts)
            .then((res) => {
              return resolve(res)
            })
            .catch((err2) => {
              return reject(err2)
            });
        });
    })
  };

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  /**
   * @class
   * @classdesc Identity claim
   * @property {string} uri             - The claim's URI
   * @property {string} fingerprint     - The fingerprint to verify the claim against
   * @property {number} status          - The current status code of the claim
   * @property {Array<object>} matches  - The claim definitions matched against the URI
   * @example
   * const claim = doip.Claim();
   * const claim = doip.Claim('dns:domain.tld?type=TXT');
   * const claim = doip.Claim('dns:domain.tld?type=TXT', '123abc123abc');
   */
  class Claim {
    /**
     * Initialize a Claim object
     * @param {string} [uri]          - The URI of the identity claim
     * @param {string} [fingerprint]  - The fingerprint of the OpenPGP key
     */
    constructor (uri, fingerprint) {
      // Verify validity of URI
      if (uri && !validUrlExports.isUri(uri)) {
        throw new Error('Invalid URI')
      }

      // Verify validity of fingerprint
      if (fingerprint) {
        try {
          // @ts-ignore
          _default.default(fingerprint);
        } catch (err) {
          throw new Error('Invalid fingerprint')
        }
      }

      /**
       * @type {string}
       */
      this._uri = uri || '';
      /**
       * @type {string}
       */
      this._fingerprint = fingerprint || '';
      /**
       * @type {number}
       */
      this._status = ClaimStatus.INIT;
      /**
       * @type {Array<ServiceProvider>}
       */
      this._matches = [];
    }

    /**
     * @function
     * @param {*} claimObject - JSON representation of a claim
     * @returns {Claim} Parsed claim
     * @throws Will throw an error if the JSON object can't be coerced into a Claim
     * @example
     * doip.Claim.fromJSON(JSON.stringify(claim));
     */
    static fromJSON (claimObject) {
      /** @type {Claim} */
      let claim;
      let result;

      if (typeof claimObject === 'object' && 'claimVersion' in claimObject) {
        switch (claimObject.claimVersion) {
          case 1:
            result = importJsonClaimVersion1(claimObject);
            if (result instanceof Error) {
              throw result
            }
            claim = result;
            break

          case 2:
            result = importJsonClaimVersion2(claimObject);
            if (result instanceof Error) {
              throw result
            }
            claim = result;
            break

          default:
            throw new Error('Invalid claim version')
        }
      }

      return claim
    }

    get uri () {
      return this._uri
    }

    get fingerprint () {
      return this._fingerprint
    }

    get status () {
      return this._status
    }

    get matches () {
      if (this._status === ClaimStatus.INIT) {
        throw new Error('This claim has not yet been matched')
      }
      return this._matches
    }

    set uri (uri) {
      if (this._status !== ClaimStatus.INIT) {
        throw new Error(
          'Cannot change the URI, this claim has already been matched'
        )
      }
      // Verify validity of URI
      if (uri.length > 0 && !validUrlExports.isUri(uri)) {
        throw new Error('The URI was invalid')
      }
      // Remove leading and trailing spaces
      uri = uri.replace(/^\s+|\s+$/g, '');

      this._uri = uri;
    }

    set fingerprint (fingerprint) {
      if (this._status === ClaimStatus.VERIFIED) {
        throw new Error(
          'Cannot change the fingerprint, this claim has already been verified'
        )
      }
      this._fingerprint = fingerprint;
    }

    set status (anything) {
      throw new Error("Cannot change a claim's status")
    }

    set matches (anything) {
      throw new Error("Cannot change a claim's matches")
    }

    /**
     * Match the claim's URI to candidate definitions
     * @function
     */
    match () {
      if (this._status !== ClaimStatus.INIT) {
        throw new Error('This claim was already matched')
      }
      if (this._uri.length === 0 || !validUrlExports.isUri(this._uri)) {
        throw new Error('This claim has no URI')
      }

      this._matches = [];

      list.every((name, i) => {
        const def = _data[name];

        // If the candidate is invalid, continue matching
        if (!def.reURI.test(this._uri)) {
          return true
        }

        const candidate = def.processURI(this._uri);
        // If the candidate could not be processed, continue matching
        if (!candidate) {
          return true
        }

        if (candidate.claim.uriIsAmbiguous) {
          // Add to the possible candidates
          this._matches.push(candidate);
        } else {
          // Set a single candidate and stop
          this._matches = [candidate];
          return false
        }

        // Continue matching
        return true
      });

      this._status = this._matches.length === 0 ? ClaimStatus.NO_MATCHES : ClaimStatus.MATCHED;
    }

    /**
     * Verify the claim. The proof for each candidate is sequentially fetched and
     * checked for the fingerprint. The verification stops when either a positive
     * result was obtained, or an unambiguous claim definition was processed
     * regardless of the result.
     * @function
     * @param {import('./types').VerificationConfig} [opts] - Options for proxy, fetchers
     */
    async verify (opts$1) {
      if (this._status === ClaimStatus.INIT) {
        throw new Error('This claim has not yet been matched')
      }
      if (this._status >= 200) {
        throw new Error('This claim has already been verified')
      }
      if (this._fingerprint.length === 0) {
        throw new Error('This claim has no fingerprint')
      }

      // Handle options
      opts$1 = mergeOptions$1(opts, opts$1 || {});

      // If there are no matches
      if (this._matches.length === 0) {
        this.status = ClaimStatus.NO_MATCHES;
      }

      // For each match
      for (let index = 0; index < this._matches.length; index++) {
        // Continue if a result was already obtained
        if (this._status >= 200) { continue }

        let claimData = this._matches[index];

        /** @type {import('./types').VerificationResult | null} */
        let verificationResult = null;
        let proofData = null;
        let proofFetchError;

        try {
          proofData = await fetch$2(claimData, opts$1);
        } catch (err) {
          proofFetchError = err;
        }

        if (proofData) {
          // Run the verification process
          verificationResult = await run(
            proofData.result,
            claimData,
            this._fingerprint
          );
          verificationResult.proof = {
            fetcher: proofData.fetcher,
            viaProxy: proofData.viaProxy
          };

          // Validate the result
          const def = _data[claimData.about.id];
          if (def.functions?.validate && verificationResult.completed && verificationResult.result) {
            try {
              (verificationResult.result = await def.functions.validate(claimData, proofData, verificationResult, opts$1));
            } catch (_) {}
          }

          // Post process the data
          if (def.functions?.postprocess) {
            try {
              ({ claimData, proofData } = await def.functions.postprocess(claimData, proofData, opts$1));
            } catch (_) {}
          }
        } else {
          // Consider the proof completed but with a negative result
          verificationResult = verificationResult || {
            result: false,
            completed: true,
            proof: null,
            errors: [proofFetchError]
          };
        }

        if (this.isAmbiguous() && !verificationResult.result) {
          // Assume a wrong match and continue
          continue
        }

        if (verificationResult.result) {
          this._status = verificationResult.proof.viaProxy ? ClaimStatus.VERIFIED_VIA_PROXY : ClaimStatus.VERIFIED;
          this._matches = [claimData];
        }
      }

      this._status = this._status >= 200 ? this._status : ClaimStatus.NO_PROOF_FOUND;
    }

    /**
     * Determine the ambiguity of the claim. A claim is only unambiguous if any
     * of the candidates is unambiguous. An ambiguous claim should never be
     * displayed in an user interface when its result is negative.
     * @function
     * @returns {boolean} Whether the claim is ambiguous
     */
    isAmbiguous () {
      if (this._status < ClaimStatus.MATCHED) {
        throw new Error('The claim has not been matched yet')
      }
      if (this._matches.length === 0) {
        throw new Error('The claim has no matches')
      }
      if (this._status >= 200 && this._status < 300) return false
      return this._matches.length > 1 || this._matches[0].claim.uriIsAmbiguous
    }

    /**
     * Get a JSON representation of the Claim object. Useful when transferring
     * data between instances/machines.
     * @function
     * @returns {object} JSON reprentation of the claim
     */
    toJSON () {
      let displayProfileName = this._uri;
      let displayProfileUrl = null;
      let displayProofUrl = null;
      let displayServiceProviderName = null;
      let displayServiceProviderId = null;

      if (this._status >= ClaimStatus.MATCHED && this._matches.length > 0 && !this.isAmbiguous()) {
        displayProfileName = this._matches[0].profile.display;
        displayProfileUrl = this._matches[0].profile.uri;
        displayProofUrl = this._matches[0].proof.request.uri;
        displayServiceProviderName = this._matches[0].about.name;
        displayServiceProviderId = this._matches[0].about.id;
      }

      return {
        claimVersion: 2,
        uri: this._uri,
        proofs: [this._fingerprint],
        matches: this._matches.map(x => x.toJSON()),
        status: this._status,
        display: {
          profileName: displayProfileName,
          profileUrl: displayProfileUrl,
          proofUrl: displayProofUrl,
          serviceProviderName: displayServiceProviderName,
          serviceProviderId: displayServiceProviderId
        }
      }
    }
  }

  /**
   * @ignore
   * @param {object} claimObject - JSON representation of a claim
   * @returns {Claim | Error} Parsed claim
   */
  function importJsonClaimVersion1 (claimObject) {
    if (!('claimVersion' in claimObject && claimObject.claimVersion === 1)) {
      return new Error('Invalid claim')
    }

    const claim = new Claim();

    claim._uri = claimObject.uri;
    claim._fingerprint = claimObject.fingerprint;
    claim._matches = claimObject.matches.map(x => new ServiceProvider(x));

    if (claimObject.status === 'init') {
      claim._status = 100;
    }
    if (claimObject.status === 'matched') {
      if (claimObject.matches.length === 0) {
        claim._status = 301;
      }
      claim._status = 101;
    }

    if (!('result' in claimObject.verification && 'errors' in claimObject.verification)) {
      claim._status = 400;
    }
    if (claimObject.verification.errors.length > 0) {
      claim._status = 400;
    }
    if (claimObject.verification.result && claimObject.verification.proof.viaProxy) {
      claim._status = 201;
    }
    if (claimObject.verification.result && !claimObject.verification.proof.viaProxy) {
      claim._status = 200;
    }

    return claim
  }

  /**
   * @ignore
   * @param {object} claimObject - JSON representation of a claim
   * @returns {Claim | Error} Parsed claim
   */
  function importJsonClaimVersion2 (claimObject) {
    if (!('claimVersion' in claimObject && claimObject.claimVersion === 2)) {
      return new Error('Invalid claim')
    }

    const claim = new Claim();

    claim._uri = claimObject.uri;
    claim._fingerprint = claimObject.proofs[0];
    claim._matches = claimObject.matches.map(x => new ServiceProvider(x));
    claim._status = claimObject.status;

    return claim
  }

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  const SupportedCryptoAlg = ['EdDSA', 'ES256', 'ES256K', 'ES384', 'ES512'];

  /**
   * Parse a JWS and extract the profile it contains
   * @function
   * @param {string} profileJws - Compact-Serialized profile JWS
   * @param {string} uri - The ASPE URI associated with the profile
   * @returns {Promise<Profile>} The extracted profile
   * @example
   * const key = await doip.aspe.parseProfileJws('...', 'aspe:domain.example:123');
   */
  async function parseProfileJws (profileJws, uri) {
    const matches = uri.match(/aspe:(.*):(.*)/);
    const localPart = matches[2].toUpperCase();

    // Decode the headers
    const protectedHeader = decodeProtectedHeader(profileJws);

    // Extract the JWK
    if (!SupportedCryptoAlg.includes(protectedHeader.alg)) {
      throw new Error('Invalid profile JWS: wrong key algorithm')
    }
    if (!protectedHeader.kid) {
      throw new Error('Invalid profile JWS: missing key identifier')
    }
    if (!protectedHeader.jwk) {
      throw new Error('Invalid profile JWS: missing key')
    }
    const publicKey = await importJWK(protectedHeader.jwk, protectedHeader.alg);

    // Compute and verify the fingerprint
    const fp = await computeJwkFingerprint(protectedHeader.jwk);

    if (fp !== protectedHeader.kid) {
      throw new Error('Invalid profile JWS: wrong key')
    }
    if (localPart && fp !== localPart) {
      throw new Error('Invalid profile JWS: wrong key')
    }

    // Decode the payload
    const { payload } = await compactVerify(profileJws, publicKey);
    const payloadJson = JSON.parse(new TextDecoder().decode(payload));

    // Verify the payload
    if (!(Object.prototype.hasOwnProperty.call(payloadJson, 'http://ariadne.id/type') && payloadJson['http://ariadne.id/type'] === 'profile')) {
      throw new Error('Invalid profile JWS: JWS is not a profile')
    }
    if (!(Object.prototype.hasOwnProperty.call(payloadJson, 'http://ariadne.id/version') && payloadJson['http://ariadne.id/version'] === 0)) {
      throw new Error('Invalid profile JWS: profile version not supported')
    }

    // Extract data from the payload
    /** @type {string} */
    const profileName = payloadJson['http://ariadne.id/name'];
    /** @type {string} */
    const profileDescription = payloadJson['http://ariadne.id/description'];
    /** @type {string} */
    const profileThemeColor = payloadJson['http://ariadne.id/color'];
    /** @type {Array<string>} */
    const profileClaims = payloadJson['http://ariadne.id/claims'];

    const profileClaimsParsed = profileClaims.map(x => new Claim(x, uri));

    const pe = new Persona(profileName, profileClaimsParsed);
    if (profileDescription) {
      pe.setDescription(profileDescription);
    }
    if (profileThemeColor && /^#([0-9A-F]{3}){1,2}$/i.test(profileThemeColor)) {
      pe.themeColor = profileThemeColor;
    }

    const profile = new Profile(ProfileType.ASP, uri, [pe]);
    profile.publicKey.fingerprint = fp;
    profile.publicKey.encoding = PublicKeyEncoding.JWK;
    profile.publicKey.encodedKey = JSON.stringify(protectedHeader.jwk);
    profile.publicKey.key = protectedHeader.jwk;

    switch (protectedHeader.alg) {
      case 'ES256':
        profile.publicKey.keyType = PublicKeyType.ES256;
        break

      case 'EdDSA':
        profile.publicKey.keyType = PublicKeyType.EDDSA;
        break

      default:
        profile.publicKey.keyType = PublicKeyType.UNKNOWN;
        break
    }

    return profile
  }

  /**
   * Compute the fingerprint for {@link https://github.com/panva/jose/blob/main/docs/interfaces/types.JWK.md JWK} keys
   * @function
   * @param {import('jose').JWK} key - The JWK public key for which to compute the fingerprint
   * @returns {Promise<string>} The computed fingerprint
   */
  async function computeJwkFingerprint (key) {
    const thumbprint = await calculateJwkThumbprint(key, 'sha512');
    const fingerprintBytes = base64url.parse(thumbprint, { loose: true }).slice(0, 16);
    const fingerprint = base32.stringify(fingerprintBytes, { pad: false });

    return fingerprint
  }

  /*
  Copyright 2024 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs from Profile obtained through ASPE
   * @module fetcher/aspe
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.aspe.fn({ aspeUri: 'aspe:domain.example:abc123def456' });
   */

  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$a = 5000;

  const reURI = /^aspe:([a-zA-Z0-9.\-_]*):([a-zA-Z0-9]*)/;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.aspeUri - ASPE URI of the targeted profile
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object>} The fetched claims from an ASP profile
   */
  async function fn$8 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$a
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      const match = data.aspeUri.match(reURI);

      if (!data.aspeUri || !reURI.test(data.aspeUri) || !isFQDN(match[1])) {
        reject(new Error('No valid ASPE URI provided'));
        return
      }

      const url = `https://${match[1]}/.well-known/aspe/id/${match[2].toUpperCase()}`;

      axios$1.get(url, {
        headers: {
          Accept: 'application/asp+jwt',
          'User-Agent': `doipjs/${version}`
        },
        validateStatus: (status) => status >= 200 && status < 400
      })
        .then(async res => await parseProfileJws(res.data, data.aspeUri))
        .then(profile =>
          profile.personas.flatMap(p => { return p.claims.map(c => c._uri) })
        )
        .then(res => {
          resolve({
            claims: res
          });
        })
        .catch(e => {
          reject(e);
        });
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var aspe = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$8,
    timeout: timeout$a
  });

  var dns$2 = {};

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using DNS TXT records
   * @module fetcher/dns
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.dns.fn({ domain: 'domain.example' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$9 = 5000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.domain - The targeted domain
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object>} The fetched DNS records
   */
  async function fn$7 (data, opts) {
    if (isBrowser_1) {
      return null
    }

    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$9
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      dns$2.resolveTxt(data.domain, (err, records) => {
        if (err) {
          reject(err);
          return
        }

        resolve({
          domain: data.domain,
          records: {
            txt: records
          }
        });
      });
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var dns$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$7,
    timeout: timeout$9
  });

  /*
  Copyright 2023 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using GraphQL queries
   * @module fetcher/graphql
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.graphql.fn({ url: 'https://domain.example/graphql/v2', query: '{ "query": "..." }' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$8 = 5000;

  /**
   * Execute a GraphQL query via HTTP request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.url - The URL pointing at the GraphQL HTTP endpoint
   * @param {string} data.query - The GraphQL query to fetch the data containing the proof
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object>} The fetched GraphQL object
   */
  async function fn$6 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$8
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      if (!data.url) {
        reject(new Error('No valid URI provided'));
        return
      }

      let jsonData;
      try {
        jsonData = JSON.parse(data.query);
      } catch (error) {
        reject(new Error('Invalid GraphQL query object'));
      }

      axios$1.post(data.url, jsonData, {
        headers: {
          'Content-Type': 'application/json',
          // @ts-ignore
          'User-Agent': `doipjs/${version}`
        },
        validateStatus: function (status) {
          return status >= 200 && status < 400
        }
      })
        .then(res => {
          resolve(res.data);
        })
        .catch(e => {
          reject(e);
        });
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var graphql = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$6,
    timeout: timeout$8
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using HTTP requests
   * @module fetcher/http
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.http.fn({ url: 'https://domain.example/data.json', format: 'json' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$7 = 5000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.url - The URL pointing at targeted content
   * @param {string} data.format - The format of the targeted content
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object|string>} The fetched JSON object or text
   */
  async function fn$5 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$7
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      if (!data.url) {
        reject(new Error('No valid URI provided'));
        return
      }

      switch (data.format) {
        case ProofFormat.JSON:
          axios$1.get(data.url, {
            headers: {
              Accept: 'application/json',
              // @ts-ignore
              'User-Agent': `doipjs/${version}`
            },
            validateStatus: function (status) {
              return status >= 200 && status < 400
            }
          })
            .then(res => {
              resolve(res.data);
            })
            .catch(e => {
              reject(e);
            });
          break
        case ProofFormat.TEXT:
          axios$1.get(data.url, {
            validateStatus: function (status) {
              return status >= 200 && status < 400
            },
            responseType: 'text'
          })
            .then(res => {
              resolve(res.data);
            })
            .catch(e => {
              reject(e);
            });
          break
        default:
          reject(new Error('No specified data format'));
          break
      }
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var http$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$5,
    timeout: timeout$7
  });

  var irc$1 = {};

  var _polyfillNode_net = {};

  var _polyfillNode_net$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _polyfillNode_net
  });

  var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_net$1);

  var _polyfillNode_tls = {};

  var _polyfillNode_tls$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _polyfillNode_tls
  });

  var require$$1$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_tls$1);

  var inherits;
  if (typeof Object.create === 'function'){
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits$1 = inherits;

  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
    function getOwnPropertyDescriptors(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };

  var formatRegExp = /%[sdj%]/g;
  function format$1(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  }

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global$1.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    if (browser$1$1.noDeprecation === true) {
      return fn;
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        if (browser$1$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = browser$1$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format$1.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  }

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray(ar) {
    return Array.isArray(ar);
  }

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  function isNull(arg) {
    return arg === null;
  }

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isString(arg) {
    return typeof arg === 'string';
  }

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }

  function isUndefined(arg) {
    return arg === void 0;
  }

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }

  function isBuffer(maybeBuf) {
    return Buffer.isBuffer(maybeBuf);
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  function log() {
    console.log('%s - %s', timestamp(), format$1.apply(null, arguments));
  }

  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

  function promisify(original) {
    if (typeof original !== 'function')
      throw new TypeError('The "original" argument must be of type Function');

    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== 'function') {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn, enumerable: false, writable: false, configurable: true
      });
      return fn;
    }

    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function (resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });

      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      args.push(function (err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });

      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }

      return promise;
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return Object.defineProperties(
      fn,
      getOwnPropertyDescriptors(original)
    );
  }

  promisify.custom = kCustomPromisifiedSymbol;

  function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
      var newReason = new Error('Promise was rejected with a falsy value');
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }

  function callbackify(original) {
    if (typeof original !== 'function') {
      throw new TypeError('The "original" argument must be of type Function');
    }

    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      var maybeCb = args.pop();
      if (typeof maybeCb !== 'function') {
        throw new TypeError('The last argument must be of type Function');
      }
      var self = this;
      var cb = function() {
        return maybeCb.apply(self, arguments);
      };
      // In true node style we process the callback on `nextTick` with all the
      // implications (stack, `uncaughtException`, `async_hooks`)
      original.apply(this, args)
        .then(function(ret) { browser$1$1.nextTick(cb.bind(null, null, ret)); },
          function(rej) { browser$1$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
    }

    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }

  var _polyfillNode_util = {
    inherits: inherits$1,
    _extend: _extend,
    log: log,
    isBuffer: isBuffer,
    isPrimitive: isPrimitive,
    isFunction: isFunction,
    isError: isError,
    isDate: isDate,
    isObject: isObject,
    isRegExp: isRegExp,
    isUndefined: isUndefined,
    isSymbol: isSymbol,
    isString: isString,
    isNumber: isNumber,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray,
    inspect: inspect,
    deprecate: deprecate,
    format: format$1,
    debuglog: debuglog,
    promisify: promisify,
    callbackify: callbackify,
  };

  var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _extend: _extend,
    callbackify: callbackify,
    debuglog: debuglog,
    default: _polyfillNode_util,
    deprecate: deprecate,
    format: format$1,
    inherits: inherits$1,
    inspect: inspect,
    isArray: isArray,
    isBoolean: isBoolean,
    isBuffer: isBuffer,
    isDate: isDate,
    isError: isError,
    isFunction: isFunction,
    isNull: isNull,
    isNullOrUndefined: isNullOrUndefined,
    isNumber: isNumber,
    isObject: isObject,
    isPrimitive: isPrimitive,
    isRegExp: isRegExp,
    isString: isString,
    isSymbol: isSymbol,
    isUndefined: isUndefined,
    log: log,
    promisify: promisify
  });

  var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

  var domain;

  // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).
  function EventHandlers() {}
  EventHandlers.prototype = Object.create(null);

  function EventEmitter$7() {
    EventEmitter$7.init.call(this);
  }

  // nodejs oddity
  // require('events') === require('events').EventEmitter
  EventEmitter$7.EventEmitter = EventEmitter$7;

  EventEmitter$7.usingDomains = false;

  EventEmitter$7.prototype.domain = undefined;
  EventEmitter$7.prototype._events = undefined;
  EventEmitter$7.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter$7.defaultMaxListeners = 10;

  EventEmitter$7.init = function() {
    this.domain = null;
    if (EventEmitter$7.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter$7.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter$7.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter$7.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };

  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      handler.call(self);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      handler.call(self, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      handler.call(self, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn)
      handler.apply(self, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self, args);
    }
  }

  EventEmitter$7.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = (type === 'error');

    events = this._events;
    if (events)
      doError = (doError && events.error == null);
    else if (!doError)
      return false;

    domain = this.domain;

    // If there is no 'error' event listener then throw.
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }

    handler = events[type];

    if (!handler)
      return false;

    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');

    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] :
                                            [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }

      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + type + ' listeners added. ' +
                              'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }
  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }
  EventEmitter$7.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter$7.prototype.on = EventEmitter$7.prototype.addListener;

  EventEmitter$7.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }

  EventEmitter$7.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter$7.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter$7.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');

        events = this._events;
        if (!events)
          return this;

        list = events[type];
        if (!list)
          return this;

        if (list === listener || (list.listener && list.listener === listener)) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length; i-- > 0;) {
            if (list[i] === listener ||
                (list[i].listener && list[i].listener === listener)) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (list.length === 1) {
            list[0] = undefined;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }

          if (events.removeListener)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };
      
  // Alias for removeListener added in NodeJS 10.0
  // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
  EventEmitter$7.prototype.off = function(type, listener){
      return this.removeListener(type, listener);
  };

  EventEmitter$7.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events;

        events = this._events;
        if (!events)
          return this;

        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          for (var i = 0, key; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          do {
            this.removeListener(type, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }

        return this;
      };

  EventEmitter$7.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;

    if (!events)
      ret = [];
    else {
      evlistener = events[type];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === 'function')
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }

    return ret;
  };

  EventEmitter$7.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount$1.call(emitter, type);
    }
  };

  EventEmitter$7.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter$7.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };

  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);
    while (i--)
      copy[i] = arr[i];
    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  var _polyfillNode_events = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EventEmitter: EventEmitter$7,
    default: EventEmitter$7
  });

  var require$$1$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

  var colors$1 = {};

  var codes$1 = {
      white: '\u000300',
      black: '\u000301',
      dark_blue: '\u000302',
      dark_green: '\u000303',
      light_red: '\u000304',
      dark_red: '\u000305',
      magenta: '\u000306',
      orange: '\u000307',
      yellow: '\u000308',
      light_green: '\u000309',
      cyan: '\u000310',
      light_cyan: '\u000311',
      light_blue: '\u000312',
      light_magenta: '\u000313',
      gray: '\u000314',
      light_gray: '\u000315',

      bold: '\u0002',
      underline: '\u001f',

      reset: '\u000f'
  };
  colors$1.codes = codes$1;

  function wrap(color, text, resetColor) {
      if (codes$1[color]) {
          text = codes$1[color] + text;
          text += (codes$1[resetColor]) ? codes$1[resetColor] : codes$1.reset;
      }
      return text;
  }
  colors$1.wrap = wrap;

  var ircColors$1 = {};

  (function (exports) {
  	const colors = {
  	  '00': ['white'],
  	  '01': ['black'],
  	  '02': ['navy'],
  	  '03': ['green'],
  	  '04': ['red'],
  	  '05': ['brown', 'maroon'],
  	  '06': ['purple', 'violet'],
  	  '07': ['olive'],
  	  '08': ['yellow'],
  	  '09': ['lightgreen', 'lime'],
  	  '10': ['teal', 'bluecyan'],
  	  '11': ['cyan', 'aqua'],
  	  '12': ['blue', 'royal'],
  	  '13': ['pink', 'lightpurple', 'fuchsia'],
  	  '14': ['gray', 'grey'],
  	  '15': ['lightgray', 'lightgrey', 'silver']
  	};

  	const styles = {
  	  normal        : '\x0F',
  	  underline     : '\x1F',
  	  bold          : '\x02',
  	  italic        : '\x1D',
  	  inverse       : '\x16',
  	  strikethrough : '\x1E',
  	  monospace     : '\x11',
  	};

  	const styleChars = {};
  	Object.keys(styles).forEach((key) => {
  	  styleChars[styles[key]] = true;
  	});


  	// Coloring character.
  	const c = '\x03';
  	const zero = styles.bold + styles.bold;
  	const badStr = /^,\d/;
  	const colorCodeStr = new RegExp(`^${c}\\d\\d`);

  	const allColors = {
  	  fg: [], bg: [], styles: Object.keys(styles), custom: [], extras: [],
  	};

  	// Make color functions for both foreground and background.
  	Object.keys(colors).forEach((code) => {
  	  // Foreground.
  	  // If the string begins with /,\d/,
  	  // it can undersirably apply a background color.
  	  let fg = str => c + code + (badStr.test(str) ? zero : '') + str + c;

  	  // Background.
  	  let bg = (str) => {
  	    // If the string begins with a foreground color already applied,
  	    // use it to save string space.
  	    if (colorCodeStr.test(str)) {
  	      let str2 = str.substr(3);
  	      return str.substr(0, 3) + ',' + code +
  	        (str2.indexOf(zero) === 0 ? str2.substr(zero.length) : str2);
  	    } else {
  	      return c + '01,' + code + str + c;
  	    }
  	  };

  	  colors[code].forEach((color) => {
  	    allColors.fg.push(color);
  	    allColors.bg.push('bg' + color);
  	    exports[color] = fg;
  	    exports['bg' + color] = bg;
  	  });
  	});

  	// Style functions.
  	Object.keys(styles).forEach((style) => {
  	  let code = styles[style];
  	  exports[style] = str => code + str + code;
  	});

  	// Some custom helpers.
  	const custom = {
  	  rainbow: (str, colorArr) => {
  	    let rainbow = [
  	      'red', 'olive', 'yellow', 'green', 'blue', 'navy', 'violet'
  	    ];
  	    colorArr = colorArr || rainbow;
  	    let l = colorArr.length;
  	    let i = 0;

  	    return str
  	      .split('')
  	      .map(c => c !== ' ' ? exports[colorArr[i++ % l]](c) : c)
  	      .join('');
  	  },
  	};

  	Object.keys(custom).forEach((extra) => {
  	  allColors.custom.push(extra);
  	  exports[extra] = custom[extra];
  	});

  	// Extras.
  	const extras = {
  	  stripColors: str => str.replace(/\x03\d{0,2}(,\d{0,2}|\x02\x02)?/g, ''),

  	  stripStyle: (str) => {
  	    let path = [];
  	    for (let i = 0, len = str.length; i < len; i++) {
  	      let char = str[i];
  	      if (styleChars[char] || char === c) {
  	        let lastChar = path[path.length - 1];
  	        if (lastChar && lastChar[0] === char) {
  	          let p0 = lastChar[1];
  	          // Don't strip out styles with no characters inbetween.
  	          // And don't strip out color codes.
  	          if (i - p0 > 1 && char !== c) {
  	            str = str.slice(0, p0) + str.slice(p0 + 1, i) + str.slice(i + 1);
  	            i -= 2;
  	          }
  	          path.pop();
  	        } else {
  	          path.push([str[i], i]);
  	        }
  	      }

  	    }

  	    // Remove any unmatching style characterss.
  	    // Traverse list backwards to make removing less complicated.
  	    for (let char of path.reverse()) {
  	      if (char[0] !== c) {
  	        let pos = char[1];
  	        str = str.slice(0, pos) + str.slice(pos + 1);
  	      }
  	    }
  	    return str;
  	  },

  	  stripColorsAndStyle: str => exports.stripColors(exports.stripStyle(str)),
  	};

  	Object.keys(extras).forEach((extra) => {
  	  allColors.extras.push(extra);
  	  exports[extra] = extras[extra];
  	});

  	// Adds all functions to each other so they can be chained.
  	const addGetters = (fn, types) => {
  	  Object.keys(allColors).forEach((type) => {
  	    if (types.indexOf(type) > -1) { return; }
  	    allColors[type].forEach((color) => {
  	      if (fn[color] != null) { return; }
  	      Object.defineProperty(fn, color, {
  	        get: () => {
  	          let f = str => exports[color](fn(str));
  	          addGetters(f, [].concat(types, type));
  	          return f;
  	        },
  	      });
  	    });
  	  });
  	};

  	Object.keys(allColors).forEach((type) => {
  	  allColors[type].forEach((color) => {
  	    addGetters(exports[color], [type]);
  	  });
  	});


  	// Adds functions to global String object.
  	exports.global = () => {
  	  let str, irc = {};

  	  String.prototype.__defineGetter__('irc', function() {
  	    str = this;
  	    return irc;
  	  });

  	  for (let type in allColors) {
  	    allColors[type].forEach((color) => {
  	      let fn = () => exports[color](str);
  	      addGetters(fn, [type]);
  	      irc[color] = fn;
  	    });
  	  }
  	}; 
  } (ircColors$1));

  var codes = {
      '001': {
          name: 'rpl_welcome',
          type: 'reply'
      },
      '002': {
          name: 'rpl_yourhost',
          type: 'reply'
      },
      '003': {
          name: 'rpl_created',
          type: 'reply'
      },
      '004': {
          name: 'rpl_myinfo',
          type: 'reply'
      },
      '005': {
          name: 'rpl_isupport',
          type: 'reply'
      },
      200: {
          name: 'rpl_tracelink',
          type: 'reply'
      },
      201: {
          name: 'rpl_traceconnecting',
          type: 'reply'
      },
      202: {
          name: 'rpl_tracehandshake',
          type: 'reply'
      },
      203: {
          name: 'rpl_traceunknown',
          type: 'reply'
      },
      204: {
          name: 'rpl_traceoperator',
          type: 'reply'
      },
      205: {
          name: 'rpl_traceuser',
          type: 'reply'
      },
      206: {
          name: 'rpl_traceserver',
          type: 'reply'
      },
      208: {
          name: 'rpl_tracenewtype',
          type: 'reply'
      },
      211: {
          name: 'rpl_statslinkinfo',
          type: 'reply'
      },
      212: {
          name: 'rpl_statscommands',
          type: 'reply'
      },
      213: {
          name: 'rpl_statscline',
          type: 'reply'
      },
      214: {
          name: 'rpl_statsnline',
          type: 'reply'
      },
      215: {
          name: 'rpl_statsiline',
          type: 'reply'
      },
      216: {
          name: 'rpl_statskline',
          type: 'reply'
      },
      218: {
          name: 'rpl_statsyline',
          type: 'reply'
      },
      219: {
          name: 'rpl_endofstats',
          type: 'reply'
      },
      221: {
          name: 'rpl_umodeis',
          type: 'reply'
      },
      241: {
          name: 'rpl_statslline',
          type: 'reply'
      },
      242: {
          name: 'rpl_statsuptime',
          type: 'reply'
      },
      243: {
          name: 'rpl_statsoline',
          type: 'reply'
      },
      244: {
          name: 'rpl_statshline',
          type: 'reply'
      },
      250: {
          name: 'rpl_statsconn',
          type: 'reply'
      },
      251: {
          name: 'rpl_luserclient',
          type: 'reply'
      },
      252: {
          name: 'rpl_luserop',
          type: 'reply'
      },
      253: {
          name: 'rpl_luserunknown',
          type: 'reply'
      },
      254: {
          name: 'rpl_luserchannels',
          type: 'reply'
      },
      255: {
          name: 'rpl_luserme',
          type: 'reply'
      },
      256: {
          name: 'rpl_adminme',
          type: 'reply'
      },
      257: {
          name: 'rpl_adminloc1',
          type: 'reply'
      },
      258: {
          name: 'rpl_adminloc2',
          type: 'reply'
      },
      259: {
          name: 'rpl_adminemail',
          type: 'reply'
      },
      261: {
          name: 'rpl_tracelog',
          type: 'reply'
      },
      265: {
          name: 'rpl_localusers',
          type: 'reply'
      },
      266: {
          name: 'rpl_globalusers',
          type: 'reply'
      },
      300: {
          name: 'rpl_none',
          type: 'reply'
      },
      301: {
          name: 'rpl_away',
          type: 'reply'
      },
      302: {
          name: 'rpl_userhost',
          type: 'reply'
      },
      303: {
          name: 'rpl_ison',
          type: 'reply'
      },
      305: {
          name: 'rpl_unaway',
          type: 'reply'
      },
      306: {
          name: 'rpl_nowaway',
          type: 'reply'
      },
      307: {
          type: 'reply'
      },
      311: {
          name: 'rpl_whoisuser',
          type: 'reply'
      },
      312: {
          name: 'rpl_whoisserver',
          type: 'reply'
      },
      313: {
          name: 'rpl_whoisoperator',
          type: 'reply'
      },
      314: {
          name: 'rpl_whowasuser',
          type: 'reply'
      },
      315: {
          name: 'rpl_endofwho',
          type: 'reply'
      },
      317: {
          name: 'rpl_whoisidle',
          type: 'reply'
      },
      318: {
          name: 'rpl_endofwhois',
          type: 'reply'
      },
      319: {
          name: 'rpl_whoischannels',
          type: 'reply'
      },
      321: {
          name: 'rpl_liststart',
          type: 'reply'
      },
      322: {
          name: 'rpl_list',
          type: 'reply'
      },
      323: {
          name: 'rpl_listend',
          type: 'reply'
      },
      324: {
          name: 'rpl_channelmodeis',
          type: 'reply'
      },
      329: {
          name: 'rpl_creationtime',
          type: 'reply'
      },
      331: {
          name: 'rpl_notopic',
          type: 'reply'
      },
      332: {
          name: 'rpl_topic',
          type: 'reply'
      },
      333: {
          name: 'rpl_topicwhotime',
          type: 'reply'
      },
      335: {
          name: 'rpl_whoisbot',
          type: 'reply'
      },
      341: {
          name: 'rpl_inviting',
          type: 'reply'
      },
      342: {
          name: 'rpl_summoning',
          type: 'reply'
      },
      351: {
          name: 'rpl_version',
          type: 'reply'
      },
      352: {
          name: 'rpl_whoreply',
          type: 'reply'
      },
      353: {
          name: 'rpl_namreply',
          type: 'reply'
      },
      364: {
          name: 'rpl_links',
          type: 'reply'
      },
      365: {
          name: 'rpl_endoflinks',
          type: 'reply'
      },
      366: {
          name: 'rpl_endofnames',
          type: 'reply'
      },
      367: {
          name: 'rpl_banlist',
          type: 'reply'
      },
      368: {
          name: 'rpl_endofbanlist',
          type: 'reply'
      },
      369: {
          name: 'rpl_endofwhowas',
          type: 'reply'
      },
      371: {
          name: 'rpl_info',
          type: 'reply'
      },
      372: {
          name: 'rpl_motd',
          type: 'reply'
      },
      374: {
          name: 'rpl_endofinfo',
          type: 'reply'
      },
      375: {
          name: 'rpl_motdstart',
          type: 'reply'
      },
      376: {
          name: 'rpl_endofmotd',
          type: 'reply'
      },
      378: {
          name: 'rpl_whoishost',
          type: 'reply'
      },
      379: {
          name: 'rpl_whoismodes',
          type: 'reply'
      },
      381: {
          name: 'rpl_youreoper',
          type: 'reply'
      },
      382: {
          name: 'rpl_rehashing',
          type: 'reply'
      },
      391: {
          name: 'rpl_time',
          type: 'reply'
      },
      392: {
          name: 'rpl_usersstart',
          type: 'reply'
      },
      393: {
          name: 'rpl_users',
          type: 'reply'
      },
      394: {
          name: 'rpl_endofusers',
          type: 'reply'
      },
      395: {
          name: 'rpl_nousers',
          type: 'reply'
      },
      401: {
          name: 'err_nosuchnick',
          type: 'error'
      },
      402: {
          name: 'err_nosuchserver',
          type: 'error'
      },
      403: {
          name: 'err_nosuchchannel',
          type: 'error'
      },
      404: {
          name: 'err_cannotsendtochan',
          type: 'error'
      },
      405: {
          name: 'err_toomanychannels',
          type: 'error'
      },
      406: {
          name: 'err_wasnosuchnick',
          type: 'error'
      },
      407: {
          name: 'err_toomanytargets',
          type: 'error'
      },
      409: {
          name: 'err_noorigin',
          type: 'error'
      },
      411: {
          name: 'err_norecipient',
          type: 'error'
      },
      412: {
          name: 'err_notexttosend',
          type: 'error'
      },
      413: {
          name: 'err_notoplevel',
          type: 'error'
      },
      414: {
          name: 'err_wildtoplevel',
          type: 'error'
      },
      421: {
          name: 'err_unknowncommand',
          type: 'error'
      },
      422: {
          name: 'err_nomotd',
          type: 'error'
      },
      423: {
          name: 'err_noadmininfo',
          type: 'error'
      },
      424: {
          name: 'err_fileerror',
          type: 'error'
      },
      431: {
          name: 'err_nonicknamegiven',
          type: 'error'
      },
      432: {
          name: 'err_erroneusnickname',
          type: 'error'
      },
      433: {
          name: 'err_nicknameinuse',
          type: 'error'
      },
      436: {
          name: 'err_nickcollision',
          type: 'error'
      },
      441: {
          name: 'err_usernotinchannel',
          type: 'error'
      },
      442: {
          name: 'err_notonchannel',
          type: 'error'
      },
      443: {
          name: 'err_useronchannel',
          type: 'error'
      },
      444: {
          name: 'err_nologin',
          type: 'error'
      },
      445: {
          name: 'err_summondisabled',
          type: 'error'
      },
      446: {
          name: 'err_usersdisabled',
          type: 'error'
      },
      451: {
          name: 'err_notregistered',
          type: 'error'
      },
      461: {
          name: 'err_needmoreparams',
          type: 'error'
      },
      462: {
          name: 'err_alreadyregistred',
          type: 'error'
      },
      463: {
          name: 'err_nopermforhost',
          type: 'error'
      },
      464: {
          name: 'err_passwdmismatch',
          type: 'error'
      },
      465: {
          name: 'err_yourebannedcreep',
          type: 'error'
      },
      467: {
          name: 'err_keyset',
          type: 'error'
      },
      471: {
          name: 'err_channelisfull',
          type: 'error'
      },
      472: {
          name: 'err_unknownmode',
          type: 'error'
      },
      473: {
          name: 'err_inviteonlychan',
          type: 'error'
      },
      474: {
          name: 'err_bannedfromchan',
          type: 'error'
      },
      475: {
          name: 'err_badchannelkey',
          type: 'error'
      },
      477: {
          type: 'error'
      },
      481: {
          name: 'err_noprivileges',
          type: 'error'
      },
      482: {
          name: 'err_chanoprivsneeded',
          type: 'error'
      },
      483: {
          name: 'err_cantkillserver',
          type: 'error'
      },
      491: {
          name: 'err_nooperhost',
          type: 'error'
      },
      501: {
          name: 'err_umodeunknownflag',
          type: 'error'
      },
      502: {
          name: 'err_usersdontmatch',
          type: 'error'
      },
      671: {
          name: 'rpl_whoissecure',
          type: 'reply'
      },
      900: {
          name: 'rpl_loggedin',
          type: 'reply'
      },
      901: {
          name: 'rpl_loggedout',
          type: 'reply'
      },
      902: {
          name: 'err_nicklocked',
          type: 'error'
      },
      903: {
          name: 'rpl_saslsuccess',
          type: 'reply'
      },
      904: {
          name: 'err_saslfail',
          type: 'error'
      },
      905: {
          name: 'err_sasltoolong',
          type: 'error'
      },
      906: {
          name: 'err_saslaborted',
          type: 'error'
      },
      907: {
          name: 'err_saslalready',
          type: 'error'
      },
      908: {
          name: 'rpl_saslmechs',
          type: 'reply'
      }
  };

  var ircColors = ircColors$1;
  var replyFor = codes;

  /**
   * parseMessage(line, stripColors)
   *
   * takes a raw "line" from the IRC server and turns it into an object with
   * useful keys
   * @param {String} line Raw message from IRC server.
   * @param {Boolean} stripColors If true, strip IRC colors.
   * @param {Boolean} enableStrictParse If true, will try to conform to RFC2812 strictly for parsing usernames (and disallow eg CJK characters).
   * @return {Object} A parsed message object.
   */
  var parse_message = function parseMessage(line, stripColors, enableStrictParse) {
      var message = {};
      var match;

      if (stripColors) {
          line = ircColors.stripColorsAndStyle(line);
      }

      // Parse prefix
      match = line.match(/^:([^ ]+) +/);
      if (match) {
          message.prefix = match[1];
          line = line.replace(/^:[^ ]+ +/, '');
          if (enableStrictParse) {
              match = message.prefix.match(/^([_a-zA-Z0-9~[\]\\`^{}|-]*)(!([^@]+)@(.*))?$/);
          } else {
              match = message.prefix.match(/^([\u1100-\u11FF\u3040-\u309fF\u30A0-\u30FF\u3130-\u318F\u31F0-\u31FF\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF_a-zA-Z0-9~[\]\\/?`^{}|-]*)(!([^@]+)@(.*))?$/);
          }
          if (match) {
              message.nick = match[1];
              message.user = match[3];
              message.host = match[4];
          }
          else {
              message.server = message.prefix;
          }
      }

      // Parse command
      match = line.match(/^([^ ]+) */);
      message.command = match[1];
      message.rawCommand = match[1];
      message.commandType = 'normal';
      line = line.replace(/^[^ ]+ +/, '');

      var codeData = replyFor[message.rawCommand];
      if (codeData) {
          if ('name' in codeData) message.command = codeData.name;
          message.commandType = codeData.type;
      }

      message.args = [];
      var middle, trailing;

      // Parse parameters
      if (line.search(/^:|\s+:/) !== -1) {
          match = line.match(/(.*?)(?:^:|\s+:)(.*)/);
          middle = match[1].trimRight();
          trailing = match[2];
      }
      else {
          middle = line;
      }

      if (middle.length)
          message.args = middle.split(/ +/);

      if (typeof trailing !== 'undefined' && trailing.length)
          message.args.push(trailing);

      return message;
  };

  var util$2 = require$$2$1;
  var EventEmitter$6 = require$$1$2;

  /**
   * This class encapsulates the ping timeout functionality.
   * When enough silence (lack of server-sent activity) passes, an object of this type will emit a 'wantPing' event, indicating you should send a PING message to the server in order to get some signs of life from it.
   * If enough time passes after that (i.e. server does not respond to PING), then an object of this type will emit a 'pingTimeout' event.
   *
   * To start the gears turning, call start() on an instance of this class to put it in the 'started' state.
   *
   * When server-side activity occurs, call notifyOfActivity() on the object.
   *
   * When a pingTimeout occurs, the object will go into the 'stopped' state.
   */
  var ctr = 0;

  function CyclingPingTimer$1(client) {
      var self = this;
      self.timerNumber = ctr++;
      self.started = false;

      // Only one of these two should be non-null at any given time.
      self.loopingTimeout = null;
      self.pingWaitTimeout = null;

      // conditionally log debug messages
      function debug(msg) {
          client.out.debug('CyclingPingTimer ' + self.timerNumber + ':', msg);
      }

      // set up EventEmitter functionality
      EventEmitter$6.call(self);

      self.on('wantPing', function() {
          debug('server silent for too long, let\'s send a PING');
          self.pingWaitTimeout = setTimeout(function() {
              self.stop();
              debug('ping timeout!');
              self.emit('pingTimeout');
          }, client.opt.millisecondsBeforePingTimeout);
      });

      self.notifyOfActivity = function() {
          if (self.started) {
              _stop();
              _start();
          }
      };

      self.stop = function() {
          if (!self.started) {
              return;
          }
          debug('ping timer stopped');
          _stop();
      };
      function _stop() {
          self.started = false;

          clearTimeout(self.loopingTimeout);
          clearTimeout(self.pingWaitTimeout);

          self.loopingTimeout = null;
          self.pingWaitTimeout = null;
      }

      self.start = function() {
          if (self.started) {
              debug('can\'t start, not stopped!');
              return;
          }
          debug('ping timer started');
          _start();
      };
      function _start() {
          self.started = true;

          self.loopingTimeout = setTimeout(function() {
              self.loopingTimeout = null;
              self.emit('wantPing');
          }, client.opt.millisecondsOfSilenceBeforePingSent);
      }
  }

  util$2.inherits(CyclingPingTimer$1, EventEmitter$6);

  var cycling_ping_timer = CyclingPingTimer$1;

  var lib$1 = {exports: {}};

  var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_buffer);

  var safer_1;
  var hasRequiredSafer;

  function requireSafer () {
  	if (hasRequiredSafer) return safer_1;
  	hasRequiredSafer = 1;

  	var buffer = require$$0$1;
  	var Buffer = buffer.Buffer;

  	var safer = {};

  	var key;

  	for (key in buffer) {
  	  if (!buffer.hasOwnProperty(key)) continue
  	  if (key === 'SlowBuffer' || key === 'Buffer') continue
  	  safer[key] = buffer[key];
  	}

  	var Safer = safer.Buffer = {};
  	for (key in Buffer) {
  	  if (!Buffer.hasOwnProperty(key)) continue
  	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  	  Safer[key] = Buffer[key];
  	}

  	safer.Buffer.prototype = Buffer.prototype;

  	if (!Safer.from || Safer.from === Uint8Array.from) {
  	  Safer.from = function (value, encodingOrOffset, length) {
  	    if (typeof value === 'number') {
  	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
  	    }
  	    if (value && typeof value.length === 'undefined') {
  	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
  	    }
  	    return Buffer(value, encodingOrOffset, length)
  	  };
  	}

  	if (!Safer.alloc) {
  	  Safer.alloc = function (size, fill, encoding) {
  	    if (typeof size !== 'number') {
  	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
  	    }
  	    if (size < 0 || size >= 2 * (1 << 30)) {
  	      throw new RangeError('The value "' + size + '" is invalid for option "size"')
  	    }
  	    var buf = Buffer(size);
  	    if (!fill || fill.length === 0) {
  	      buf.fill(0);
  	    } else if (typeof encoding === 'string') {
  	      buf.fill(fill, encoding);
  	    } else {
  	      buf.fill(fill);
  	    }
  	    return buf
  	  };
  	}

  	if (!safer.kStringMaxLength) {
  	  try {
  	    safer.kStringMaxLength = browser$1$1.binding('buffer').kStringMaxLength;
  	  } catch (e) {
  	    // we can't determine kStringMaxLength in environments where process.binding
  	    // is unsupported, so let's not set it
  	  }
  	}

  	if (!safer.constants) {
  	  safer.constants = {
  	    MAX_LENGTH: safer.kMaxLength
  	  };
  	  if (safer.kStringMaxLength) {
  	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  	  }
  	}

  	safer_1 = safer;
  	return safer_1;
  }

  var bomHandling = {};

  var hasRequiredBomHandling;

  function requireBomHandling () {
  	if (hasRequiredBomHandling) return bomHandling;
  	hasRequiredBomHandling = 1;

  	var BOMChar = '\uFEFF';

  	bomHandling.PrependBOM = PrependBOMWrapper;
  	function PrependBOMWrapper(encoder, options) {
  	    this.encoder = encoder;
  	    this.addBOM = true;
  	}

  	PrependBOMWrapper.prototype.write = function(str) {
  	    if (this.addBOM) {
  	        str = BOMChar + str;
  	        this.addBOM = false;
  	    }

  	    return this.encoder.write(str);
  	};

  	PrependBOMWrapper.prototype.end = function() {
  	    return this.encoder.end();
  	};


  	//------------------------------------------------------------------------------

  	bomHandling.StripBOM = StripBOMWrapper;
  	function StripBOMWrapper(decoder, options) {
  	    this.decoder = decoder;
  	    this.pass = false;
  	    this.options = options || {};
  	}

  	StripBOMWrapper.prototype.write = function(buf) {
  	    var res = this.decoder.write(buf);
  	    if (this.pass || !res)
  	        return res;

  	    if (res[0] === BOMChar) {
  	        res = res.slice(1);
  	        if (typeof this.options.stripBOM === 'function')
  	            this.options.stripBOM();
  	    }

  	    this.pass = true;
  	    return res;
  	};

  	StripBOMWrapper.prototype.end = function() {
  	    return this.decoder.end();
  	};
  	return bomHandling;
  }

  var encodings = {};

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var isBufferEncoding = Buffer.isEncoding
    || function(encoding) {
         switch (encoding && encoding.toLowerCase()) {
           case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
           default: return false;
         }
       };


  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error('Unknown encoding: ' + encoding);
    }
  }

  // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters. CESU-8 is handled as part of the UTF-8 encoding.
  //
  // @TODO Handling all encodings inside a single object makes it very difficult
  // to reason about this code, so it should be split up in the future.
  // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
  // points as used by CESU-8.
  function StringDecoder(encoding) {
    this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
    assertEncoding(encoding);
    switch (this.encoding) {
      case 'utf8':
        // CESU-8 represents each of Surrogate Pair by 3-bytes
        this.surrogateSize = 3;
        break;
      case 'ucs2':
      case 'utf16le':
        // UTF-16 represents each of Surrogate Pair by 2-bytes
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case 'base64':
        // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }

    // Enough space to store all bytes of a single character. UTF-8 needs 4
    // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
    this.charBuffer = new Buffer(6);
    // Number of bytes received for the current incomplete multi-byte character.
    this.charReceived = 0;
    // Number of bytes expected for the current incomplete multi-byte character.
    this.charLength = 0;
  }

  // write decodes the given buffer and returns it as JS string that is
  // guaranteed to not contain any partial multi-byte characters. Any partial
  // character found at the end of the buffer is buffered up, and will be
  // returned when calling write again with the remaining bytes.
  //
  // Note: Converting a Buffer containing an orphan surrogate to a String
  // currently works, but converting a String to a Buffer (via `new Buffer`, or
  // Buffer#write) will replace incomplete surrogates with the unicode
  // replacement character. See https://codereview.chromium.org/121173009/ .
  StringDecoder.prototype.write = function(buffer) {
    var charStr = '';
    // if our last write ended with an incomplete multibyte character
    while (this.charLength) {
      // determine how many remaining bytes this buffer has to offer for this char
      var available = (buffer.length >= this.charLength - this.charReceived) ?
          this.charLength - this.charReceived :
          buffer.length;

      // add the new bytes to the char buffer
      buffer.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;

      if (this.charReceived < this.charLength) {
        // still not enough chars in this buffer? wait for more ...
        return '';
      }

      // remove bytes belonging to the current character from the buffer
      buffer = buffer.slice(available, buffer.length);

      // get the character that was split
      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      var charCode = charStr.charCodeAt(charStr.length - 1);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        this.charLength += this.surrogateSize;
        charStr = '';
        continue;
      }
      this.charReceived = this.charLength = 0;

      // if there are no more bytes in this buffer, just emit our char
      if (buffer.length === 0) {
        return charStr;
      }
      break;
    }

    // determine and set charLength / charReceived
    this.detectIncompleteChar(buffer);

    var end = buffer.length;
    if (this.charLength) {
      // buffer the incomplete character bytes we got
      buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
      end -= this.charReceived;
    }

    charStr += buffer.toString(this.encoding, 0, end);

    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    }

    // or just emit the charStr
    return charStr;
  };

  // detectIncompleteChar determines if there is an incomplete UTF-8 character at
  // the end of the given buffer. If so, it sets this.charLength to the byte
  // length that character, and sets this.charReceived to the number of bytes
  // that are available for this character.
  StringDecoder.prototype.detectIncompleteChar = function(buffer) {
    // determine how many bytes we have to check at the end of this buffer
    var i = (buffer.length >= 3) ? 3 : buffer.length;

    // Figure out if one of the last i bytes of our buffer announces an
    // incomplete char.
    for (; i > 0; i--) {
      var c = buffer[buffer.length - i];

      // See http://en.wikipedia.org/wiki/UTF-8#Description

      // 110XXXXX
      if (i == 1 && c >> 5 == 0x06) {
        this.charLength = 2;
        break;
      }

      // 1110XXXX
      if (i <= 2 && c >> 4 == 0x0E) {
        this.charLength = 3;
        break;
      }

      // 11110XXX
      if (i <= 3 && c >> 3 == 0x1E) {
        this.charLength = 4;
        break;
      }
    }
    this.charReceived = i;
  };

  StringDecoder.prototype.end = function(buffer) {
    var res = '';
    if (buffer && buffer.length)
      res = this.write(buffer);

    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }

    return res;
  };

  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }

  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }

  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }

  var _polyfillNode_string_decoder = /*#__PURE__*/Object.freeze({
    __proto__: null,
    StringDecoder: StringDecoder
  });

  var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_string_decoder);

  var internal;
  var hasRequiredInternal;

  function requireInternal () {
  	if (hasRequiredInternal) return internal;
  	hasRequiredInternal = 1;
  	var Buffer = requireSafer().Buffer;

  	// Export Node.js internal encodings.

  	internal = {
  	    // Encodings
  	    utf8:   { type: "_internal", bomAware: true},
  	    cesu8:  { type: "_internal", bomAware: true},
  	    unicode11utf8: "utf8",

  	    ucs2:   { type: "_internal", bomAware: true},
  	    utf16le: "ucs2",

  	    binary: { type: "_internal" },
  	    base64: { type: "_internal" },
  	    hex:    { type: "_internal" },

  	    // Codec.
  	    _internal: InternalCodec,
  	};

  	//------------------------------------------------------------------------------

  	function InternalCodec(codecOptions, iconv) {
  	    this.enc = codecOptions.encodingName;
  	    this.bomAware = codecOptions.bomAware;

  	    if (this.enc === "base64")
  	        this.encoder = InternalEncoderBase64;
  	    else if (this.enc === "cesu8") {
  	        this.enc = "utf8"; // Use utf8 for decoding.
  	        this.encoder = InternalEncoderCesu8;

  	        // Add decoder for versions of Node not supporting CESU-8
  	        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
  	            this.decoder = InternalDecoderCesu8;
  	            this.defaultCharUnicode = iconv.defaultCharUnicode;
  	        }
  	    }
  	}

  	InternalCodec.prototype.encoder = InternalEncoder;
  	InternalCodec.prototype.decoder = InternalDecoder;

  	//------------------------------------------------------------------------------

  	// We use node.js internal decoder. Its signature is the same as ours.
  	var StringDecoder = require$$1$1.StringDecoder;

  	if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
  	    StringDecoder.prototype.end = function() {};


  	function InternalDecoder(options, codec) {
  	    this.decoder = new StringDecoder(codec.enc);
  	}

  	InternalDecoder.prototype.write = function(buf) {
  	    if (!Buffer.isBuffer(buf)) {
  	        buf = Buffer.from(buf);
  	    }

  	    return this.decoder.write(buf);
  	};

  	InternalDecoder.prototype.end = function() {
  	    return this.decoder.end();
  	};


  	//------------------------------------------------------------------------------
  	// Encoder is mostly trivial

  	function InternalEncoder(options, codec) {
  	    this.enc = codec.enc;
  	}

  	InternalEncoder.prototype.write = function(str) {
  	    return Buffer.from(str, this.enc);
  	};

  	InternalEncoder.prototype.end = function() {
  	};


  	//------------------------------------------------------------------------------
  	// Except base64 encoder, which must keep its state.

  	function InternalEncoderBase64(options, codec) {
  	    this.prevStr = '';
  	}

  	InternalEncoderBase64.prototype.write = function(str) {
  	    str = this.prevStr + str;
  	    var completeQuads = str.length - (str.length % 4);
  	    this.prevStr = str.slice(completeQuads);
  	    str = str.slice(0, completeQuads);

  	    return Buffer.from(str, "base64");
  	};

  	InternalEncoderBase64.prototype.end = function() {
  	    return Buffer.from(this.prevStr, "base64");
  	};


  	//------------------------------------------------------------------------------
  	// CESU-8 encoder is also special.

  	function InternalEncoderCesu8(options, codec) {
  	}

  	InternalEncoderCesu8.prototype.write = function(str) {
  	    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
  	    for (var i = 0; i < str.length; i++) {
  	        var charCode = str.charCodeAt(i);
  	        // Naive implementation, but it works because CESU-8 is especially easy
  	        // to convert from UTF-16 (which all JS strings are encoded in).
  	        if (charCode < 0x80)
  	            buf[bufIdx++] = charCode;
  	        else if (charCode < 0x800) {
  	            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
  	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
  	        }
  	        else { // charCode will always be < 0x10000 in javascript.
  	            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
  	            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
  	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
  	        }
  	    }
  	    return buf.slice(0, bufIdx);
  	};

  	InternalEncoderCesu8.prototype.end = function() {
  	};

  	//------------------------------------------------------------------------------
  	// CESU-8 decoder is not implemented in Node v4.0+

  	function InternalDecoderCesu8(options, codec) {
  	    this.acc = 0;
  	    this.contBytes = 0;
  	    this.accBytes = 0;
  	    this.defaultCharUnicode = codec.defaultCharUnicode;
  	}

  	InternalDecoderCesu8.prototype.write = function(buf) {
  	    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
  	        res = '';
  	    for (var i = 0; i < buf.length; i++) {
  	        var curByte = buf[i];
  	        if ((curByte & 0xC0) !== 0x80) { // Leading byte
  	            if (contBytes > 0) { // Previous code is invalid
  	                res += this.defaultCharUnicode;
  	                contBytes = 0;
  	            }

  	            if (curByte < 0x80) { // Single-byte code
  	                res += String.fromCharCode(curByte);
  	            } else if (curByte < 0xE0) { // Two-byte code
  	                acc = curByte & 0x1F;
  	                contBytes = 1; accBytes = 1;
  	            } else if (curByte < 0xF0) { // Three-byte code
  	                acc = curByte & 0x0F;
  	                contBytes = 2; accBytes = 1;
  	            } else { // Four or more are not supported for CESU-8.
  	                res += this.defaultCharUnicode;
  	            }
  	        } else { // Continuation byte
  	            if (contBytes > 0) { // We're waiting for it.
  	                acc = (acc << 6) | (curByte & 0x3f);
  	                contBytes--; accBytes++;
  	                if (contBytes === 0) {
  	                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
  	                    if (accBytes === 2 && acc < 0x80 && acc > 0)
  	                        res += this.defaultCharUnicode;
  	                    else if (accBytes === 3 && acc < 0x800)
  	                        res += this.defaultCharUnicode;
  	                    else
  	                        // Actually add character.
  	                        res += String.fromCharCode(acc);
  	                }
  	            } else { // Unexpected continuation byte
  	                res += this.defaultCharUnicode;
  	            }
  	        }
  	    }
  	    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
  	    return res;
  	};

  	InternalDecoderCesu8.prototype.end = function() {
  	    var res = 0;
  	    if (this.contBytes > 0)
  	        res += this.defaultCharUnicode;
  	    return res;
  	};
  	return internal;
  }

  var utf32 = {};

  var hasRequiredUtf32;

  function requireUtf32 () {
  	if (hasRequiredUtf32) return utf32;
  	hasRequiredUtf32 = 1;

  	var Buffer = requireSafer().Buffer;

  	// == UTF32-LE/BE codec. ==========================================================

  	utf32._utf32 = Utf32Codec;

  	function Utf32Codec(codecOptions, iconv) {
  	    this.iconv = iconv;
  	    this.bomAware = true;
  	    this.isLE = codecOptions.isLE;
  	}

  	utf32.utf32le = { type: '_utf32', isLE: true };
  	utf32.utf32be = { type: '_utf32', isLE: false };

  	// Aliases
  	utf32.ucs4le = 'utf32le';
  	utf32.ucs4be = 'utf32be';

  	Utf32Codec.prototype.encoder = Utf32Encoder;
  	Utf32Codec.prototype.decoder = Utf32Decoder;

  	// -- Encoding

  	function Utf32Encoder(options, codec) {
  	    this.isLE = codec.isLE;
  	    this.highSurrogate = 0;
  	}

  	Utf32Encoder.prototype.write = function(str) {
  	    var src = Buffer.from(str, 'ucs2');
  	    var dst = Buffer.alloc(src.length * 2);
  	    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
  	    var offset = 0;

  	    for (var i = 0; i < src.length; i += 2) {
  	        var code = src.readUInt16LE(i);
  	        var isHighSurrogate = (0xD800 <= code && code < 0xDC00);
  	        var isLowSurrogate = (0xDC00 <= code && code < 0xE000);

  	        if (this.highSurrogate) {
  	            if (isHighSurrogate || !isLowSurrogate) {
  	                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
  	                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
  	                // (technically wrong, but expected by some applications, like Windows file names).
  	                write32.call(dst, this.highSurrogate, offset);
  	                offset += 4;
  	            }
  	            else {
  	                // Create 32-bit value from high and low surrogates;
  	                var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;

  	                write32.call(dst, codepoint, offset);
  	                offset += 4;
  	                this.highSurrogate = 0;

  	                continue;
  	            }
  	        }

  	        if (isHighSurrogate)
  	            this.highSurrogate = code;
  	        else {
  	            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
  	            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
  	            // unpaired high surrogates.
  	            write32.call(dst, code, offset);
  	            offset += 4;
  	            this.highSurrogate = 0;
  	        }
  	    }

  	    if (offset < dst.length)
  	        dst = dst.slice(0, offset);

  	    return dst;
  	};

  	Utf32Encoder.prototype.end = function() {
  	    // Treat any leftover high surrogate as a semi-valid independent character.
  	    if (!this.highSurrogate)
  	        return;

  	    var buf = Buffer.alloc(4);

  	    if (this.isLE)
  	        buf.writeUInt32LE(this.highSurrogate, 0);
  	    else
  	        buf.writeUInt32BE(this.highSurrogate, 0);

  	    this.highSurrogate = 0;

  	    return buf;
  	};

  	// -- Decoding

  	function Utf32Decoder(options, codec) {
  	    this.isLE = codec.isLE;
  	    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
  	    this.overflow = [];
  	}

  	Utf32Decoder.prototype.write = function(src) {
  	    if (src.length === 0)
  	        return '';

  	    var i = 0;
  	    var codepoint = 0;
  	    var dst = Buffer.alloc(src.length + 4);
  	    var offset = 0;
  	    var isLE = this.isLE;
  	    var overflow = this.overflow;
  	    var badChar = this.badChar;

  	    if (overflow.length > 0) {
  	        for (; i < src.length && overflow.length < 4; i++)
  	            overflow.push(src[i]);
  	        
  	        if (overflow.length === 4) {
  	            // NOTE: codepoint is a signed int32 and can be negative.
  	            // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
  	            if (isLE) {
  	                codepoint = overflow[i] | (overflow[i+1] << 8) | (overflow[i+2] << 16) | (overflow[i+3] << 24);
  	            } else {
  	                codepoint = overflow[i+3] | (overflow[i+2] << 8) | (overflow[i+1] << 16) | (overflow[i] << 24);
  	            }
  	            overflow.length = 0;

  	            offset = _writeCodepoint(dst, offset, codepoint, badChar);
  	        }
  	    }

  	    // Main loop. Should be as optimized as possible.
  	    for (; i < src.length - 3; i += 4) {
  	        // NOTE: codepoint is a signed int32 and can be negative.
  	        if (isLE) {
  	            codepoint = src[i] | (src[i+1] << 8) | (src[i+2] << 16) | (src[i+3] << 24);
  	        } else {
  	            codepoint = src[i+3] | (src[i+2] << 8) | (src[i+1] << 16) | (src[i] << 24);
  	        }
  	        offset = _writeCodepoint(dst, offset, codepoint, badChar);
  	    }

  	    // Keep overflowing bytes.
  	    for (; i < src.length; i++) {
  	        overflow.push(src[i]);
  	    }

  	    return dst.slice(0, offset).toString('ucs2');
  	};

  	function _writeCodepoint(dst, offset, codepoint, badChar) {
  	    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
  	    if (codepoint < 0 || codepoint > 0x10FFFF) {
  	        // Not a valid Unicode codepoint
  	        codepoint = badChar;
  	    } 

  	    // Ephemeral Planes: Write high surrogate.
  	    if (codepoint >= 0x10000) {
  	        codepoint -= 0x10000;

  	        var high = 0xD800 | (codepoint >> 10);
  	        dst[offset++] = high & 0xff;
  	        dst[offset++] = high >> 8;

  	        // Low surrogate is written below.
  	        var codepoint = 0xDC00 | (codepoint & 0x3FF);
  	    }

  	    // Write BMP char or low surrogate.
  	    dst[offset++] = codepoint & 0xff;
  	    dst[offset++] = codepoint >> 8;

  	    return offset;
  	}
  	Utf32Decoder.prototype.end = function() {
  	    this.overflow.length = 0;
  	};

  	// == UTF-32 Auto codec =============================================================
  	// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
  	// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
  	// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

  	// Encoder prepends BOM (which can be overridden with (addBOM: false}).

  	utf32.utf32 = Utf32AutoCodec;
  	utf32.ucs4 = 'utf32';

  	function Utf32AutoCodec(options, iconv) {
  	    this.iconv = iconv;
  	}

  	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

  	// -- Encoding

  	function Utf32AutoEncoder(options, codec) {
  	    options = options || {};

  	    if (options.addBOM === undefined)
  	        options.addBOM = true;

  	    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
  	}

  	Utf32AutoEncoder.prototype.write = function(str) {
  	    return this.encoder.write(str);
  	};

  	Utf32AutoEncoder.prototype.end = function() {
  	    return this.encoder.end();
  	};

  	// -- Decoding

  	function Utf32AutoDecoder(options, codec) {
  	    this.decoder = null;
  	    this.initialBufs = [];
  	    this.initialBufsLen = 0;
  	    this.options = options || {};
  	    this.iconv = codec.iconv;
  	}

  	Utf32AutoDecoder.prototype.write = function(buf) {
  	    if (!this.decoder) { 
  	        // Codec is not chosen yet. Accumulate initial bytes.
  	        this.initialBufs.push(buf);
  	        this.initialBufsLen += buf.length;

  	        if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)
  	            return '';

  	        // We have enough bytes -> detect endianness.
  	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
  	        this.decoder = this.iconv.getDecoder(encoding, this.options);

  	        var resStr = '';
  	        for (var i = 0; i < this.initialBufs.length; i++)
  	            resStr += this.decoder.write(this.initialBufs[i]);

  	        this.initialBufs.length = this.initialBufsLen = 0;
  	        return resStr;
  	    }

  	    return this.decoder.write(buf);
  	};

  	Utf32AutoDecoder.prototype.end = function() {
  	    if (!this.decoder) {
  	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
  	        this.decoder = this.iconv.getDecoder(encoding, this.options);

  	        var resStr = '';
  	        for (var i = 0; i < this.initialBufs.length; i++)
  	            resStr += this.decoder.write(this.initialBufs[i]);

  	        var trail = this.decoder.end();
  	        if (trail)
  	            resStr += trail;

  	        this.initialBufs.length = this.initialBufsLen = 0;
  	        return resStr;
  	    }

  	    return this.decoder.end();
  	};

  	function detectEncoding(bufs, defaultEncoding) {
  	    var b = [];
  	    var charsProcessed = 0;
  	    var invalidLE = 0, invalidBE = 0;   // Number of invalid chars when decoded as LE or BE.
  	    var bmpCharsLE = 0, bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

  	    outer_loop:
  	    for (var i = 0; i < bufs.length; i++) {
  	        var buf = bufs[i];
  	        for (var j = 0; j < buf.length; j++) {
  	            b.push(buf[j]);
  	            if (b.length === 4) {
  	                if (charsProcessed === 0) {
  	                    // Check BOM first.
  	                    if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
  	                        return 'utf-32le';
  	                    }
  	                    if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
  	                        return 'utf-32be';
  	                    }
  	                }

  	                if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
  	                if (b[3] !== 0 || b[2] > 0x10) invalidLE++;

  	                if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
  	                if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;

  	                b.length = 0;
  	                charsProcessed++;

  	                if (charsProcessed >= 100) {
  	                    break outer_loop;
  	                }
  	            }
  	        }
  	    }

  	    // Make decisions.
  	    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)  return 'utf-32be';
  	    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)  return 'utf-32le';

  	    // Couldn't decide (likely all zeros or not enough data).
  	    return defaultEncoding || 'utf-32le';
  	}
  	return utf32;
  }

  var utf16 = {};

  var hasRequiredUtf16;

  function requireUtf16 () {
  	if (hasRequiredUtf16) return utf16;
  	hasRequiredUtf16 = 1;
  	var Buffer = requireSafer().Buffer;

  	// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

  	// == UTF16-BE codec. ==========================================================

  	utf16.utf16be = Utf16BECodec;
  	function Utf16BECodec() {
  	}

  	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  	Utf16BECodec.prototype.bomAware = true;


  	// -- Encoding

  	function Utf16BEEncoder() {
  	}

  	Utf16BEEncoder.prototype.write = function(str) {
  	    var buf = Buffer.from(str, 'ucs2');
  	    for (var i = 0; i < buf.length; i += 2) {
  	        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
  	    }
  	    return buf;
  	};

  	Utf16BEEncoder.prototype.end = function() {
  	};


  	// -- Decoding

  	function Utf16BEDecoder() {
  	    this.overflowByte = -1;
  	}

  	Utf16BEDecoder.prototype.write = function(buf) {
  	    if (buf.length == 0)
  	        return '';

  	    var buf2 = Buffer.alloc(buf.length + 1),
  	        i = 0, j = 0;

  	    if (this.overflowByte !== -1) {
  	        buf2[0] = buf[0];
  	        buf2[1] = this.overflowByte;
  	        i = 1; j = 2;
  	    }

  	    for (; i < buf.length-1; i += 2, j+= 2) {
  	        buf2[j] = buf[i+1];
  	        buf2[j+1] = buf[i];
  	    }

  	    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

  	    return buf2.slice(0, j).toString('ucs2');
  	};

  	Utf16BEDecoder.prototype.end = function() {
  	    this.overflowByte = -1;
  	};


  	// == UTF-16 codec =============================================================
  	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
  	// Defaults to UTF-16LE, as it's prevalent and default in Node.
  	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
  	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

  	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

  	utf16.utf16 = Utf16Codec;
  	function Utf16Codec(codecOptions, iconv) {
  	    this.iconv = iconv;
  	}

  	Utf16Codec.prototype.encoder = Utf16Encoder;
  	Utf16Codec.prototype.decoder = Utf16Decoder;


  	// -- Encoding (pass-through)

  	function Utf16Encoder(options, codec) {
  	    options = options || {};
  	    if (options.addBOM === undefined)
  	        options.addBOM = true;
  	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
  	}

  	Utf16Encoder.prototype.write = function(str) {
  	    return this.encoder.write(str);
  	};

  	Utf16Encoder.prototype.end = function() {
  	    return this.encoder.end();
  	};


  	// -- Decoding

  	function Utf16Decoder(options, codec) {
  	    this.decoder = null;
  	    this.initialBufs = [];
  	    this.initialBufsLen = 0;

  	    this.options = options || {};
  	    this.iconv = codec.iconv;
  	}

  	Utf16Decoder.prototype.write = function(buf) {
  	    if (!this.decoder) {
  	        // Codec is not chosen yet. Accumulate initial bytes.
  	        this.initialBufs.push(buf);
  	        this.initialBufsLen += buf.length;
  	        
  	        if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)
  	            return '';

  	        // We have enough bytes -> detect endianness.
  	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
  	        this.decoder = this.iconv.getDecoder(encoding, this.options);

  	        var resStr = '';
  	        for (var i = 0; i < this.initialBufs.length; i++)
  	            resStr += this.decoder.write(this.initialBufs[i]);

  	        this.initialBufs.length = this.initialBufsLen = 0;
  	        return resStr;
  	    }

  	    return this.decoder.write(buf);
  	};

  	Utf16Decoder.prototype.end = function() {
  	    if (!this.decoder) {
  	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
  	        this.decoder = this.iconv.getDecoder(encoding, this.options);

  	        var resStr = '';
  	        for (var i = 0; i < this.initialBufs.length; i++)
  	            resStr += this.decoder.write(this.initialBufs[i]);

  	        var trail = this.decoder.end();
  	        if (trail)
  	            resStr += trail;

  	        this.initialBufs.length = this.initialBufsLen = 0;
  	        return resStr;
  	    }
  	    return this.decoder.end();
  	};

  	function detectEncoding(bufs, defaultEncoding) {
  	    var b = [];
  	    var charsProcessed = 0;
  	    var asciiCharsLE = 0, asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.

  	    outer_loop:
  	    for (var i = 0; i < bufs.length; i++) {
  	        var buf = bufs[i];
  	        for (var j = 0; j < buf.length; j++) {
  	            b.push(buf[j]);
  	            if (b.length === 2) {
  	                if (charsProcessed === 0) {
  	                    // Check BOM first.
  	                    if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';
  	                    if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';
  	                }

  	                if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
  	                if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;

  	                b.length = 0;
  	                charsProcessed++;

  	                if (charsProcessed >= 100) {
  	                    break outer_loop;
  	                }
  	            }
  	        }
  	    }

  	    // Make decisions.
  	    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
  	    // So, we count ASCII as if it was LE or BE, and decide from that.
  	    if (asciiCharsBE > asciiCharsLE) return 'utf-16be';
  	    if (asciiCharsBE < asciiCharsLE) return 'utf-16le';

  	    // Couldn't decide (likely all zeros or not enough data).
  	    return defaultEncoding || 'utf-16le';
  	}
  	return utf16;
  }

  var utf7 = {};

  var hasRequiredUtf7;

  function requireUtf7 () {
  	if (hasRequiredUtf7) return utf7;
  	hasRequiredUtf7 = 1;
  	var Buffer = requireSafer().Buffer;

  	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
  	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

  	utf7.utf7 = Utf7Codec;
  	utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
  	function Utf7Codec(codecOptions, iconv) {
  	    this.iconv = iconv;
  	}
  	Utf7Codec.prototype.encoder = Utf7Encoder;
  	Utf7Codec.prototype.decoder = Utf7Decoder;
  	Utf7Codec.prototype.bomAware = true;


  	// -- Encoding

  	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

  	function Utf7Encoder(options, codec) {
  	    this.iconv = codec.iconv;
  	}

  	Utf7Encoder.prototype.write = function(str) {
  	    // Naive implementation.
  	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
  	    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
  	        return "+" + (chunk === '+' ? '' : 
  	            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
  	            + "-";
  	    }.bind(this)));
  	};

  	Utf7Encoder.prototype.end = function() {
  	};


  	// -- Decoding

  	function Utf7Decoder(options, codec) {
  	    this.iconv = codec.iconv;
  	    this.inBase64 = false;
  	    this.base64Accum = '';
  	}

  	var base64Regex = /[A-Za-z0-9\/+]/;
  	var base64Chars = [];
  	for (var i = 0; i < 256; i++)
  	    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

  	var plusChar = '+'.charCodeAt(0), 
  	    minusChar = '-'.charCodeAt(0),
  	    andChar = '&'.charCodeAt(0);

  	Utf7Decoder.prototype.write = function(buf) {
  	    var res = "", lastI = 0,
  	        inBase64 = this.inBase64,
  	        base64Accum = this.base64Accum;

  	    // The decoder is more involved as we must handle chunks in stream.

  	    for (var i = 0; i < buf.length; i++) {
  	        if (!inBase64) { // We're in direct mode.
  	            // Write direct chars until '+'
  	            if (buf[i] == plusChar) {
  	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
  	                lastI = i+1;
  	                inBase64 = true;
  	            }
  	        } else { // We decode base64.
  	            if (!base64Chars[buf[i]]) { // Base64 ended.
  	                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
  	                    res += "+";
  	                } else {
  	                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
  	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
  	                }

  	                if (buf[i] != minusChar) // Minus is absorbed after base64.
  	                    i--;

  	                lastI = i+1;
  	                inBase64 = false;
  	                base64Accum = '';
  	            }
  	        }
  	    }

  	    if (!inBase64) {
  	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
  	    } else {
  	        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");

  	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
  	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
  	        b64str = b64str.slice(0, canBeDecoded);

  	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
  	    }

  	    this.inBase64 = inBase64;
  	    this.base64Accum = base64Accum;

  	    return res;
  	};

  	Utf7Decoder.prototype.end = function() {
  	    var res = "";
  	    if (this.inBase64 && this.base64Accum.length > 0)
  	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

  	    this.inBase64 = false;
  	    this.base64Accum = '';
  	    return res;
  	};


  	// UTF-7-IMAP codec.
  	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
  	// Differences:
  	//  * Base64 part is started by "&" instead of "+"
  	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
  	//  * In Base64, "," is used instead of "/"
  	//  * Base64 must not be used to represent direct characters.
  	//  * No implicit shift back from Base64 (should always end with '-')
  	//  * String must end in non-shifted position.
  	//  * "-&" while in base64 is not allowed.


  	utf7.utf7imap = Utf7IMAPCodec;
  	function Utf7IMAPCodec(codecOptions, iconv) {
  	    this.iconv = iconv;
  	}
  	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  	Utf7IMAPCodec.prototype.bomAware = true;


  	// -- Encoding

  	function Utf7IMAPEncoder(options, codec) {
  	    this.iconv = codec.iconv;
  	    this.inBase64 = false;
  	    this.base64Accum = Buffer.alloc(6);
  	    this.base64AccumIdx = 0;
  	}

  	Utf7IMAPEncoder.prototype.write = function(str) {
  	    var inBase64 = this.inBase64,
  	        base64Accum = this.base64Accum,
  	        base64AccumIdx = this.base64AccumIdx,
  	        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

  	    for (var i = 0; i < str.length; i++) {
  	        var uChar = str.charCodeAt(i);
  	        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
  	            if (inBase64) {
  	                if (base64AccumIdx > 0) {
  	                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
  	                    base64AccumIdx = 0;
  	                }

  	                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
  	                inBase64 = false;
  	            }

  	            if (!inBase64) {
  	                buf[bufIdx++] = uChar; // Write direct character

  	                if (uChar === andChar)  // Ampersand -> '&-'
  	                    buf[bufIdx++] = minusChar;
  	            }

  	        } else { // Non-direct character
  	            if (!inBase64) {
  	                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
  	                inBase64 = true;
  	            }
  	            if (inBase64) {
  	                base64Accum[base64AccumIdx++] = uChar >> 8;
  	                base64Accum[base64AccumIdx++] = uChar & 0xFF;

  	                if (base64AccumIdx == base64Accum.length) {
  	                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
  	                    base64AccumIdx = 0;
  	                }
  	            }
  	        }
  	    }

  	    this.inBase64 = inBase64;
  	    this.base64AccumIdx = base64AccumIdx;

  	    return buf.slice(0, bufIdx);
  	};

  	Utf7IMAPEncoder.prototype.end = function() {
  	    var buf = Buffer.alloc(10), bufIdx = 0;
  	    if (this.inBase64) {
  	        if (this.base64AccumIdx > 0) {
  	            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
  	            this.base64AccumIdx = 0;
  	        }

  	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
  	        this.inBase64 = false;
  	    }

  	    return buf.slice(0, bufIdx);
  	};


  	// -- Decoding

  	function Utf7IMAPDecoder(options, codec) {
  	    this.iconv = codec.iconv;
  	    this.inBase64 = false;
  	    this.base64Accum = '';
  	}

  	var base64IMAPChars = base64Chars.slice();
  	base64IMAPChars[','.charCodeAt(0)] = true;

  	Utf7IMAPDecoder.prototype.write = function(buf) {
  	    var res = "", lastI = 0,
  	        inBase64 = this.inBase64,
  	        base64Accum = this.base64Accum;

  	    // The decoder is more involved as we must handle chunks in stream.
  	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

  	    for (var i = 0; i < buf.length; i++) {
  	        if (!inBase64) { // We're in direct mode.
  	            // Write direct chars until '&'
  	            if (buf[i] == andChar) {
  	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
  	                lastI = i+1;
  	                inBase64 = true;
  	            }
  	        } else { // We decode base64.
  	            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
  	                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
  	                    res += "&";
  	                } else {
  	                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, '/');
  	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
  	                }

  	                if (buf[i] != minusChar) // Minus may be absorbed after base64.
  	                    i--;

  	                lastI = i+1;
  	                inBase64 = false;
  	                base64Accum = '';
  	            }
  	        }
  	    }

  	    if (!inBase64) {
  	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
  	    } else {
  	        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, '/');

  	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
  	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
  	        b64str = b64str.slice(0, canBeDecoded);

  	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
  	    }

  	    this.inBase64 = inBase64;
  	    this.base64Accum = base64Accum;

  	    return res;
  	};

  	Utf7IMAPDecoder.prototype.end = function() {
  	    var res = "";
  	    if (this.inBase64 && this.base64Accum.length > 0)
  	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

  	    this.inBase64 = false;
  	    this.base64Accum = '';
  	    return res;
  	};
  	return utf7;
  }

  var sbcsCodec = {};

  var hasRequiredSbcsCodec;

  function requireSbcsCodec () {
  	if (hasRequiredSbcsCodec) return sbcsCodec;
  	hasRequiredSbcsCodec = 1;
  	var Buffer = requireSafer().Buffer;

  	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
  	// correspond to encoded bytes (if 128 - then lower half is ASCII). 

  	sbcsCodec._sbcs = SBCSCodec;
  	function SBCSCodec(codecOptions, iconv) {
  	    if (!codecOptions)
  	        throw new Error("SBCS codec is called without the data.")
  	    
  	    // Prepare char buffer for decoding.
  	    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
  	        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
  	    
  	    if (codecOptions.chars.length === 128) {
  	        var asciiString = "";
  	        for (var i = 0; i < 128; i++)
  	            asciiString += String.fromCharCode(i);
  	        codecOptions.chars = asciiString + codecOptions.chars;
  	    }

  	    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
  	    
  	    // Encoding buffer.
  	    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

  	    for (var i = 0; i < codecOptions.chars.length; i++)
  	        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

  	    this.encodeBuf = encodeBuf;
  	}

  	SBCSCodec.prototype.encoder = SBCSEncoder;
  	SBCSCodec.prototype.decoder = SBCSDecoder;


  	function SBCSEncoder(options, codec) {
  	    this.encodeBuf = codec.encodeBuf;
  	}

  	SBCSEncoder.prototype.write = function(str) {
  	    var buf = Buffer.alloc(str.length);
  	    for (var i = 0; i < str.length; i++)
  	        buf[i] = this.encodeBuf[str.charCodeAt(i)];
  	    
  	    return buf;
  	};

  	SBCSEncoder.prototype.end = function() {
  	};


  	function SBCSDecoder(options, codec) {
  	    this.decodeBuf = codec.decodeBuf;
  	}

  	SBCSDecoder.prototype.write = function(buf) {
  	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
  	    var decodeBuf = this.decodeBuf;
  	    var newBuf = Buffer.alloc(buf.length*2);
  	    var idx1 = 0, idx2 = 0;
  	    for (var i = 0; i < buf.length; i++) {
  	        idx1 = buf[i]*2; idx2 = i*2;
  	        newBuf[idx2] = decodeBuf[idx1];
  	        newBuf[idx2+1] = decodeBuf[idx1+1];
  	    }
  	    return newBuf.toString('ucs2');
  	};

  	SBCSDecoder.prototype.end = function() {
  	};
  	return sbcsCodec;
  }

  var sbcsData;
  var hasRequiredSbcsData;

  function requireSbcsData () {
  	if (hasRequiredSbcsData) return sbcsData;
  	hasRequiredSbcsData = 1;

  	// Manually added data to be used by sbcs codec in addition to generated one.

  	sbcsData = {
  	    // Not supported by iconv, not sure why.
  	    "10029": "maccenteuro",
  	    "maccenteuro": {
  	        "type": "_sbcs",
  	        "chars": ""
  	    },

  	    "808": "cp808",
  	    "ibm808": "cp808",
  	    "cp808": {
  	        "type": "_sbcs",
  	        "chars": ""
  	    },

  	    "mik": {
  	        "type": "_sbcs",
  	        "chars": ""
  	    },

  	    "cp720": {
  	        "type": "_sbcs",
  	        "chars": "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
  	    },

  	    // Aliases of generated encodings.
  	    "ascii8bit": "ascii",
  	    "usascii": "ascii",
  	    "ansix34": "ascii",
  	    "ansix341968": "ascii",
  	    "ansix341986": "ascii",
  	    "csascii": "ascii",
  	    "cp367": "ascii",
  	    "ibm367": "ascii",
  	    "isoir6": "ascii",
  	    "iso646us": "ascii",
  	    "iso646irv": "ascii",
  	    "us": "ascii",

  	    "latin1": "iso88591",
  	    "latin2": "iso88592",
  	    "latin3": "iso88593",
  	    "latin4": "iso88594",
  	    "latin5": "iso88599",
  	    "latin6": "iso885910",
  	    "latin7": "iso885913",
  	    "latin8": "iso885914",
  	    "latin9": "iso885915",
  	    "latin10": "iso885916",

  	    "csisolatin1": "iso88591",
  	    "csisolatin2": "iso88592",
  	    "csisolatin3": "iso88593",
  	    "csisolatin4": "iso88594",
  	    "csisolatincyrillic": "iso88595",
  	    "csisolatinarabic": "iso88596",
  	    "csisolatingreek" : "iso88597",
  	    "csisolatinhebrew": "iso88598",
  	    "csisolatin5": "iso88599",
  	    "csisolatin6": "iso885910",

  	    "l1": "iso88591",
  	    "l2": "iso88592",
  	    "l3": "iso88593",
  	    "l4": "iso88594",
  	    "l5": "iso88599",
  	    "l6": "iso885910",
  	    "l7": "iso885913",
  	    "l8": "iso885914",
  	    "l9": "iso885915",
  	    "l10": "iso885916",

  	    "isoir14": "iso646jp",
  	    "isoir57": "iso646cn",
  	    "isoir100": "iso88591",
  	    "isoir101": "iso88592",
  	    "isoir109": "iso88593",
  	    "isoir110": "iso88594",
  	    "isoir144": "iso88595",
  	    "isoir127": "iso88596",
  	    "isoir126": "iso88597",
  	    "isoir138": "iso88598",
  	    "isoir148": "iso88599",
  	    "isoir157": "iso885910",
  	    "isoir166": "tis620",
  	    "isoir179": "iso885913",
  	    "isoir199": "iso885914",
  	    "isoir203": "iso885915",
  	    "isoir226": "iso885916",

  	    "cp819": "iso88591",
  	    "ibm819": "iso88591",

  	    "cyrillic": "iso88595",

  	    "arabic": "iso88596",
  	    "arabic8": "iso88596",
  	    "ecma114": "iso88596",
  	    "asmo708": "iso88596",

  	    "greek" : "iso88597",
  	    "greek8" : "iso88597",
  	    "ecma118" : "iso88597",
  	    "elot928" : "iso88597",

  	    "hebrew": "iso88598",
  	    "hebrew8": "iso88598",

  	    "turkish": "iso88599",
  	    "turkish8": "iso88599",

  	    "thai": "iso885911",
  	    "thai8": "iso885911",

  	    "celtic": "iso885914",
  	    "celtic8": "iso885914",
  	    "isoceltic": "iso885914",

  	    "tis6200": "tis620",
  	    "tis62025291": "tis620",
  	    "tis62025330": "tis620",

  	    "10000": "macroman",
  	    "10006": "macgreek",
  	    "10007": "maccyrillic",
  	    "10079": "maciceland",
  	    "10081": "macturkish",

  	    "cspc8codepage437": "cp437",
  	    "cspc775baltic": "cp775",
  	    "cspc850multilingual": "cp850",
  	    "cspcp852": "cp852",
  	    "cspc862latinhebrew": "cp862",
  	    "cpgr": "cp869",

  	    "msee": "cp1250",
  	    "mscyrl": "cp1251",
  	    "msansi": "cp1252",
  	    "msgreek": "cp1253",
  	    "msturk": "cp1254",
  	    "mshebr": "cp1255",
  	    "msarab": "cp1256",
  	    "winbaltrim": "cp1257",

  	    "cp20866": "koi8r",
  	    "20866": "koi8r",
  	    "ibm878": "koi8r",
  	    "cskoi8r": "koi8r",

  	    "cp21866": "koi8u",
  	    "21866": "koi8u",
  	    "ibm1168": "koi8u",

  	    "strk10482002": "rk1048",

  	    "tcvn5712": "tcvn",
  	    "tcvn57121": "tcvn",

  	    "gb198880": "iso646cn",
  	    "cn": "iso646cn",

  	    "csiso14jisc6220ro": "iso646jp",
  	    "jisc62201969ro": "iso646jp",
  	    "jp": "iso646jp",

  	    "cshproman8": "hproman8",
  	    "r8": "hproman8",
  	    "roman8": "hproman8",
  	    "xroman8": "hproman8",
  	    "ibm1051": "hproman8",

  	    "mac": "macintosh",
  	    "csmacintosh": "macintosh",
  	};
  	return sbcsData;
  }

  var sbcsDataGenerated;
  var hasRequiredSbcsDataGenerated;

  function requireSbcsDataGenerated () {
  	if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  	hasRequiredSbcsDataGenerated = 1;

  	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
  	sbcsDataGenerated = {
  	  "437": "cp437",
  	  "737": "cp737",
  	  "775": "cp775",
  	  "850": "cp850",
  	  "852": "cp852",
  	  "855": "cp855",
  	  "856": "cp856",
  	  "857": "cp857",
  	  "858": "cp858",
  	  "860": "cp860",
  	  "861": "cp861",
  	  "862": "cp862",
  	  "863": "cp863",
  	  "864": "cp864",
  	  "865": "cp865",
  	  "866": "cp866",
  	  "869": "cp869",
  	  "874": "windows874",
  	  "922": "cp922",
  	  "1046": "cp1046",
  	  "1124": "cp1124",
  	  "1125": "cp1125",
  	  "1129": "cp1129",
  	  "1133": "cp1133",
  	  "1161": "cp1161",
  	  "1162": "cp1162",
  	  "1163": "cp1163",
  	  "1250": "windows1250",
  	  "1251": "windows1251",
  	  "1252": "windows1252",
  	  "1253": "windows1253",
  	  "1254": "windows1254",
  	  "1255": "windows1255",
  	  "1256": "windows1256",
  	  "1257": "windows1257",
  	  "1258": "windows1258",
  	  "28591": "iso88591",
  	  "28592": "iso88592",
  	  "28593": "iso88593",
  	  "28594": "iso88594",
  	  "28595": "iso88595",
  	  "28596": "iso88596",
  	  "28597": "iso88597",
  	  "28598": "iso88598",
  	  "28599": "iso88599",
  	  "28600": "iso885910",
  	  "28601": "iso885911",
  	  "28603": "iso885913",
  	  "28604": "iso885914",
  	  "28605": "iso885915",
  	  "28606": "iso885916",
  	  "windows874": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win874": "windows874",
  	  "cp874": "windows874",
  	  "windows1250": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1250": "windows1250",
  	  "cp1250": "windows1250",
  	  "windows1251": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1251": "windows1251",
  	  "cp1251": "windows1251",
  	  "windows1252": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1252": "windows1252",
  	  "cp1252": "windows1252",
  	  "windows1253": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1253": "windows1253",
  	  "cp1253": "windows1253",
  	  "windows1254": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1254": "windows1254",
  	  "cp1254": "windows1254",
  	  "windows1255": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1255": "windows1255",
  	  "cp1255": "windows1255",
  	  "windows1256": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1256": "windows1256",
  	  "cp1256": "windows1256",
  	  "windows1257": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1257": "windows1257",
  	  "cp1257": "windows1257",
  	  "windows1258": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "win1258": "windows1258",
  	  "cp1258": "windows1258",
  	  "iso88591": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28591": "iso88591",
  	  "iso88592": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28592": "iso88592",
  	  "iso88593": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28593": "iso88593",
  	  "iso88594": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28594": "iso88594",
  	  "iso88595": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28595": "iso88595",
  	  "iso88596": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28596": "iso88596",
  	  "iso88597": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28597": "iso88597",
  	  "iso88598": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28598": "iso88598",
  	  "iso88599": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28599": "iso88599",
  	  "iso885910": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28600": "iso885910",
  	  "iso885911": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28601": "iso885911",
  	  "iso885913": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28603": "iso885913",
  	  "iso885914": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28604": "iso885914",
  	  "iso885915": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28605": "iso885915",
  	  "iso885916": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "cp28606": "iso885916",
  	  "cp437": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm437": "cp437",
  	  "csibm437": "cp437",
  	  "cp737": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm737": "cp737",
  	  "csibm737": "cp737",
  	  "cp775": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm775": "cp775",
  	  "csibm775": "cp775",
  	  "cp850": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm850": "cp850",
  	  "csibm850": "cp850",
  	  "cp852": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm852": "cp852",
  	  "csibm852": "cp852",
  	  "cp855": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm855": "cp855",
  	  "csibm855": "cp855",
  	  "cp856": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm856": "cp856",
  	  "csibm856": "cp856",
  	  "cp857": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm857": "cp857",
  	  "csibm857": "cp857",
  	  "cp858": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm858": "cp858",
  	  "csibm858": "cp858",
  	  "cp860": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm860": "cp860",
  	  "csibm860": "cp860",
  	  "cp861": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm861": "cp861",
  	  "csibm861": "cp861",
  	  "cp862": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm862": "cp862",
  	  "csibm862": "cp862",
  	  "cp863": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm863": "cp863",
  	  "csibm863": "cp863",
  	  "cp864": {
  	    "type": "_sbcs",
  	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  	  },
  	  "ibm864": "cp864",
  	  "csibm864": "cp864",
  	  "cp865": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm865": "cp865",
  	  "csibm865": "cp865",
  	  "cp866": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm866": "cp866",
  	  "csibm866": "cp866",
  	  "cp869": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm869": "cp869",
  	  "csibm869": "cp869",
  	  "cp922": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm922": "cp922",
  	  "csibm922": "cp922",
  	  "cp1046": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1046": "cp1046",
  	  "csibm1046": "cp1046",
  	  "cp1124": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1124": "cp1124",
  	  "csibm1124": "cp1124",
  	  "cp1125": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1125": "cp1125",
  	  "csibm1125": "cp1125",
  	  "cp1129": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1129": "cp1129",
  	  "csibm1129": "cp1129",
  	  "cp1133": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1133": "cp1133",
  	  "csibm1133": "cp1133",
  	  "cp1161": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1161": "cp1161",
  	  "csibm1161": "cp1161",
  	  "cp1162": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1162": "cp1162",
  	  "csibm1162": "cp1162",
  	  "cp1163": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ibm1163": "cp1163",
  	  "csibm1163": "cp1163",
  	  "maccroatian": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "maccyrillic": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macgreek": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "maciceland": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macroman": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macromania": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macthai": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macturkish": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macukraine": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "koi8r": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "koi8u": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "koi8ru": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "koi8t": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "armscii8": {
  	    "type": "_sbcs",
  	    "chars": ")(.,-"
  	  },
  	  "rk1048": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "tcvn": {
  	    "type": "_sbcs",
  	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  	  },
  	  "georgianacademy": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "georgianps": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "pt154": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "viscii": {
  	    "type": "_sbcs",
  	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  	  },
  	  "iso646cn": {
  	    "type": "_sbcs",
  	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  	  },
  	  "iso646jp": {
  	    "type": "_sbcs",
  	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  	  },
  	  "hproman8": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "macintosh": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "ascii": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  },
  	  "tis620": {
  	    "type": "_sbcs",
  	    "chars": ""
  	  }
  	};
  	return sbcsDataGenerated;
  }

  var dbcsCodec = {};

  var hasRequiredDbcsCodec;

  function requireDbcsCodec () {
  	if (hasRequiredDbcsCodec) return dbcsCodec;
  	hasRequiredDbcsCodec = 1;
  	var Buffer = requireSafer().Buffer;

  	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
  	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
  	// To save memory and loading time, we read table files only when requested.

  	dbcsCodec._dbcs = DBCSCodec;

  	var UNASSIGNED = -1,
  	    GB18030_CODE = -2,
  	    SEQ_START  = -10,
  	    NODE_START = -1000,
  	    UNASSIGNED_NODE = new Array(0x100),
  	    DEF_CHAR = -1;

  	for (var i = 0; i < 0x100; i++)
  	    UNASSIGNED_NODE[i] = UNASSIGNED;


  	// Class DBCSCodec reads and initializes mapping tables.
  	function DBCSCodec(codecOptions, iconv) {
  	    this.encodingName = codecOptions.encodingName;
  	    if (!codecOptions)
  	        throw new Error("DBCS codec is called without the data.")
  	    if (!codecOptions.table)
  	        throw new Error("Encoding '" + this.encodingName + "' has no data.");

  	    // Load tables.
  	    var mappingTable = codecOptions.table();


  	    // Decode tables: MBCS -> Unicode.

  	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
  	    // Trie root is decodeTables[0].
  	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
  	    //         == UNASSIGNED -> unknown/unassigned sequence.
  	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
  	    //         <= NODE_START -> index of the next node in our trie to process next byte.
  	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
  	    this.decodeTables = [];
  	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

  	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
  	    this.decodeTableSeq = [];

  	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
  	    for (var i = 0; i < mappingTable.length; i++)
  	        this._addDecodeChunk(mappingTable[i]);

  	    // Load & create GB18030 tables when needed.
  	    if (typeof codecOptions.gb18030 === 'function') {
  	        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

  	        // Add GB18030 common decode nodes.
  	        var commonThirdByteNodeIdx = this.decodeTables.length;
  	        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

  	        var commonFourthByteNodeIdx = this.decodeTables.length;
  	        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

  	        // Fill out the tree
  	        var firstByteNode = this.decodeTables[0];
  	        for (var i = 0x81; i <= 0xFE; i++) {
  	            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
  	            for (var j = 0x30; j <= 0x39; j++) {
  	                if (secondByteNode[j] === UNASSIGNED) {
  	                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
  	                } else if (secondByteNode[j] > NODE_START) {
  	                    throw new Error("gb18030 decode tables conflict at byte 2");
  	                }

  	                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
  	                for (var k = 0x81; k <= 0xFE; k++) {
  	                    if (thirdByteNode[k] === UNASSIGNED) {
  	                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
  	                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
  	                        continue;
  	                    } else if (thirdByteNode[k] > NODE_START) {
  	                        throw new Error("gb18030 decode tables conflict at byte 3");
  	                    }

  	                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
  	                    for (var l = 0x30; l <= 0x39; l++) {
  	                        if (fourthByteNode[l] === UNASSIGNED)
  	                            fourthByteNode[l] = GB18030_CODE;
  	                    }
  	                }
  	            }
  	        }
  	    }

  	    this.defaultCharUnicode = iconv.defaultCharUnicode;

  	    
  	    // Encode tables: Unicode -> DBCS.

  	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
  	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
  	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
  	    //         == UNASSIGNED -> no conversion found. Output a default char.
  	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
  	    this.encodeTable = [];
  	    
  	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
  	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
  	    // means end of sequence (needed when one sequence is a strict subsequence of another).
  	    // Objects are kept separately from encodeTable to increase performance.
  	    this.encodeTableSeq = [];

  	    // Some chars can be decoded, but need not be encoded.
  	    var skipEncodeChars = {};
  	    if (codecOptions.encodeSkipVals)
  	        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
  	            var val = codecOptions.encodeSkipVals[i];
  	            if (typeof val === 'number')
  	                skipEncodeChars[val] = true;
  	            else
  	                for (var j = val.from; j <= val.to; j++)
  	                    skipEncodeChars[j] = true;
  	        }
  	        
  	    // Use decode trie to recursively fill out encode tables.
  	    this._fillEncodeTable(0, 0, skipEncodeChars);

  	    // Add more encoding pairs when needed.
  	    if (codecOptions.encodeAdd) {
  	        for (var uChar in codecOptions.encodeAdd)
  	            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
  	                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
  	    }

  	    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
  	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
  	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  	}

  	DBCSCodec.prototype.encoder = DBCSEncoder;
  	DBCSCodec.prototype.decoder = DBCSDecoder;

  	// Decoder helpers
  	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
  	    var bytes = [];
  	    for (; addr > 0; addr >>>= 8)
  	        bytes.push(addr & 0xFF);
  	    if (bytes.length == 0)
  	        bytes.push(0);

  	    var node = this.decodeTables[0];
  	    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
  	        var val = node[bytes[i]];

  	        if (val == UNASSIGNED) { // Create new node.
  	            node[bytes[i]] = NODE_START - this.decodeTables.length;
  	            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
  	        }
  	        else if (val <= NODE_START) { // Existing node.
  	            node = this.decodeTables[NODE_START - val];
  	        }
  	        else
  	            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
  	    }
  	    return node;
  	};


  	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
  	    // First element of chunk is the hex mbcs code where we start.
  	    var curAddr = parseInt(chunk[0], 16);

  	    // Choose the decoding node where we'll write our chars.
  	    var writeTable = this._getDecodeTrieNode(curAddr);
  	    curAddr = curAddr & 0xFF;

  	    // Write all other elements of the chunk to the table.
  	    for (var k = 1; k < chunk.length; k++) {
  	        var part = chunk[k];
  	        if (typeof part === "string") { // String, write as-is.
  	            for (var l = 0; l < part.length;) {
  	                var code = part.charCodeAt(l++);
  	                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
  	                    var codeTrail = part.charCodeAt(l++);
  	                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
  	                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
  	                    else
  	                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
  	                }
  	                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
  	                    var len = 0xFFF - code + 2;
  	                    var seq = [];
  	                    for (var m = 0; m < len; m++)
  	                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

  	                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
  	                    this.decodeTableSeq.push(seq);
  	                }
  	                else
  	                    writeTable[curAddr++] = code; // Basic char
  	            }
  	        } 
  	        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
  	            var charCode = writeTable[curAddr - 1] + 1;
  	            for (var l = 0; l < part; l++)
  	                writeTable[curAddr++] = charCode++;
  	        }
  	        else
  	            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
  	    }
  	    if (curAddr > 0xFF)
  	        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  	};

  	// Encoder helpers
  	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
  	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
  	    if (this.encodeTable[high] === undefined)
  	        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
  	    return this.encodeTable[high];
  	};

  	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
  	    var bucket = this._getEncodeBucket(uCode);
  	    var low = uCode & 0xFF;
  	    if (bucket[low] <= SEQ_START)
  	        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
  	    else if (bucket[low] == UNASSIGNED)
  	        bucket[low] = dbcsCode;
  	};

  	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
  	    
  	    // Get the root of character tree according to first character of the sequence.
  	    var uCode = seq[0];
  	    var bucket = this._getEncodeBucket(uCode);
  	    var low = uCode & 0xFF;

  	    var node;
  	    if (bucket[low] <= SEQ_START) {
  	        // There's already a sequence with  - use it.
  	        node = this.encodeTableSeq[SEQ_START-bucket[low]];
  	    }
  	    else {
  	        // There was no sequence object - allocate a new one.
  	        node = {};
  	        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
  	        bucket[low] = SEQ_START - this.encodeTableSeq.length;
  	        this.encodeTableSeq.push(node);
  	    }

  	    // Traverse the character tree, allocating new nodes as needed.
  	    for (var j = 1; j < seq.length-1; j++) {
  	        var oldVal = node[uCode];
  	        if (typeof oldVal === 'object')
  	            node = oldVal;
  	        else {
  	            node = node[uCode] = {};
  	            if (oldVal !== undefined)
  	                node[DEF_CHAR] = oldVal;
  	        }
  	    }

  	    // Set the leaf to given dbcsCode.
  	    uCode = seq[seq.length-1];
  	    node[uCode] = dbcsCode;
  	};

  	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
  	    var node = this.decodeTables[nodeIdx];
  	    var hasValues = false;
  	    var subNodeEmpty = {};
  	    for (var i = 0; i < 0x100; i++) {
  	        var uCode = node[i];
  	        var mbCode = prefix + i;
  	        if (skipEncodeChars[mbCode])
  	            continue;

  	        if (uCode >= 0) {
  	            this._setEncodeChar(uCode, mbCode);
  	            hasValues = true;
  	        } else if (uCode <= NODE_START) {
  	            var subNodeIdx = NODE_START - uCode;
  	            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
  	                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.
  	                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
  	                    hasValues = true;
  	                else
  	                    subNodeEmpty[subNodeIdx] = true;
  	            }
  	        } else if (uCode <= SEQ_START) {
  	            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
  	            hasValues = true;
  	        }
  	    }
  	    return hasValues;
  	};



  	// == Encoder ==================================================================

  	function DBCSEncoder(options, codec) {
  	    // Encoder state
  	    this.leadSurrogate = -1;
  	    this.seqObj = undefined;
  	    
  	    // Static data
  	    this.encodeTable = codec.encodeTable;
  	    this.encodeTableSeq = codec.encodeTableSeq;
  	    this.defaultCharSingleByte = codec.defCharSB;
  	    this.gb18030 = codec.gb18030;
  	}

  	DBCSEncoder.prototype.write = function(str) {
  	    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
  	        leadSurrogate = this.leadSurrogate,
  	        seqObj = this.seqObj, nextChar = -1,
  	        i = 0, j = 0;

  	    while (true) {
  	        // 0. Get next character.
  	        if (nextChar === -1) {
  	            if (i == str.length) break;
  	            var uCode = str.charCodeAt(i++);
  	        }
  	        else {
  	            var uCode = nextChar;
  	            nextChar = -1;    
  	        }

  	        // 1. Handle surrogates.
  	        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
  	            if (uCode < 0xDC00) { // We've got lead surrogate.
  	                if (leadSurrogate === -1) {
  	                    leadSurrogate = uCode;
  	                    continue;
  	                } else {
  	                    leadSurrogate = uCode;
  	                    // Double lead surrogate found.
  	                    uCode = UNASSIGNED;
  	                }
  	            } else { // We've got trail surrogate.
  	                if (leadSurrogate !== -1) {
  	                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
  	                    leadSurrogate = -1;
  	                } else {
  	                    // Incomplete surrogate pair - only trail surrogate found.
  	                    uCode = UNASSIGNED;
  	                }
  	                
  	            }
  	        }
  	        else if (leadSurrogate !== -1) {
  	            // Incomplete surrogate pair - only lead surrogate found.
  	            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
  	            leadSurrogate = -1;
  	        }

  	        // 2. Convert uCode character.
  	        var dbcsCode = UNASSIGNED;
  	        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
  	            var resCode = seqObj[uCode];
  	            if (typeof resCode === 'object') { // Sequence continues.
  	                seqObj = resCode;
  	                continue;

  	            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
  	                dbcsCode = resCode;

  	            } else if (resCode == undefined) { // Current character is not part of the sequence.

  	                // Try default character for this sequence
  	                resCode = seqObj[DEF_CHAR];
  	                if (resCode !== undefined) {
  	                    dbcsCode = resCode; // Found. Write it.
  	                    nextChar = uCode; // Current character will be written too in the next iteration.

  	                }
  	            }
  	            seqObj = undefined;
  	        }
  	        else if (uCode >= 0) {  // Regular character
  	            var subtable = this.encodeTable[uCode >> 8];
  	            if (subtable !== undefined)
  	                dbcsCode = subtable[uCode & 0xFF];
  	            
  	            if (dbcsCode <= SEQ_START) { // Sequence start
  	                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
  	                continue;
  	            }

  	            if (dbcsCode == UNASSIGNED && this.gb18030) {
  	                // Use GB18030 algorithm to find character(s) to write.
  	                var idx = findIdx(this.gb18030.uChars, uCode);
  	                if (idx != -1) {
  	                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
  	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
  	                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
  	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
  	                    newBuf[j++] = 0x30 + dbcsCode;
  	                    continue;
  	                }
  	            }
  	        }

  	        // 3. Write dbcsCode character.
  	        if (dbcsCode === UNASSIGNED)
  	            dbcsCode = this.defaultCharSingleByte;
  	        
  	        if (dbcsCode < 0x100) {
  	            newBuf[j++] = dbcsCode;
  	        }
  	        else if (dbcsCode < 0x10000) {
  	            newBuf[j++] = dbcsCode >> 8;   // high byte
  	            newBuf[j++] = dbcsCode & 0xFF; // low byte
  	        }
  	        else if (dbcsCode < 0x1000000) {
  	            newBuf[j++] = dbcsCode >> 16;
  	            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
  	            newBuf[j++] = dbcsCode & 0xFF;
  	        } else {
  	            newBuf[j++] = dbcsCode >>> 24;
  	            newBuf[j++] = (dbcsCode >>> 16) & 0xFF;
  	            newBuf[j++] = (dbcsCode >>> 8) & 0xFF;
  	            newBuf[j++] = dbcsCode & 0xFF;
  	        }
  	    }

  	    this.seqObj = seqObj;
  	    this.leadSurrogate = leadSurrogate;
  	    return newBuf.slice(0, j);
  	};

  	DBCSEncoder.prototype.end = function() {
  	    if (this.leadSurrogate === -1 && this.seqObj === undefined)
  	        return; // All clean. Most often case.

  	    var newBuf = Buffer.alloc(10), j = 0;

  	    if (this.seqObj) { // We're in the sequence.
  	        var dbcsCode = this.seqObj[DEF_CHAR];
  	        if (dbcsCode !== undefined) { // Write beginning of the sequence.
  	            if (dbcsCode < 0x100) {
  	                newBuf[j++] = dbcsCode;
  	            }
  	            else {
  	                newBuf[j++] = dbcsCode >> 8;   // high byte
  	                newBuf[j++] = dbcsCode & 0xFF; // low byte
  	            }
  	        }
  	        this.seqObj = undefined;
  	    }

  	    if (this.leadSurrogate !== -1) {
  	        // Incomplete surrogate pair - only lead surrogate found.
  	        newBuf[j++] = this.defaultCharSingleByte;
  	        this.leadSurrogate = -1;
  	    }
  	    
  	    return newBuf.slice(0, j);
  	};

  	// Export for testing
  	DBCSEncoder.prototype.findIdx = findIdx;


  	// == Decoder ==================================================================

  	function DBCSDecoder(options, codec) {
  	    // Decoder state
  	    this.nodeIdx = 0;
  	    this.prevBytes = [];

  	    // Static data
  	    this.decodeTables = codec.decodeTables;
  	    this.decodeTableSeq = codec.decodeTableSeq;
  	    this.defaultCharUnicode = codec.defaultCharUnicode;
  	    this.gb18030 = codec.gb18030;
  	}

  	DBCSDecoder.prototype.write = function(buf) {
  	    var newBuf = Buffer.alloc(buf.length*2),
  	        nodeIdx = this.nodeIdx, 
  	        prevBytes = this.prevBytes, prevOffset = this.prevBytes.length,
  	        seqStart = -this.prevBytes.length, // idx of the start of current parsed sequence.
  	        uCode;

  	    for (var i = 0, j = 0; i < buf.length; i++) {
  	        var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];

  	        // Lookup in current trie node.
  	        var uCode = this.decodeTables[nodeIdx][curByte];

  	        if (uCode >= 0) ;
  	        else if (uCode === UNASSIGNED) { // Unknown char.
  	            // TODO: Callback with seq.
  	            uCode = this.defaultCharUnicode.charCodeAt(0);
  	            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
  	        }
  	        else if (uCode === GB18030_CODE) {
  	            if (i >= 3) {
  	                var ptr = (buf[i-3]-0x81)*12600 + (buf[i-2]-0x30)*1260 + (buf[i-1]-0x81)*10 + (curByte-0x30);
  	            } else {
  	                var ptr = (prevBytes[i-3+prevOffset]-0x81)*12600 + 
  	                          (((i-2 >= 0) ? buf[i-2] : prevBytes[i-2+prevOffset])-0x30)*1260 + 
  	                          (((i-1 >= 0) ? buf[i-1] : prevBytes[i-1+prevOffset])-0x81)*10 + 
  	                          (curByte-0x30);
  	            }
  	            var idx = findIdx(this.gb18030.gbChars, ptr);
  	            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
  	        }
  	        else if (uCode <= NODE_START) { // Go to next trie node.
  	            nodeIdx = NODE_START - uCode;
  	            continue;
  	        }
  	        else if (uCode <= SEQ_START) { // Output a sequence of chars.
  	            var seq = this.decodeTableSeq[SEQ_START - uCode];
  	            for (var k = 0; k < seq.length - 1; k++) {
  	                uCode = seq[k];
  	                newBuf[j++] = uCode & 0xFF;
  	                newBuf[j++] = uCode >> 8;
  	            }
  	            uCode = seq[seq.length-1];
  	        }
  	        else
  	            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

  	        // Write the character to buffer, handling higher planes using surrogate pair.
  	        if (uCode >= 0x10000) { 
  	            uCode -= 0x10000;
  	            var uCodeLead = 0xD800 | (uCode >> 10);
  	            newBuf[j++] = uCodeLead & 0xFF;
  	            newBuf[j++] = uCodeLead >> 8;

  	            uCode = 0xDC00 | (uCode & 0x3FF);
  	        }
  	        newBuf[j++] = uCode & 0xFF;
  	        newBuf[j++] = uCode >> 8;

  	        // Reset trie node.
  	        nodeIdx = 0; seqStart = i+1;
  	    }

  	    this.nodeIdx = nodeIdx;
  	    this.prevBytes = (seqStart >= 0)
  	        ? Array.prototype.slice.call(buf, seqStart)
  	        : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));

  	    return newBuf.slice(0, j).toString('ucs2');
  	};

  	DBCSDecoder.prototype.end = function() {
  	    var ret = '';

  	    // Try to parse all remaining chars.
  	    while (this.prevBytes.length > 0) {
  	        // Skip 1 character in the buffer.
  	        ret += this.defaultCharUnicode;
  	        var bytesArr = this.prevBytes.slice(1);

  	        // Parse remaining as usual.
  	        this.prevBytes = [];
  	        this.nodeIdx = 0;
  	        if (bytesArr.length > 0)
  	            ret += this.write(bytesArr);
  	    }

  	    this.prevBytes = [];
  	    this.nodeIdx = 0;
  	    return ret;
  	};

  	// Binary search for GB18030. Returns largest i such that table[i] <= val.
  	function findIdx(table, val) {
  	    if (table[0] > val)
  	        return -1;

  	    var l = 0, r = table.length;
  	    while (l < r-1) { // always table[l] <= val < table[r]
  	        var mid = l + ((r-l+1) >> 1);
  	        if (table[mid] <= val)
  	            l = mid;
  	        else
  	            r = mid;
  	    }
  	    return l;
  	}
  	return dbcsCodec;
  }

  var require$$0 = [
  	[
  		"0",
  		"\u0000",
  		128
  	],
  	[
  		"a1",
  		"",
  		62
  	],
  	[
  		"8140",
  		"",
  		9,
  		""
  	],
  	[
  		"8180",
  		""
  	],
  	[
  		"81b8",
  		""
  	],
  	[
  		"81c8",
  		""
  	],
  	[
  		"81da",
  		""
  	],
  	[
  		"81f0",
  		""
  	],
  	[
  		"81fc",
  		""
  	],
  	[
  		"824f",
  		"",
  		9
  	],
  	[
  		"8260",
  		"",
  		25
  	],
  	[
  		"8281",
  		"",
  		25
  	],
  	[
  		"829f",
  		"",
  		82
  	],
  	[
  		"8340",
  		"",
  		62
  	],
  	[
  		"8380",
  		"",
  		22
  	],
  	[
  		"839f",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"83bf",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"8440",
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"8470",
  		"",
  		5,
  		"",
  		7
  	],
  	[
  		"8480",
  		"",
  		17
  	],
  	[
  		"849f",
  		""
  	],
  	[
  		"8740",
  		"",
  		19,
  		"",
  		9
  	],
  	[
  		"875f",
  		""
  	],
  	[
  		"877e",
  		""
  	],
  	[
  		"8780",
  		"",
  		4,
  		""
  	],
  	[
  		"889f",
  		""
  	],
  	[
  		"8940",
  		""
  	],
  	[
  		"8980",
  		""
  	],
  	[
  		"8a40",
  		""
  	],
  	[
  		"8a80",
  		""
  	],
  	[
  		"8b40",
  		""
  	],
  	[
  		"8b80",
  		""
  	],
  	[
  		"8c40",
  		""
  	],
  	[
  		"8c80",
  		""
  	],
  	[
  		"8d40",
  		""
  	],
  	[
  		"8d80",
  		""
  	],
  	[
  		"8e40",
  		""
  	],
  	[
  		"8e80",
  		""
  	],
  	[
  		"8f40",
  		""
  	],
  	[
  		"8f80",
  		""
  	],
  	[
  		"9040",
  		""
  	],
  	[
  		"9080",
  		""
  	],
  	[
  		"9140",
  		""
  	],
  	[
  		"9180",
  		""
  	],
  	[
  		"9240",
  		""
  	],
  	[
  		"9280",
  		""
  	],
  	[
  		"9340",
  		""
  	],
  	[
  		"9380",
  		""
  	],
  	[
  		"9440",
  		""
  	],
  	[
  		"9480",
  		""
  	],
  	[
  		"9540",
  		""
  	],
  	[
  		"9580",
  		""
  	],
  	[
  		"9640",
  		""
  	],
  	[
  		"9680",
  		""
  	],
  	[
  		"9740",
  		""
  	],
  	[
  		"9780",
  		""
  	],
  	[
  		"9840",
  		""
  	],
  	[
  		"989f",
  		""
  	],
  	[
  		"9940",
  		""
  	],
  	[
  		"9980",
  		""
  	],
  	[
  		"9a40",
  		""
  	],
  	[
  		"9a80",
  		""
  	],
  	[
  		"9b40",
  		""
  	],
  	[
  		"9b80",
  		""
  	],
  	[
  		"9c40",
  		""
  	],
  	[
  		"9c80",
  		""
  	],
  	[
  		"9d40",
  		""
  	],
  	[
  		"9d80",
  		""
  	],
  	[
  		"9e40",
  		""
  	],
  	[
  		"9e80",
  		""
  	],
  	[
  		"9f40",
  		""
  	],
  	[
  		"9f80",
  		""
  	],
  	[
  		"e040",
  		""
  	],
  	[
  		"e080",
  		""
  	],
  	[
  		"e140",
  		""
  	],
  	[
  		"e180",
  		""
  	],
  	[
  		"e240",
  		""
  	],
  	[
  		"e280",
  		""
  	],
  	[
  		"e340",
  		""
  	],
  	[
  		"e380",
  		""
  	],
  	[
  		"e440",
  		""
  	],
  	[
  		"e480",
  		""
  	],
  	[
  		"e540",
  		""
  	],
  	[
  		"e580",
  		""
  	],
  	[
  		"e640",
  		""
  	],
  	[
  		"e680",
  		""
  	],
  	[
  		"e740",
  		""
  	],
  	[
  		"e780",
  		""
  	],
  	[
  		"e840",
  		""
  	],
  	[
  		"e880",
  		""
  	],
  	[
  		"e940",
  		""
  	],
  	[
  		"e980",
  		""
  	],
  	[
  		"ea40",
  		""
  	],
  	[
  		"ea80",
  		""
  	],
  	[
  		"ed40",
  		""
  	],
  	[
  		"ed80",
  		""
  	],
  	[
  		"ee40",
  		""
  	],
  	[
  		"ee80",
  		""
  	],
  	[
  		"eeef",
  		"",
  		9,
  		""
  	],
  	[
  		"f040",
  		"",
  		62
  	],
  	[
  		"f080",
  		"",
  		124
  	],
  	[
  		"f140",
  		"",
  		62
  	],
  	[
  		"f180",
  		"",
  		124
  	],
  	[
  		"f240",
  		"",
  		62
  	],
  	[
  		"f280",
  		"",
  		124
  	],
  	[
  		"f340",
  		"",
  		62
  	],
  	[
  		"f380",
  		"",
  		124
  	],
  	[
  		"f440",
  		"",
  		62
  	],
  	[
  		"f480",
  		"",
  		124
  	],
  	[
  		"f540",
  		"",
  		62
  	],
  	[
  		"f580",
  		"",
  		124
  	],
  	[
  		"f640",
  		"",
  		62
  	],
  	[
  		"f680",
  		"",
  		124
  	],
  	[
  		"f740",
  		"",
  		62
  	],
  	[
  		"f780",
  		"",
  		124
  	],
  	[
  		"f840",
  		"",
  		62
  	],
  	[
  		"f880",
  		"",
  		124
  	],
  	[
  		"f940",
  		""
  	],
  	[
  		"fa40",
  		"",
  		9,
  		"",
  		9,
  		""
  	],
  	[
  		"fa80",
  		""
  	],
  	[
  		"fb40",
  		""
  	],
  	[
  		"fb80",
  		""
  	],
  	[
  		"fc40",
  		""
  	]
  ];

  var require$$1 = [
  	[
  		"0",
  		"\u0000",
  		127
  	],
  	[
  		"8ea1",
  		"",
  		62
  	],
  	[
  		"a1a1",
  		"",
  		9,
  		""
  	],
  	[
  		"a2a1",
  		""
  	],
  	[
  		"a2ba",
  		""
  	],
  	[
  		"a2ca",
  		""
  	],
  	[
  		"a2dc",
  		""
  	],
  	[
  		"a2f2",
  		""
  	],
  	[
  		"a2fe",
  		""
  	],
  	[
  		"a3b0",
  		"",
  		9
  	],
  	[
  		"a3c1",
  		"",
  		25
  	],
  	[
  		"a3e1",
  		"",
  		25
  	],
  	[
  		"a4a1",
  		"",
  		82
  	],
  	[
  		"a5a1",
  		"",
  		85
  	],
  	[
  		"a6a1",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"a6c1",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"a7a1",
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"a7d1",
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"a8a1",
  		""
  	],
  	[
  		"ada1",
  		"",
  		19,
  		"",
  		9
  	],
  	[
  		"adc0",
  		""
  	],
  	[
  		"addf",
  		"",
  		4,
  		""
  	],
  	[
  		"b0a1",
  		""
  	],
  	[
  		"b1a1",
  		""
  	],
  	[
  		"b2a1",
  		""
  	],
  	[
  		"b3a1",
  		""
  	],
  	[
  		"b4a1",
  		""
  	],
  	[
  		"b5a1",
  		""
  	],
  	[
  		"b6a1",
  		""
  	],
  	[
  		"b7a1",
  		""
  	],
  	[
  		"b8a1",
  		""
  	],
  	[
  		"b9a1",
  		""
  	],
  	[
  		"baa1",
  		""
  	],
  	[
  		"bba1",
  		""
  	],
  	[
  		"bca1",
  		""
  	],
  	[
  		"bda1",
  		""
  	],
  	[
  		"bea1",
  		""
  	],
  	[
  		"bfa1",
  		""
  	],
  	[
  		"c0a1",
  		""
  	],
  	[
  		"c1a1",
  		""
  	],
  	[
  		"c2a1",
  		""
  	],
  	[
  		"c3a1",
  		""
  	],
  	[
  		"c4a1",
  		""
  	],
  	[
  		"c5a1",
  		""
  	],
  	[
  		"c6a1",
  		""
  	],
  	[
  		"c7a1",
  		""
  	],
  	[
  		"c8a1",
  		""
  	],
  	[
  		"c9a1",
  		""
  	],
  	[
  		"caa1",
  		""
  	],
  	[
  		"cba1",
  		""
  	],
  	[
  		"cca1",
  		""
  	],
  	[
  		"cda1",
  		""
  	],
  	[
  		"cea1",
  		""
  	],
  	[
  		"cfa1",
  		""
  	],
  	[
  		"d0a1",
  		""
  	],
  	[
  		"d1a1",
  		""
  	],
  	[
  		"d2a1",
  		""
  	],
  	[
  		"d3a1",
  		""
  	],
  	[
  		"d4a1",
  		""
  	],
  	[
  		"d5a1",
  		""
  	],
  	[
  		"d6a1",
  		""
  	],
  	[
  		"d7a1",
  		""
  	],
  	[
  		"d8a1",
  		""
  	],
  	[
  		"d9a1",
  		""
  	],
  	[
  		"daa1",
  		""
  	],
  	[
  		"dba1",
  		""
  	],
  	[
  		"dca1",
  		""
  	],
  	[
  		"dda1",
  		""
  	],
  	[
  		"dea1",
  		""
  	],
  	[
  		"dfa1",
  		""
  	],
  	[
  		"e0a1",
  		""
  	],
  	[
  		"e1a1",
  		""
  	],
  	[
  		"e2a1",
  		""
  	],
  	[
  		"e3a1",
  		""
  	],
  	[
  		"e4a1",
  		""
  	],
  	[
  		"e5a1",
  		""
  	],
  	[
  		"e6a1",
  		""
  	],
  	[
  		"e7a1",
  		""
  	],
  	[
  		"e8a1",
  		""
  	],
  	[
  		"e9a1",
  		""
  	],
  	[
  		"eaa1",
  		""
  	],
  	[
  		"eba1",
  		""
  	],
  	[
  		"eca1",
  		""
  	],
  	[
  		"eda1",
  		""
  	],
  	[
  		"eea1",
  		""
  	],
  	[
  		"efa1",
  		""
  	],
  	[
  		"f0a1",
  		""
  	],
  	[
  		"f1a1",
  		""
  	],
  	[
  		"f2a1",
  		""
  	],
  	[
  		"f3a1",
  		""
  	],
  	[
  		"f4a1",
  		""
  	],
  	[
  		"f9a1",
  		""
  	],
  	[
  		"faa1",
  		""
  	],
  	[
  		"fba1",
  		""
  	],
  	[
  		"fca1",
  		""
  	],
  	[
  		"fcf1",
  		"",
  		9,
  		""
  	],
  	[
  		"8fa2af",
  		""
  	],
  	[
  		"8fa2c2",
  		""
  	],
  	[
  		"8fa2eb",
  		""
  	],
  	[
  		"8fa6e1",
  		""
  	],
  	[
  		"8fa6e7",
  		""
  	],
  	[
  		"8fa6e9",
  		""
  	],
  	[
  		"8fa6ec",
  		""
  	],
  	[
  		"8fa6f1",
  		""
  	],
  	[
  		"8fa7c2",
  		"",
  		10,
  		""
  	],
  	[
  		"8fa7f2",
  		"",
  		10,
  		""
  	],
  	[
  		"8fa9a1",
  		""
  	],
  	[
  		"8fa9a4",
  		""
  	],
  	[
  		"8fa9a6",
  		""
  	],
  	[
  		"8fa9a8",
  		""
  	],
  	[
  		"8fa9ab",
  		""
  	],
  	[
  		"8fa9af",
  		""
  	],
  	[
  		"8fa9c1",
  		""
  	],
  	[
  		"8faaa1",
  		""
  	],
  	[
  		"8faaba",
  		""
  	],
  	[
  		"8faba1",
  		""
  	],
  	[
  		"8fabbd",
  		""
  	],
  	[
  		"8fabc5",
  		""
  	],
  	[
  		"8fb0a1",
  		""
  	],
  	[
  		"8fb1a1",
  		""
  	],
  	[
  		"8fb2a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fb3a1",
  		""
  	],
  	[
  		"8fb4a1",
  		""
  	],
  	[
  		"8fb5a1",
  		""
  	],
  	[
  		"8fb6a1",
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"8fb7a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fb8a1",
  		""
  	],
  	[
  		"8fb9a1",
  		""
  	],
  	[
  		"8fbaa1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fbba1",
  		""
  	],
  	[
  		"8fbca1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fbda1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fbea1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fbfa1",
  		""
  	],
  	[
  		"8fc0a1",
  		""
  	],
  	[
  		"8fc1a1",
  		""
  	],
  	[
  		"8fc2a1",
  		""
  	],
  	[
  		"8fc3a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fc4a1",
  		""
  	],
  	[
  		"8fc5a1",
  		""
  	],
  	[
  		"8fc6a1",
  		""
  	],
  	[
  		"8fc7a1",
  		""
  	],
  	[
  		"8fc8a1",
  		""
  	],
  	[
  		"8fc9a1",
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"8fcaa1",
  		""
  	],
  	[
  		"8fcba1",
  		""
  	],
  	[
  		"8fcca1",
  		"",
  		9,
  		""
  	],
  	[
  		"8fcda1",
  		"",
  		5,
  		""
  	],
  	[
  		"8fcea1",
  		"",
  		6,
  		""
  	],
  	[
  		"8fcfa1",
  		""
  	],
  	[
  		"8fd0a1",
  		""
  	],
  	[
  		"8fd1a1",
  		""
  	],
  	[
  		"8fd2a1",
  		"",
  		5
  	],
  	[
  		"8fd3a1",
  		""
  	],
  	[
  		"8fd4a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fd5a1",
  		""
  	],
  	[
  		"8fd6a1",
  		""
  	],
  	[
  		"8fd7a1",
  		""
  	],
  	[
  		"8fd8a1",
  		""
  	],
  	[
  		"8fd9a1",
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"8fdaa1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fdba1",
  		"",
  		6,
  		""
  	],
  	[
  		"8fdca1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fdda1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fdea1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fdfa1",
  		""
  	],
  	[
  		"8fe0a1",
  		""
  	],
  	[
  		"8fe1a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fe2a1",
  		""
  	],
  	[
  		"8fe3a1",
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"8fe4a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fe5a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fe6a1",
  		""
  	],
  	[
  		"8fe7a1",
  		""
  	],
  	[
  		"8fe8a1",
  		"",
  		4,
  		""
  	],
  	[
  		"8fe9a1",
  		"",
  		4
  	],
  	[
  		"8feaa1",
  		"",
  		4,
  		""
  	],
  	[
  		"8feba1",
  		"",
  		4,
  		""
  	],
  	[
  		"8feca1",
  		""
  	],
  	[
  		"8feda1",
  		"",
  		4,
  		"",
  		4,
  		""
  	]
  ];

  var require$$2 = [
  	[
  		"0",
  		"\u0000",
  		127,
  		""
  	],
  	[
  		"8140",
  		"",
  		5,
  		"",
  		9,
  		"",
  		6,
  		""
  	],
  	[
  		"8180",
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"8240",
  		"",
  		4,
  		"",
  		8,
  		"",
  		4,
  		"",
  		11
  	],
  	[
  		"8280",
  		"",
  		10,
  		"",
  		4,
  		"",
  		7,
  		"",
  		5,
  		"",
  		8,
  		"",
  		20,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"8340",
  		"",
  		17,
  		"",
  		5,
  		"",
  		10,
  		"",
  		4,
  		"",
  		9,
  		""
  	],
  	[
  		"8380",
  		"",
  		5,
  		"",
  		13,
  		"",
  		28,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5
  	],
  	[
  		"8440",
  		"",
  		5,
  		"",
  		5,
  		""
  	],
  	[
  		"8480",
  		"",
  		9,
  		"",
  		4,
  		"",
  		6,
  		"",
  		6,
  		"",
  		9,
  		"",
  		5,
  		"",
  		10,
  		"",
  		7,
  		""
  	],
  	[
  		"8540",
  		"",
  		9,
  		""
  	],
  	[
  		"8580",
  		"",
  		4,
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		"",
  		7,
  		""
  	],
  	[
  		"8640",
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"8680",
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		"",
  		8,
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"8740",
  		"",
  		7,
  		"",
  		11,
  		"",
  		4,
  		"",
  		4
  	],
  	[
  		"8780",
  		"",
  		7,
  		"",
  		6,
  		"",
  		14,
  		"",
  		10,
  		"",
  		6,
  		"",
  		12,
  		"",
  		8,
  		"",
  		5,
  		"",
  		6
  	],
  	[
  		"8840",
  		"",
  		9,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"8880",
  		"",
  		4,
  		"",
  		6,
  		"",
  		8,
  		"",
  		6,
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		"",
  		7
  	],
  	[
  		"8940",
  		"",
  		5,
  		"",
  		6,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		16,
  		""
  	],
  	[
  		"8980",
  		"",
  		4,
  		"",
  		4,
  		"",
  		7,
  		"",
  		17,
  		"",
  		10,
  		"",
  		13,
  		"",
  		5,
  		"",
  		7,
  		"",
  		4,
  		""
  	],
  	[
  		"8a40",
  		"",
  		4,
  		"",
  		12,
  		""
  	],
  	[
  		"8a80",
  		"",
  		5,
  		"",
  		6,
  		"",
  		4,
  		"",
  		11,
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		"",
  		9,
  		"",
  		5
  	],
  	[
  		"8b40",
  		"",
  		8,
  		"",
  		17,
  		"",
  		6,
  		"",
  		13,
  		""
  	],
  	[
  		"8b80",
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		22,
  		"",
  		11,
  		"",
  		25,
  		"",
  		7,
  		"",
  		6
  	],
  	[
  		"8c40",
  		"",
  		7,
  		""
  	],
  	[
  		"8c80",
  		"",
  		8,
  		"",
  		4,
  		"",
  		6,
  		"",
  		6,
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		"",
  		4
  	],
  	[
  		"8d40",
  		"",
  		5,
  		"",
  		5,
  		"",
  		5,
  		"",
  		6,
  		"",
  		9,
  		"",
  		4
  	],
  	[
  		"8d80",
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		"",
  		7,
  		"",
  		7,
  		"",
  		10,
  		"",
  		10,
  		"",
  		12,
  		"",
  		21,
  		""
  	],
  	[
  		"8e40",
  		"",
  		21,
  		"",
  		12,
  		"",
  		6,
  		"",
  		12,
  		""
  	],
  	[
  		"8e80",
  		"",
  		4,
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		"",
  		4,
  		"",
  		14,
  		"",
  		4,
  		"",
  		4,
  		"",
  		6
  	],
  	[
  		"8f40",
  		"",
  		5,
  		"",
  		11,
  		"",
  		8,
  		""
  	],
  	[
  		"8f80",
  		"",
  		6,
  		"",
  		14,
  		"",
  		5,
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"9040",
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"9080",
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		"",
  		18,
  		"",
  		6
  	],
  	[
  		"9140",
  		"",
  		6,
  		"",
  		6,
  		"",
  		18,
  		"",
  		4,
  		""
  	],
  	[
  		"9180",
  		"",
  		6,
  		"",
  		8,
  		"",
  		9,
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		16,
  		"",
  		13,
  		"",
  		8,
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"9240",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9280",
  		"",
  		5,
  		"",
  		7,
  		"",
  		6,
  		""
  	],
  	[
  		"9340",
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"9380",
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		"",
  		4,
  		"",
  		7,
  		"",
  		9,
  		"",
  		6,
  		"",
  		8,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"9440",
  		"",
  		24,
  		"",
  		7,
  		"",
  		7,
  		"",
  		4,
  		"",
  		8
  	],
  	[
  		"9480",
  		"",
  		4,
  		"",
  		4,
  		"",
  		14,
  		"",
  		7,
  		"",
  		7,
  		""
  	],
  	[
  		"9540",
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"9580",
  		"",
  		4,
  		"",
  		4,
  		"",
  		8,
  		"",
  		4,
  		"",
  		4,
  		"",
  		25,
  		"",
  		7,
  		"",
  		5,
  		""
  	],
  	[
  		"9640",
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"9680",
  		"",
  		7,
  		"",
  		9,
  		"",
  		7,
  		"",
  		4,
  		"",
  		6,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"9740",
  		"",
  		7,
  		"",
  		8,
  		"",
  		7,
  		"",
  		9,
  		""
  	],
  	[
  		"9780",
  		"",
  		6,
  		"",
  		5,
  		"",
  		4,
  		"",
  		9,
  		"",
  		4,
  		"",
  		11,
  		"",
  		7,
  		"",
  		16,
  		""
  	],
  	[
  		"9840",
  		"",
  		4,
  		"",
  		5,
  		"",
  		9,
  		""
  	],
  	[
  		"9880",
  		"",
  		7,
  		"",
  		5,
  		"",
  		11,
  		"",
  		9,
  		"",
  		9,
  		"",
  		11,
  		"",
  		5,
  		"",
  		5,
  		"",
  		6,
  		"",
  		4,
  		"",
  		7,
  		"",
  		6,
  		""
  	],
  	[
  		"9940",
  		"",
  		4,
  		"",
  		10,
  		"",
  		6,
  		"",
  		8,
  		"",
  		4,
  		"",
  		7,
  		"",
  		5
  	],
  	[
  		"9980",
  		"",
  		114,
  		"",
  		6
  	],
  	[
  		"9a40",
  		"",
  		11,
  		"",
  		7,
  		"",
  		13,
  		""
  	],
  	[
  		"9a80",
  		"",
  		4,
  		"",
  		7,
  		"",
  		7,
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		"",
  		7,
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"9b40",
  		"",
  		4,
  		""
  	],
  	[
  		"9b80",
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"9c40",
  		"",
  		7,
  		""
  	],
  	[
  		"9c80",
  		"",
  		7,
  		"",
  		7,
  		"",
  		10,
  		"",
  		14,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"9d40",
  		"",
  		7,
  		"",
  		4,
  		"",
  		9,
  		"",
  		6,
  		""
  	],
  	[
  		"9d80",
  		"",
  		9,
  		"",
  		5,
  		"",
  		6,
  		"",
  		12,
  		"",
  		4,
  		"",
  		10,
  		"",
  		5,
  		"",
  		5,
  		"",
  		6,
  		"",
  		10,
  		""
  	],
  	[
  		"9e40",
  		"",
  		7,
  		"",
  		32,
  		"",
  		7,
  		"",
  		6,
  		"",
  		6
  	],
  	[
  		"9e80",
  		"",
  		9,
  		"",
  		17,
  		"",
  		13,
  		"",
  		11,
  		"",
  		12,
  		"",
  		12,
  		""
  	],
  	[
  		"9f40",
  		"",
  		6,
  		"",
  		10,
  		"",
  		4,
  		"",
  		10,
  		"",
  		7,
  		""
  	],
  	[
  		"9f80",
  		"",
  		13,
  		"",
  		12,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		8,
  		"",
  		9,
  		"",
  		4
  	],
  	[
  		"a040",
  		"",
  		9,
  		"",
  		5,
  		"",
  		9,
  		"",
  		11,
  		"",
  		19
  	],
  	[
  		"a080",
  		"",
  		9,
  		"",
  		6,
  		"",
  		4,
  		"",
  		11,
  		"",
  		11,
  		"",
  		6,
  		""
  	],
  	[
  		"a1a1",
  		"",
  		7,
  		""
  	],
  	[
  		"a2a1",
  		"",
  		9
  	],
  	[
  		"a2b1",
  		"",
  		19,
  		"",
  		19,
  		"",
  		9
  	],
  	[
  		"a2e5",
  		"",
  		9
  	],
  	[
  		"a2f1",
  		"",
  		11
  	],
  	[
  		"a3a1",
  		"",
  		88,
  		""
  	],
  	[
  		"a4a1",
  		"",
  		82
  	],
  	[
  		"a5a1",
  		"",
  		85
  	],
  	[
  		"a6a1",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"a6c1",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"a6e0",
  		""
  	],
  	[
  		"a6ee",
  		""
  	],
  	[
  		"a6f4",
  		""
  	],
  	[
  		"a7a1",
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"a7d1",
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"a840",
  		"",
  		35,
  		"",
  		6
  	],
  	[
  		"a880",
  		"",
  		7,
  		""
  	],
  	[
  		"a8a1",
  		""
  	],
  	[
  		"a8bd",
  		""
  	],
  	[
  		"a8c0",
  		""
  	],
  	[
  		"a8c5",
  		"",
  		36
  	],
  	[
  		"a940",
  		"",
  		8,
  		""
  	],
  	[
  		"a959",
  		""
  	],
  	[
  		"a95c",
  		""
  	],
  	[
  		"a960",
  		"",
  		9,
  		"",
  		8
  	],
  	[
  		"a980",
  		"",
  		4,
  		""
  	],
  	[
  		"a996",
  		""
  	],
  	[
  		"a9a4",
  		"",
  		75
  	],
  	[
  		"aa40",
  		"",
  		5,
  		"",
  		5,
  		"",
  		8
  	],
  	[
  		"aa80",
  		"",
  		7,
  		"",
  		10,
  		""
  	],
  	[
  		"ab40",
  		"",
  		11,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4
  	],
  	[
  		"ab80",
  		"",
  		6,
  		"",
  		4
  	],
  	[
  		"ac40",
  		"",
  		10,
  		"",
  		8,
  		"",
  		5,
  		"",
  		4,
  		"",
  		11
  	],
  	[
  		"ac80",
  		"",
  		6,
  		"",
  		12,
  		"",
  		4,
  		""
  	],
  	[
  		"ad40",
  		"",
  		10,
  		"",
  		7,
  		"",
  		15,
  		"",
  		12
  	],
  	[
  		"ad80",
  		"",
  		9,
  		"",
  		8,
  		"",
  		6,
  		""
  	],
  	[
  		"ae40",
  		"",
  		6,
  		"",
  		7,
  		"",
  		4,
  		""
  	],
  	[
  		"ae80",
  		"",
  		7,
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"af40",
  		"",
  		4,
  		""
  	],
  	[
  		"af80",
  		""
  	],
  	[
  		"b040",
  		"",
  		6,
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		"",
  		7,
  		""
  	],
  	[
  		"b080",
  		"",
  		7,
  		"",
  		8,
  		"",
  		9,
  		""
  	],
  	[
  		"b140",
  		"",
  		4,
  		"",
  		7,
  		"",
  		10,
  		""
  	],
  	[
  		"b180",
  		"",
  		4,
  		"",
  		7,
  		"",
  		7,
  		""
  	],
  	[
  		"b240",
  		"",
  		11,
  		"",
  		5,
  		"",
  		11,
  		"",
  		4
  	],
  	[
  		"b280",
  		"",
  		12,
  		"",
  		8,
  		"",
  		4,
  		""
  	],
  	[
  		"b340",
  		"",
  		5,
  		""
  	],
  	[
  		"b380",
  		"",
  		11,
  		"",
  		7,
  		"",
  		6,
  		""
  	],
  	[
  		"b440",
  		"",
  		7,
  		"",
  		9
  	],
  	[
  		"b480",
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"b540",
  		"",
  		5,
  		"",
  		9,
  		"",
  		4,
  		"",
  		14,
  		"",
  		4,
  		"",
  		8,
  		""
  	],
  	[
  		"b580",
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"b640",
  		"",
  		6,
  		"",
  		11,
  		"",
  		10,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"b680",
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"b740",
  		"",
  		14,
  		"",
  		5,
  		"",
  		9,
  		"",
  		4,
  		"",
  		16
  	],
  	[
  		"b780",
  		"",
  		6,
  		""
  	],
  	[
  		"b840",
  		"",
  		4,
  		"",
  		10,
  		"",
  		10,
  		"",
  		9,
  		"",
  		5,
  		""
  	],
  	[
  		"b880",
  		"",
  		4,
  		""
  	],
  	[
  		"b940",
  		"",
  		5,
  		"",
  		10,
  		"",
  		6,
  		""
  	],
  	[
  		"b980",
  		"",
  		7,
  		""
  	],
  	[
  		"ba40",
  		"",
  		4,
  		"",
  		4,
  		"",
  		7,
  		"",
  		5,
  		""
  	],
  	[
  		"ba80",
  		"",
  		4,
  		"",
  		5,
  		"",
  		12,
  		"",
  		5,
  		""
  	],
  	[
  		"bb40",
  		"",
  		9,
  		"",
  		36,
  		"",
  		5,
  		"",
  		9
  	],
  	[
  		"bb80",
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"bc40",
  		"",
  		6,
  		"",
  		6,
  		"",
  		5,
  		"",
  		7,
  		"",
  		13,
  		"",
  		5
  	],
  	[
  		"bc80",
  		"",
  		14,
  		"",
  		6,
  		""
  	],
  	[
  		"bd40",
  		"",
  		54,
  		"",
  		7
  	],
  	[
  		"bd80",
  		"",
  		32,
  		""
  	],
  	[
  		"be40",
  		"",
  		12,
  		"",
  		6,
  		"",
  		42
  	],
  	[
  		"be80",
  		"",
  		32,
  		""
  	],
  	[
  		"bf40",
  		"",
  		62
  	],
  	[
  		"bf80",
  		"",
  		4,
  		"",
  		4,
  		"",
  		21,
  		""
  	],
  	[
  		"c040",
  		"",
  		35,
  		"",
  		23,
  		""
  	],
  	[
  		"c080",
  		"",
  		6,
  		"",
  		9,
  		""
  	],
  	[
  		"c140",
  		"",
  		4,
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"c180",
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"c240",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"c280",
  		"",
  		13,
  		"",
  		5,
  		"",
  		11,
  		""
  	],
  	[
  		"c340",
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"c380",
  		"",
  		12,
  		"",
  		4,
  		""
  	],
  	[
  		"c440",
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"c480",
  		"",
  		7,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"c540",
  		"",
  		14,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"c580",
  		"",
  		7,
  		"",
  		7,
  		""
  	],
  	[
  		"c640",
  		""
  	],
  	[
  		"c680",
  		"",
  		4,
  		"",
  		9,
  		""
  	],
  	[
  		"c740",
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		6,
  		"",
  		6,
  		""
  	],
  	[
  		"c780",
  		""
  	],
  	[
  		"c840",
  		"",
  		4,
  		"",
  		5,
  		"",
  		5,
  		"",
  		7,
  		"",
  		5,
  		"",
  		7,
  		""
  	],
  	[
  		"c880",
  		"",
  		6,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"c940",
  		"",
  		4,
  		"",
  		7,
  		"",
  		12,
  		""
  	],
  	[
  		"c980",
  		"",
  		4,
  		"",
  		4,
  		"",
  		10,
  		""
  	],
  	[
  		"ca40",
  		"",
  		8,
  		"",
  		8,
  		"",
  		9,
  		"",
  		4,
  		"",
  		10
  	],
  	[
  		"ca80",
  		"",
  		4,
  		"",
  		8,
  		""
  	],
  	[
  		"cb40",
  		"",
  		6,
  		"",
  		10,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"cb80",
  		"",
  		5,
  		"",
  		6,
  		"",
  		14,
  		""
  	],
  	[
  		"cc40",
  		"",
  		4,
  		"",
  		10,
  		"",
  		15,
  		"",
  		13,
  		""
  	],
  	[
  		"cc80",
  		"",
  		11,
  		"",
  		4,
  		"",
  		7,
  		""
  	],
  	[
  		"cd40",
  		"",
  		6,
  		"",
  		6,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"cd80",
  		""
  	],
  	[
  		"ce40",
  		"",
  		6,
  		"",
  		5,
  		"",
  		7,
  		""
  	],
  	[
  		"ce80",
  		"",
  		4,
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"cf40",
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		9
  	],
  	[
  		"cf80",
  		"",
  		5,
  		"",
  		7,
  		"",
  		4,
  		""
  	],
  	[
  		"d040",
  		"",
  		13,
  		"",
  		5,
  		"",
  		5,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"d080",
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"d140",
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"d180",
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"d240",
  		"",
  		8,
  		"",
  		24,
  		"",
  		5,
  		"",
  		19,
  		""
  	],
  	[
  		"d280",
  		"",
  		26,
  		""
  	],
  	[
  		"d340",
  		"",
  		30,
  		"",
  		6
  	],
  	[
  		"d380",
  		"",
  		4,
  		"",
  		5,
  		"",
  		21,
  		""
  	],
  	[
  		"d440",
  		"",
  		31,
  		"",
  		8,
  		"",
  		21
  	],
  	[
  		"d480",
  		"",
  		25,
  		"",
  		6,
  		""
  	],
  	[
  		"d540",
  		"",
  		7,
  		"",
  		7,
  		"",
  		46
  	],
  	[
  		"d580",
  		"",
  		32,
  		""
  	],
  	[
  		"d640",
  		"",
  		34,
  		"",
  		27
  	],
  	[
  		"d680",
  		"",
  		30,
  		""
  	],
  	[
  		"d740",
  		"",
  		31,
  		"",
  		4,
  		"",
  		25
  	],
  	[
  		"d780",
  		"",
  		24,
  		""
  	],
  	[
  		"d840",
  		"",
  		8,
  		"",
  		7,
  		"",
  		5,
  		"",
  		6,
  		"",
  		6,
  		"",
  		6,
  		""
  	],
  	[
  		"d880",
  		"",
  		6,
  		"",
  		20,
  		""
  	],
  	[
  		"d940",
  		"",
  		62
  	],
  	[
  		"d980",
  		"",
  		32,
  		""
  	],
  	[
  		"da40",
  		"",
  		14,
  		"",
  		8,
  		"",
  		4,
  		"",
  		9,
  		""
  	],
  	[
  		"da80",
  		"",
  		12,
  		""
  	],
  	[
  		"db40",
  		"",
  		6,
  		"",
  		7,
  		"",
  		4,
  		""
  	],
  	[
  		"db80",
  		"",
  		4,
  		"",
  		5,
  		"",
  		11,
  		""
  	],
  	[
  		"dc40",
  		"",
  		4,
  		"",
  		6,
  		"",
  		6,
  		"",
  		11,
  		"",
  		6,
  		"",
  		7
  	],
  	[
  		"dc80",
  		"",
  		10,
  		"",
  		21,
  		""
  	],
  	[
  		"dd40",
  		"",
  		62
  	],
  	[
  		"dd80",
  		"",
  		32,
  		""
  	],
  	[
  		"de40",
  		"",
  		32,
  		""
  	],
  	[
  		"de80",
  		"",
  		4,
  		""
  	],
  	[
  		"df40",
  		"",
  		5,
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"df80",
  		"",
  		4,
  		""
  	],
  	[
  		"e040",
  		"",
  		19,
  		""
  	],
  	[
  		"e080",
  		"",
  		10,
  		"",
  		6,
  		"",
  		8,
  		""
  	],
  	[
  		"e140",
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		5,
  		""
  	],
  	[
  		"e180",
  		"",
  		10,
  		"",
  		9,
  		"",
  		8,
  		""
  	],
  	[
  		"e240",
  		"",
  		62
  	],
  	[
  		"e280",
  		"",
  		32,
  		"",
  		5,
  		""
  	],
  	[
  		"e340",
  		"",
  		45,
  		"",
  		16
  	],
  	[
  		"e380",
  		"",
  		7,
  		"",
  		24,
  		""
  	],
  	[
  		"e440",
  		"",
  		5,
  		"",
  		24,
  		"",
  		31
  	],
  	[
  		"e480",
  		"",
  		32,
  		""
  	],
  	[
  		"e540",
  		"",
  		51,
  		"",
  		10
  	],
  	[
  		"e580",
  		"",
  		31,
  		""
  	],
  	[
  		"e640",
  		"",
  		34,
  		"",
  		27
  	],
  	[
  		"e680",
  		"",
  		29,
  		""
  	],
  	[
  		"e740",
  		"",
  		7,
  		"",
  		54
  	],
  	[
  		"e780",
  		"",
  		32,
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"e840",
  		"",
  		14,
  		"",
  		43,
  		""
  	],
  	[
  		"e880",
  		"",
  		20,
  		""
  	],
  	[
  		"e940",
  		"",
  		7,
  		"",
  		42
  	],
  	[
  		"e980",
  		"",
  		32,
  		""
  	],
  	[
  		"ea40",
  		"",
  		27,
  		"",
  		6,
  		""
  	],
  	[
  		"ea80",
  		"",
  		4,
  		"",
  		12,
  		""
  	],
  	[
  		"eb40",
  		"",
  		9,
  		"",
  		7,
  		"",
  		9,
  		"",
  		6,
  		""
  	],
  	[
  		"eb80",
  		"",
  		4,
  		""
  	],
  	[
  		"ec40",
  		"",
  		8,
  		"",
  		4,
  		"",
  		18,
  		"",
  		7
  	],
  	[
  		"ec80",
  		"",
  		4,
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"ed40",
  		"",
  		6,
  		"",
  		46
  	],
  	[
  		"ed80",
  		"",
  		4,
  		"",
  		23,
  		""
  	],
  	[
  		"ee40",
  		"",
  		62
  	],
  	[
  		"ee80",
  		"",
  		32,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"ef40",
  		"",
  		5,
  		"",
  		37,
  		"",
  		4
  	],
  	[
  		"ef80",
  		"",
  		30,
  		"",
  		4,
  		"",
  		8,
  		""
  	],
  	[
  		"f040",
  		"",
  		4,
  		"",
  		28,
  		"",
  		26
  	],
  	[
  		"f080",
  		"",
  		9,
  		"",
  		12,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"f140",
  		"",
  		10,
  		"",
  		47
  	],
  	[
  		"f180",
  		"",
  		32,
  		""
  	],
  	[
  		"f240",
  		"",
  		62
  	],
  	[
  		"f280",
  		"",
  		32,
  		""
  	],
  	[
  		"f340",
  		"",
  		17,
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"f380",
  		"",
  		8,
  		"",
  		6,
  		""
  	],
  	[
  		"f440",
  		"",
  		5,
  		"",
  		10,
  		"",
  		10,
  		"",
  		7,
  		"",
  		5
  	],
  	[
  		"f480",
  		"",
  		32,
  		""
  	],
  	[
  		"f540",
  		"",
  		62
  	],
  	[
  		"f580",
  		"",
  		32,
  		""
  	],
  	[
  		"f640",
  		"",
  		62
  	],
  	[
  		"f680",
  		"",
  		32,
  		"",
  		5,
  		"",
  		5,
  		"",
  		4,
  		"",
  		7,
  		""
  	],
  	[
  		"f740",
  		"",
  		62
  	],
  	[
  		"f780",
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"f840",
  		"",
  		62
  	],
  	[
  		"f880",
  		"",
  		32
  	],
  	[
  		"f940",
  		"",
  		62
  	],
  	[
  		"f980",
  		"",
  		32
  	],
  	[
  		"fa40",
  		"",
  		62
  	],
  	[
  		"fa80",
  		"",
  		32
  	],
  	[
  		"fb40",
  		"",
  		27,
  		"",
  		9,
  		""
  	],
  	[
  		"fb80",
  		"",
  		5,
  		"",
  		8,
  		"",
  		5,
  		""
  	],
  	[
  		"fc40",
  		"",
  		8,
  		"",
  		4,
  		"",
  		8,
  		"",
  		6
  	],
  	[
  		"fc80",
  		"",
  		4,
  		"",
  		5,
  		"",
  		8,
  		""
  	],
  	[
  		"fd40",
  		"",
  		4,
  		"",
  		4,
  		"",
  		10,
  		"",
  		38
  	],
  	[
  		"fd80",
  		"",
  		5,
  		"",
  		11,
  		"",
  		4,
  		""
  	],
  	[
  		"fe40",
  		""
  	]
  ];

  var require$$3 = [
  	[
  		"a140",
  		"",
  		62
  	],
  	[
  		"a180",
  		"",
  		32
  	],
  	[
  		"a240",
  		"",
  		62
  	],
  	[
  		"a280",
  		"",
  		32
  	],
  	[
  		"a2ab",
  		"",
  		5
  	],
  	[
  		"a2e3",
  		""
  	],
  	[
  		"a2ef",
  		""
  	],
  	[
  		"a2fd",
  		""
  	],
  	[
  		"a340",
  		"",
  		62
  	],
  	[
  		"a380",
  		"",
  		31,
  		""
  	],
  	[
  		"a440",
  		"",
  		62
  	],
  	[
  		"a480",
  		"",
  		32
  	],
  	[
  		"a4f4",
  		"",
  		10
  	],
  	[
  		"a540",
  		"",
  		62
  	],
  	[
  		"a580",
  		"",
  		32
  	],
  	[
  		"a5f7",
  		"",
  		7
  	],
  	[
  		"a640",
  		"",
  		62
  	],
  	[
  		"a680",
  		"",
  		32
  	],
  	[
  		"a6b9",
  		"",
  		7
  	],
  	[
  		"a6d9",
  		"",
  		6
  	],
  	[
  		"a6ec",
  		""
  	],
  	[
  		"a6f3",
  		""
  	],
  	[
  		"a6f6",
  		"",
  		8
  	],
  	[
  		"a740",
  		"",
  		62
  	],
  	[
  		"a780",
  		"",
  		32
  	],
  	[
  		"a7c2",
  		"",
  		14
  	],
  	[
  		"a7f2",
  		"",
  		12
  	],
  	[
  		"a896",
  		"",
  		10
  	],
  	[
  		"a8bc",
  		""
  	],
  	[
  		"a8bf",
  		""
  	],
  	[
  		"a8c1",
  		""
  	],
  	[
  		"a8ea",
  		"",
  		20
  	],
  	[
  		"a958",
  		""
  	],
  	[
  		"a95b",
  		""
  	],
  	[
  		"a95d",
  		""
  	],
  	[
  		"a989",
  		"",
  		11
  	],
  	[
  		"a997",
  		"",
  		12
  	],
  	[
  		"a9f0",
  		"",
  		14
  	],
  	[
  		"aaa1",
  		"",
  		93
  	],
  	[
  		"aba1",
  		"",
  		93
  	],
  	[
  		"aca1",
  		"",
  		93
  	],
  	[
  		"ada1",
  		"",
  		93
  	],
  	[
  		"aea1",
  		"",
  		93
  	],
  	[
  		"afa1",
  		"",
  		93
  	],
  	[
  		"d7fa",
  		"",
  		4
  	],
  	[
  		"f8a1",
  		"",
  		93
  	],
  	[
  		"f9a1",
  		"",
  		93
  	],
  	[
  		"faa1",
  		"",
  		93
  	],
  	[
  		"fba1",
  		"",
  		93
  	],
  	[
  		"fca1",
  		"",
  		93
  	],
  	[
  		"fda1",
  		"",
  		93
  	],
  	[
  		"fe50",
  		""
  	],
  	[
  		"fe80",
  		"",
  		6,
  		"",
  		93
  	],
  	[
  		"8135f437",
  		""
  	]
  ];

  var uChars = [
  	128,
  	165,
  	169,
  	178,
  	184,
  	216,
  	226,
  	235,
  	238,
  	244,
  	248,
  	251,
  	253,
  	258,
  	276,
  	284,
  	300,
  	325,
  	329,
  	334,
  	364,
  	463,
  	465,
  	467,
  	469,
  	471,
  	473,
  	475,
  	477,
  	506,
  	594,
  	610,
  	712,
  	716,
  	730,
  	930,
  	938,
  	962,
  	970,
  	1026,
  	1104,
  	1106,
  	8209,
  	8215,
  	8218,
  	8222,
  	8231,
  	8241,
  	8244,
  	8246,
  	8252,
  	8365,
  	8452,
  	8454,
  	8458,
  	8471,
  	8482,
  	8556,
  	8570,
  	8596,
  	8602,
  	8713,
  	8720,
  	8722,
  	8726,
  	8731,
  	8737,
  	8740,
  	8742,
  	8748,
  	8751,
  	8760,
  	8766,
  	8777,
  	8781,
  	8787,
  	8802,
  	8808,
  	8816,
  	8854,
  	8858,
  	8870,
  	8896,
  	8979,
  	9322,
  	9372,
  	9548,
  	9588,
  	9616,
  	9622,
  	9634,
  	9652,
  	9662,
  	9672,
  	9676,
  	9680,
  	9702,
  	9735,
  	9738,
  	9793,
  	9795,
  	11906,
  	11909,
  	11913,
  	11917,
  	11928,
  	11944,
  	11947,
  	11951,
  	11956,
  	11960,
  	11964,
  	11979,
  	12284,
  	12292,
  	12312,
  	12319,
  	12330,
  	12351,
  	12436,
  	12447,
  	12535,
  	12543,
  	12586,
  	12842,
  	12850,
  	12964,
  	13200,
  	13215,
  	13218,
  	13253,
  	13263,
  	13267,
  	13270,
  	13384,
  	13428,
  	13727,
  	13839,
  	13851,
  	14617,
  	14703,
  	14801,
  	14816,
  	14964,
  	15183,
  	15471,
  	15585,
  	16471,
  	16736,
  	17208,
  	17325,
  	17330,
  	17374,
  	17623,
  	17997,
  	18018,
  	18212,
  	18218,
  	18301,
  	18318,
  	18760,
  	18811,
  	18814,
  	18820,
  	18823,
  	18844,
  	18848,
  	18872,
  	19576,
  	19620,
  	19738,
  	19887,
  	40870,
  	59244,
  	59336,
  	59367,
  	59413,
  	59417,
  	59423,
  	59431,
  	59437,
  	59443,
  	59452,
  	59460,
  	59478,
  	59493,
  	63789,
  	63866,
  	63894,
  	63976,
  	63986,
  	64016,
  	64018,
  	64021,
  	64025,
  	64034,
  	64037,
  	64042,
  	65074,
  	65093,
  	65107,
  	65112,
  	65127,
  	65132,
  	65375,
  	65510,
  	65536
  ];
  var gbChars = [
  	0,
  	36,
  	38,
  	45,
  	50,
  	81,
  	89,
  	95,
  	96,
  	100,
  	103,
  	104,
  	105,
  	109,
  	126,
  	133,
  	148,
  	172,
  	175,
  	179,
  	208,
  	306,
  	307,
  	308,
  	309,
  	310,
  	311,
  	312,
  	313,
  	341,
  	428,
  	443,
  	544,
  	545,
  	558,
  	741,
  	742,
  	749,
  	750,
  	805,
  	819,
  	820,
  	7922,
  	7924,
  	7925,
  	7927,
  	7934,
  	7943,
  	7944,
  	7945,
  	7950,
  	8062,
  	8148,
  	8149,
  	8152,
  	8164,
  	8174,
  	8236,
  	8240,
  	8262,
  	8264,
  	8374,
  	8380,
  	8381,
  	8384,
  	8388,
  	8390,
  	8392,
  	8393,
  	8394,
  	8396,
  	8401,
  	8406,
  	8416,
  	8419,
  	8424,
  	8437,
  	8439,
  	8445,
  	8482,
  	8485,
  	8496,
  	8521,
  	8603,
  	8936,
  	8946,
  	9046,
  	9050,
  	9063,
  	9066,
  	9076,
  	9092,
  	9100,
  	9108,
  	9111,
  	9113,
  	9131,
  	9162,
  	9164,
  	9218,
  	9219,
  	11329,
  	11331,
  	11334,
  	11336,
  	11346,
  	11361,
  	11363,
  	11366,
  	11370,
  	11372,
  	11375,
  	11389,
  	11682,
  	11686,
  	11687,
  	11692,
  	11694,
  	11714,
  	11716,
  	11723,
  	11725,
  	11730,
  	11736,
  	11982,
  	11989,
  	12102,
  	12336,
  	12348,
  	12350,
  	12384,
  	12393,
  	12395,
  	12397,
  	12510,
  	12553,
  	12851,
  	12962,
  	12973,
  	13738,
  	13823,
  	13919,
  	13933,
  	14080,
  	14298,
  	14585,
  	14698,
  	15583,
  	15847,
  	16318,
  	16434,
  	16438,
  	16481,
  	16729,
  	17102,
  	17122,
  	17315,
  	17320,
  	17402,
  	17418,
  	17859,
  	17909,
  	17911,
  	17915,
  	17916,
  	17936,
  	17939,
  	17961,
  	18664,
  	18703,
  	18814,
  	18962,
  	19043,
  	33469,
  	33470,
  	33471,
  	33484,
  	33485,
  	33490,
  	33497,
  	33501,
  	33505,
  	33513,
  	33520,
  	33536,
  	33550,
  	37845,
  	37921,
  	37948,
  	38029,
  	38038,
  	38064,
  	38065,
  	38066,
  	38069,
  	38075,
  	38076,
  	38078,
  	39108,
  	39109,
  	39113,
  	39114,
  	39115,
  	39116,
  	39265,
  	39394,
  	189000
  ];
  var require$$4$1 = {
  	uChars: uChars,
  	gbChars: gbChars
  };

  var require$$5 = [
  	[
  		"0",
  		"\u0000",
  		127
  	],
  	[
  		"8141",
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"8161",
  		"",
  		9,
  		"",
  		5,
  		""
  	],
  	[
  		"8181",
  		"",
  		18,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		7,
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"8241",
  		"",
  		7,
  		"",
  		5
  	],
  	[
  		"8261",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"8281",
  		"",
  		7,
  		"",
  		7,
  		"",
  		4,
  		"",
  		10,
  		"",
  		5,
  		"",
  		17,
  		"",
  		7,
  		"",
  		6,
  		"",
  		7,
  		"",
  		18
  	],
  	[
  		"8341",
  		"",
  		5,
  		"",
  		5,
  		"",
  		7
  	],
  	[
  		"8361",
  		"",
  		18,
  		""
  	],
  	[
  		"8381",
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		5,
  		"",
  		46,
  		"",
  		6,
  		"",
  		5,
  		"",
  		8
  	],
  	[
  		"8441",
  		"",
  		5,
  		"",
  		8
  	],
  	[
  		"8461",
  		"",
  		18
  	],
  	[
  		"8481",
  		"",
  		7,
  		"",
  		6,
  		"",
  		5,
  		"",
  		10,
  		"",
  		5,
  		"",
  		18,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		26,
  		""
  	],
  	[
  		"8541",
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		"",
  		4
  	],
  	[
  		"8561",
  		"",
  		5,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"8581",
  		"",
  		6,
  		"",
  		6,
  		"",
  		9,
  		"",
  		26,
  		"",
  		29,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"8641",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"8661",
  		"",
  		6,
  		"",
  		10
  	],
  	[
  		"8681",
  		"",
  		22,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		22,
  		"",
  		4,
  		""
  	],
  	[
  		"8741",
  		"",
  		9,
  		"",
  		15
  	],
  	[
  		"8761",
  		"",
  		18,
  		""
  	],
  	[
  		"8781",
  		"",
  		5,
  		"",
  		7,
  		"",
  		7,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		18,
  		"",
  		6,
  		"",
  		26,
  		"",
  		6,
  		"",
  		4
  	],
  	[
  		"8841",
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		"",
  		4
  	],
  	[
  		"8861",
  		"",
  		4,
  		""
  	],
  	[
  		"8881",
  		"",
  		15,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		54,
  		""
  	],
  	[
  		"8941",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"8961",
  		"",
  		10,
  		"",
  		5,
  		""
  	],
  	[
  		"8981",
  		"",
  		21,
  		"",
  		18,
  		"",
  		18,
  		"",
  		6,
  		"",
  		6,
  		"",
  		7,
  		"",
  		15
  	],
  	[
  		"8a41",
  		"",
  		10,
  		"",
  		6,
  		""
  	],
  	[
  		"8a61",
  		"",
  		4,
  		"",
  		18,
  		""
  	],
  	[
  		"8a81",
  		"",
  		4,
  		"",
  		19,
  		"",
  		5,
  		"",
  		7,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		4,
  		"",
  		5,
  		"",
  		26,
  		""
  	],
  	[
  		"8b41",
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"8b61",
  		"",
  		6,
  		"",
  		8
  	],
  	[
  		"8b81",
  		"",
  		52,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		18,
  		"",
  		18
  	],
  	[
  		"8c41",
  		"",
  		15,
  		"",
  		4
  	],
  	[
  		"8c61",
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"8c81",
  		"",
  		12,
  		"",
  		26,
  		"",
  		50,
  		"",
  		5,
  		"",
  		16
  	],
  	[
  		"8d41",
  		"",
  		16,
  		"",
  		8
  	],
  	[
  		"8d61",
  		"",
  		17,
  		""
  	],
  	[
  		"8d81",
  		"",
  		4,
  		"",
  		33,
  		"",
  		6,
  		"",
  		7,
  		"",
  		6,
  		"",
  		9,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"8e41",
  		"",
  		6,
  		"",
  		5,
  		"",
  		8
  	],
  	[
  		"8e61",
  		"",
  		4,
  		"",
  		19
  	],
  	[
  		"8e81",
  		"",
  		13,
  		"",
  		6,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		11,
  		"",
  		7,
  		"",
  		6,
  		"",
  		5,
  		"",
  		7
  	],
  	[
  		"8f41",
  		"",
  		7,
  		"",
  		17
  	],
  	[
  		"8f61",
  		"",
  		7,
  		"",
  		6,
  		"",
  		4
  	],
  	[
  		"8f81",
  		"",
  		5,
  		"",
  		7,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		18,
  		"",
  		6,
  		"",
  		26,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"9041",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9061",
  		"",
  		5,
  		"",
  		15
  	],
  	[
  		"9081",
  		"",
  		12,
  		"",
  		6,
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		"",
  		4,
  		"",
  		5,
  		"",
  		11,
  		"",
  		33,
  		""
  	],
  	[
  		"9141",
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"9161",
  		"",
  		9,
  		"",
  		5
  	],
  	[
  		"9181",
  		"",
  		20,
  		"",
  		4,
  		"",
  		5,
  		"",
  		14,
  		"",
  		33,
  		"",
  		7,
  		"",
  		5,
  		"",
  		6
  	],
  	[
  		"9241",
  		"",
  		7,
  		"",
  		4,
  		""
  	],
  	[
  		"9261",
  		"",
  		7,
  		"",
  		7,
  		"",
  		4
  	],
  	[
  		"9281",
  		"",
  		21,
  		"",
  		18,
  		"",
  		6,
  		"",
  		7,
  		"",
  		6,
  		"",
  		35,
  		""
  	],
  	[
  		"9341",
  		"",
  		4,
  		""
  	],
  	[
  		"9361",
  		"",
  		6,
  		"",
  		8
  	],
  	[
  		"9381",
  		"",
  		37,
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		7,
  		"",
  		22,
  		""
  	],
  	[
  		"9441",
  		"",
  		5,
  		"",
  		5,
  		"",
  		8
  	],
  	[
  		"9461",
  		"",
  		5,
  		"",
  		6,
  		"",
  		12
  	],
  	[
  		"9481",
  		"",
  		5,
  		"",
  		6,
  		"",
  		6,
  		"",
  		9,
  		"",
  		22,
  		"",
  		4,
  		"",
  		6,
  		"",
  		10,
  		"",
  		6,
  		"",
  		24
  	],
  	[
  		"9541",
  		"",
  		11,
  		"",
  		5,
  		""
  	],
  	[
  		"9561",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9581",
  		"",
  		6,
  		"",
  		35,
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		13,
  		"",
  		14
  	],
  	[
  		"9641",
  		"",
  		23,
  		""
  	],
  	[
  		"9661",
  		"",
  		6,
  		"",
  		5,
  		"",
  		8
  	],
  	[
  		"9681",
  		"",
  		10,
  		"",
  		5,
  		"",
  		13,
  		"",
  		33,
  		"",
  		6,
  		"",
  		44
  	],
  	[
  		"9741",
  		"",
  		16,
  		"",
  		8
  	],
  	[
  		"9761",
  		"",
  		17,
  		"",
  		7
  	],
  	[
  		"9781",
  		"",
  		11,
  		"",
  		5,
  		"",
  		6,
  		"",
  		89,
  		""
  	],
  	[
  		"9841",
  		"",
  		16,
  		"",
  		5,
  		""
  	],
  	[
  		"9861",
  		"",
  		6,
  		"",
  		15
  	],
  	[
  		"9881",
  		"",
  		21,
  		"",
  		6,
  		"",
  		5,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9941",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9961",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9981",
  		"",
  		8,
  		"",
  		5,
  		"",
  		4,
  		"",
  		11,
  		"",
  		5,
  		"",
  		6,
  		"",
  		6,
  		"",
  		6,
  		"",
  		7,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9a41",
  		"",
  		16
  	],
  	[
  		"9a61",
  		"",
  		6,
  		"",
  		6,
  		""
  	],
  	[
  		"9a81",
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		5,
  		"",
  		33,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"9b41",
  		"",
  		6,
  		"",
  		8
  	],
  	[
  		"9b61",
  		"",
  		17,
  		"",
  		7
  	],
  	[
  		"9b81",
  		"",
  		25,
  		"",
  		4,
  		"",
  		5,
  		"",
  		50,
  		"",
  		22,
  		""
  	],
  	[
  		"9c41",
  		"",
  		4,
  		"",
  		5,
  		"",
  		5
  	],
  	[
  		"9c61",
  		"",
  		8,
  		"",
  		6,
  		"",
  		9
  	],
  	[
  		"9c81",
  		"",
  		8,
  		"",
  		6,
  		"",
  		6,
  		"",
  		9,
  		"",
  		26,
  		"",
  		6,
  		"",
  		5,
  		"",
  		18,
  		"",
  		6,
  		"",
  		12
  	],
  	[
  		"9d41",
  		"",
  		13,
  		"",
  		8
  	],
  	[
  		"9d61",
  		"",
  		25
  	],
  	[
  		"9d81",
  		"",
  		8,
  		"",
  		5,
  		"",
  		9,
  		"",
  		6,
  		"",
  		10,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9e41",
  		"",
  		7,
  		"",
  		9,
  		""
  	],
  	[
  		"9e61",
  		"",
  		4,
  		"",
  		6,
  		""
  	],
  	[
  		"9e81",
  		"",
  		6,
  		"",
  		6,
  		"",
  		6,
  		"",
  		5,
  		"",
  		10,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"9f41",
  		"",
  		5,
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"9f61",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"9f81",
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		4,
  		"",
  		6,
  		"",
  		7,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"a041",
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"a061",
  		"",
  		5,
  		"",
  		13
  	],
  	[
  		"a081",
  		"",
  		4,
  		"",
  		4,
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		"",
  		26,
  		"",
  		4,
  		"",
  		5,
  		"",
  		7,
  		""
  	],
  	[
  		"a141",
  		"",
  		18,
  		""
  	],
  	[
  		"a161",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"a181",
  		"",
  		14,
  		"",
  		5,
  		"",
  		4,
  		"",
  		9,
  		""
  	],
  	[
  		"a241",
  		"",
  		5,
  		"",
  		18
  	],
  	[
  		"a261",
  		"",
  		6,
  		"",
  		18
  	],
  	[
  		"a281",
  		"",
  		7,
  		"",
  		6,
  		"",
  		7,
  		""
  	],
  	[
  		"a341",
  		"",
  		6,
  		"",
  		10,
  		""
  	],
  	[
  		"a361",
  		"",
  		6,
  		"",
  		16
  	],
  	[
  		"a381",
  		"",
  		16,
  		"",
  		4,
  		"",
  		58,
  		"",
  		32,
  		""
  	],
  	[
  		"a441",
  		"",
  		5,
  		""
  	],
  	[
  		"a461",
  		"",
  		5,
  		"",
  		12
  	],
  	[
  		"a481",
  		"",
  		28,
  		"",
  		93
  	],
  	[
  		"a541",
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"a561",
  		"",
  		17,
  		"",
  		5,
  		""
  	],
  	[
  		"a581",
  		"",
  		16,
  		"",
  		14,
  		"",
  		9
  	],
  	[
  		"a5b0",
  		"",
  		9
  	],
  	[
  		"a5c1",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"a5e1",
  		"",
  		16,
  		"",
  		6
  	],
  	[
  		"a641",
  		"",
  		19,
  		""
  	],
  	[
  		"a661",
  		"",
  		5,
  		"",
  		5,
  		"",
  		6
  	],
  	[
  		"a681",
  		"",
  		6,
  		"",
  		18,
  		"",
  		7
  	],
  	[
  		"a741",
  		"",
  		4,
  		"",
  		6,
  		"",
  		7
  	],
  	[
  		"a761",
  		"",
  		22,
  		""
  	],
  	[
  		"a781",
  		"",
  		6,
  		"",
  		5,
  		"",
  		7,
  		"",
  		9,
  		"",
  		9,
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"a841",
  		"",
  		10,
  		"",
  		14
  	],
  	[
  		"a861",
  		"",
  		18,
  		"",
  		6
  	],
  	[
  		"a881",
  		"",
  		19,
  		"",
  		11,
  		""
  	],
  	[
  		"a8a6",
  		""
  	],
  	[
  		"a8a8",
  		""
  	],
  	[
  		"a8b1",
  		"",
  		27,
  		"",
  		25,
  		"",
  		14,
  		""
  	],
  	[
  		"a941",
  		"",
  		14,
  		"",
  		10
  	],
  	[
  		"a961",
  		"",
  		18
  	],
  	[
  		"a981",
  		"",
  		14,
  		"",
  		6,
  		"",
  		27,
  		"",
  		25,
  		"",
  		14,
  		""
  	],
  	[
  		"aa41",
  		"",
  		6,
  		"",
  		4,
  		""
  	],
  	[
  		"aa61",
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"aa81",
  		"",
  		29,
  		"",
  		82
  	],
  	[
  		"ab41",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"ab61",
  		"",
  		6,
  		"",
  		5,
  		"",
  		5
  	],
  	[
  		"ab81",
  		"",
  		8,
  		"",
  		6,
  		"",
  		12,
  		"",
  		85
  	],
  	[
  		"ac41",
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"ac61",
  		"",
  		11,
  		"",
  		4
  	],
  	[
  		"ac81",
  		"",
  		28,
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"acd1",
  		"",
  		5,
  		"",
  		25
  	],
  	[
  		"ad41",
  		"",
  		6,
  		"",
  		5,
  		"",
  		7
  	],
  	[
  		"ad61",
  		"",
  		6,
  		"",
  		10,
  		""
  	],
  	[
  		"ad81",
  		"",
  		5,
  		"",
  		18,
  		""
  	],
  	[
  		"ae41",
  		"",
  		5,
  		"",
  		16
  	],
  	[
  		"ae61",
  		"",
  		5,
  		"",
  		6,
  		"",
  		4
  	],
  	[
  		"ae81",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"af41",
  		"",
  		19
  	],
  	[
  		"af61",
  		"",
  		13,
  		"",
  		5,
  		""
  	],
  	[
  		"af81",
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"b041",
  		"",
  		5,
  		"",
  		5,
  		"",
  		12
  	],
  	[
  		"b061",
  		"",
  		5,
  		"",
  		19
  	],
  	[
  		"b081",
  		"",
  		13,
  		"",
  		6,
  		"",
  		5,
  		"",
  		7,
  		"",
  		4,
  		""
  	],
  	[
  		"b141",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"b161",
  		"",
  		6,
  		"",
  		5,
  		"",
  		11
  	],
  	[
  		"b181",
  		"",
  		14,
  		"",
  		6,
  		""
  	],
  	[
  		"b241",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"b261",
  		"",
  		18,
  		"",
  		5,
  		""
  	],
  	[
  		"b281",
  		"",
  		5,
  		"",
  		18,
  		"",
  		6,
  		""
  	],
  	[
  		"b341",
  		"",
  		19,
  		""
  	],
  	[
  		"b361",
  		"",
  		5,
  		"",
  		5,
  		"",
  		5
  	],
  	[
  		"b381",
  		"",
  		5,
  		"",
  		5,
  		"",
  		19,
  		"",
  		4,
  		""
  	],
  	[
  		"b441",
  		"",
  		5,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"b461",
  		"",
  		6,
  		"",
  		10,
  		""
  	],
  	[
  		"b481",
  		"",
  		6,
  		"",
  		18,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"b541",
  		"",
  		14,
  		"",
  		5
  	],
  	[
  		"b561",
  		"",
  		5,
  		"",
  		5,
  		"",
  		4
  	],
  	[
  		"b581",
  		"",
  		6,
  		"",
  		5,
  		"",
  		11,
  		""
  	],
  	[
  		"b641",
  		"",
  		7,
  		"",
  		17
  	],
  	[
  		"b661",
  		"",
  		15,
  		""
  	],
  	[
  		"b681",
  		"",
  		5,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"b741",
  		"",
  		13,
  		"",
  		6,
  		""
  	],
  	[
  		"b761",
  		"",
  		20,
  		""
  	],
  	[
  		"b781",
  		"",
  		6,
  		"",
  		14,
  		""
  	],
  	[
  		"b841",
  		"",
  		7,
  		"",
  		17
  	],
  	[
  		"b861",
  		"",
  		8,
  		"",
  		13
  	],
  	[
  		"b881",
  		"",
  		5,
  		"",
  		24,
  		"",
  		4,
  		""
  	],
  	[
  		"b941",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"b961",
  		"",
  		14,
  		"",
  		6,
  		""
  	],
  	[
  		"b981",
  		"",
  		22,
  		"",
  		4,
  		"",
  		4,
  		""
  	],
  	[
  		"ba41",
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"ba61",
  		"",
  		5,
  		"",
  		4,
  		"",
  		5
  	],
  	[
  		"ba81",
  		"",
  		6,
  		"",
  		9,
  		""
  	],
  	[
  		"bb41",
  		"",
  		4,
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"bb61",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"bb81",
  		"",
  		31,
  		""
  	],
  	[
  		"bc41",
  		"",
  		17,
  		""
  	],
  	[
  		"bc61",
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"bc81",
  		"",
  		4,
  		"",
  		6,
  		"",
  		5,
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"bd41",
  		"",
  		7,
  		"",
  		7,
  		""
  	],
  	[
  		"bd61",
  		"",
  		5,
  		"",
  		13
  	],
  	[
  		"bd81",
  		"",
  		5,
  		"",
  		25,
  		""
  	],
  	[
  		"be41",
  		"",
  		7,
  		"",
  		14
  	],
  	[
  		"be61",
  		"",
  		7,
  		"",
  		7,
  		""
  	],
  	[
  		"be81",
  		"",
  		4,
  		"",
  		4,
  		"",
  		5,
  		"",
  		8,
  		"",
  		6,
  		""
  	],
  	[
  		"bf41",
  		"",
  		10,
  		"",
  		14
  	],
  	[
  		"bf61",
  		"",
  		18,
  		""
  	],
  	[
  		"bf81",
  		"",
  		5,
  		"",
  		7,
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"c041",
  		"",
  		5,
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"c061",
  		"",
  		25
  	],
  	[
  		"c081",
  		"",
  		6,
  		"",
  		5,
  		"",
  		7,
  		""
  	],
  	[
  		"c141",
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"c161",
  		"",
  		19,
  		""
  	],
  	[
  		"c181",
  		"",
  		31,
  		""
  	],
  	[
  		"c241",
  		"",
  		4,
  		"",
  		5,
  		""
  	],
  	[
  		"c261",
  		"",
  		4,
  		"",
  		5,
  		"",
  		6,
  		""
  	],
  	[
  		"c281",
  		"",
  		5,
  		"",
  		7,
  		"",
  		9,
  		""
  	],
  	[
  		"c341",
  		"",
  		4
  	],
  	[
  		"c361",
  		"",
  		4,
  		"",
  		5,
  		"",
  		11
  	],
  	[
  		"c381",
  		"",
  		5,
  		"",
  		7,
  		"",
  		5,
  		""
  	],
  	[
  		"c441",
  		"",
  		7,
  		"",
  		7,
  		""
  	],
  	[
  		"c461",
  		"",
  		5,
  		"",
  		4
  	],
  	[
  		"c481",
  		"",
  		5,
  		"",
  		11,
  		""
  	],
  	[
  		"c541",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"c561",
  		"",
  		6,
  		"",
  		5,
  		"",
  		4
  	],
  	[
  		"c581",
  		"",
  		6,
  		"",
  		5,
  		""
  	],
  	[
  		"c641",
  		"",
  		6,
  		"",
  		5
  	],
  	[
  		"c6a1",
  		""
  	],
  	[
  		"c7a1",
  		""
  	],
  	[
  		"c8a1",
  		""
  	],
  	[
  		"caa1",
  		""
  	],
  	[
  		"cba1",
  		""
  	],
  	[
  		"cca1",
  		""
  	],
  	[
  		"cda1",
  		""
  	],
  	[
  		"cea1",
  		""
  	],
  	[
  		"cfa1",
  		""
  	],
  	[
  		"d0a1",
  		""
  	],
  	[
  		"d1a1",
  		"",
  		5,
  		"",
  		4,
  		""
  	],
  	[
  		"d2a1",
  		"",
  		4,
  		"",
  		5,
  		"",
  		10,
  		"",
  		7,
  		"",
  		5,
  		""
  	],
  	[
  		"d3a1",
  		""
  	],
  	[
  		"d4a1",
  		""
  	],
  	[
  		"d5a1",
  		""
  	],
  	[
  		"d6a1",
  		""
  	],
  	[
  		"d7a1",
  		""
  	],
  	[
  		"d8a1",
  		""
  	],
  	[
  		"d9a1",
  		""
  	],
  	[
  		"daa1",
  		""
  	],
  	[
  		"dba1",
  		""
  	],
  	[
  		"dca1",
  		""
  	],
  	[
  		"dda1",
  		""
  	],
  	[
  		"dea1",
  		""
  	],
  	[
  		"dfa1",
  		""
  	],
  	[
  		"e0a1",
  		""
  	],
  	[
  		"e1a1",
  		""
  	],
  	[
  		"e2a1",
  		""
  	],
  	[
  		"e3a1",
  		""
  	],
  	[
  		"e4a1",
  		""
  	],
  	[
  		"e5a1",
  		""
  	],
  	[
  		"e6a1",
  		""
  	],
  	[
  		"e7a1",
  		""
  	],
  	[
  		"e8a1",
  		""
  	],
  	[
  		"e9a1",
  		""
  	],
  	[
  		"eaa1",
  		""
  	],
  	[
  		"eba1",
  		""
  	],
  	[
  		"eca1",
  		""
  	],
  	[
  		"eda1",
  		""
  	],
  	[
  		"eea1",
  		""
  	],
  	[
  		"efa1",
  		""
  	],
  	[
  		"f0a1",
  		""
  	],
  	[
  		"f1a1",
  		""
  	],
  	[
  		"f2a1",
  		""
  	],
  	[
  		"f3a1",
  		""
  	],
  	[
  		"f4a1",
  		""
  	],
  	[
  		"f5a1",
  		""
  	],
  	[
  		"f6a1",
  		""
  	],
  	[
  		"f7a1",
  		""
  	],
  	[
  		"f8a1",
  		""
  	],
  	[
  		"f9a1",
  		""
  	],
  	[
  		"faa1",
  		""
  	],
  	[
  		"fba1",
  		""
  	],
  	[
  		"fca1",
  		""
  	],
  	[
  		"fda1",
  		""
  	]
  ];

  var require$$6 = [
  	[
  		"0",
  		"\u0000",
  		127
  	],
  	[
  		"a140",
  		""
  	],
  	[
  		"a1a1",
  		"",
  		4,
  		""
  	],
  	[
  		"a240",
  		"",
  		7,
  		""
  	],
  	[
  		"a2a1",
  		"",
  		9,
  		"",
  		9,
  		"",
  		8,
  		"",
  		25,
  		"",
  		21
  	],
  	[
  		"a340",
  		"",
  		16,
  		"",
  		6,
  		"",
  		16,
  		"",
  		6,
  		"",
  		10
  	],
  	[
  		"a3a1",
  		"",
  		25,
  		""
  	],
  	[
  		"a3e1",
  		""
  	],
  	[
  		"a440",
  		""
  	],
  	[
  		"a4a1",
  		""
  	],
  	[
  		"a540",
  		""
  	],
  	[
  		"a5a1",
  		""
  	],
  	[
  		"a640",
  		""
  	],
  	[
  		"a6a1",
  		""
  	],
  	[
  		"a740",
  		""
  	],
  	[
  		"a7a1",
  		""
  	],
  	[
  		"a840",
  		""
  	],
  	[
  		"a8a1",
  		""
  	],
  	[
  		"a940",
  		""
  	],
  	[
  		"a9a1",
  		""
  	],
  	[
  		"aa40",
  		""
  	],
  	[
  		"aaa1",
  		""
  	],
  	[
  		"ab40",
  		""
  	],
  	[
  		"aba1",
  		""
  	],
  	[
  		"ac40",
  		""
  	],
  	[
  		"aca1",
  		""
  	],
  	[
  		"ad40",
  		""
  	],
  	[
  		"ada1",
  		""
  	],
  	[
  		"ae40",
  		""
  	],
  	[
  		"aea1",
  		""
  	],
  	[
  		"af40",
  		""
  	],
  	[
  		"afa1",
  		""
  	],
  	[
  		"b040",
  		""
  	],
  	[
  		"b0a1",
  		""
  	],
  	[
  		"b140",
  		""
  	],
  	[
  		"b1a1",
  		""
  	],
  	[
  		"b240",
  		""
  	],
  	[
  		"b2a1",
  		""
  	],
  	[
  		"b340",
  		""
  	],
  	[
  		"b3a1",
  		""
  	],
  	[
  		"b440",
  		""
  	],
  	[
  		"b4a1",
  		""
  	],
  	[
  		"b540",
  		""
  	],
  	[
  		"b5a1",
  		""
  	],
  	[
  		"b640",
  		""
  	],
  	[
  		"b6a1",
  		""
  	],
  	[
  		"b740",
  		""
  	],
  	[
  		"b7a1",
  		""
  	],
  	[
  		"b840",
  		""
  	],
  	[
  		"b8a1",
  		""
  	],
  	[
  		"b940",
  		""
  	],
  	[
  		"b9a1",
  		""
  	],
  	[
  		"ba40",
  		""
  	],
  	[
  		"baa1",
  		""
  	],
  	[
  		"bb40",
  		""
  	],
  	[
  		"bba1",
  		""
  	],
  	[
  		"bc40",
  		""
  	],
  	[
  		"bca1",
  		""
  	],
  	[
  		"bd40",
  		""
  	],
  	[
  		"bda1",
  		""
  	],
  	[
  		"be40",
  		""
  	],
  	[
  		"bea1",
  		""
  	],
  	[
  		"bf40",
  		""
  	],
  	[
  		"bfa1",
  		""
  	],
  	[
  		"c040",
  		""
  	],
  	[
  		"c0a1",
  		""
  	],
  	[
  		"c140",
  		""
  	],
  	[
  		"c1a1",
  		""
  	],
  	[
  		"c240",
  		""
  	],
  	[
  		"c2a1",
  		""
  	],
  	[
  		"c340",
  		""
  	],
  	[
  		"c3a1",
  		""
  	],
  	[
  		"c440",
  		""
  	],
  	[
  		"c4a1",
  		""
  	],
  	[
  		"c540",
  		""
  	],
  	[
  		"c5a1",
  		""
  	],
  	[
  		"c640",
  		""
  	],
  	[
  		"c940",
  		""
  	],
  	[
  		"c9a1",
  		""
  	],
  	[
  		"ca40",
  		""
  	],
  	[
  		"caa1",
  		""
  	],
  	[
  		"cb40",
  		""
  	],
  	[
  		"cba1",
  		""
  	],
  	[
  		"cc40",
  		""
  	],
  	[
  		"cca1",
  		""
  	],
  	[
  		"cd40",
  		""
  	],
  	[
  		"cda1",
  		""
  	],
  	[
  		"ce40",
  		""
  	],
  	[
  		"cea1",
  		""
  	],
  	[
  		"cf40",
  		""
  	],
  	[
  		"cfa1",
  		""
  	],
  	[
  		"d040",
  		""
  	],
  	[
  		"d0a1",
  		""
  	],
  	[
  		"d140",
  		""
  	],
  	[
  		"d1a1",
  		""
  	],
  	[
  		"d240",
  		""
  	],
  	[
  		"d2a1",
  		""
  	],
  	[
  		"d340",
  		""
  	],
  	[
  		"d3a1",
  		""
  	],
  	[
  		"d440",
  		""
  	],
  	[
  		"d4a1",
  		""
  	],
  	[
  		"d540",
  		""
  	],
  	[
  		"d5a1",
  		""
  	],
  	[
  		"d640",
  		""
  	],
  	[
  		"d6a1",
  		""
  	],
  	[
  		"d740",
  		""
  	],
  	[
  		"d7a1",
  		""
  	],
  	[
  		"d840",
  		""
  	],
  	[
  		"d8a1",
  		""
  	],
  	[
  		"d940",
  		""
  	],
  	[
  		"d9a1",
  		""
  	],
  	[
  		"da40",
  		""
  	],
  	[
  		"daa1",
  		""
  	],
  	[
  		"db40",
  		""
  	],
  	[
  		"dba1",
  		""
  	],
  	[
  		"dc40",
  		""
  	],
  	[
  		"dca1",
  		""
  	],
  	[
  		"dd40",
  		""
  	],
  	[
  		"dda1",
  		""
  	],
  	[
  		"de40",
  		""
  	],
  	[
  		"dea1",
  		""
  	],
  	[
  		"df40",
  		""
  	],
  	[
  		"dfa1",
  		""
  	],
  	[
  		"e040",
  		""
  	],
  	[
  		"e0a1",
  		""
  	],
  	[
  		"e140",
  		""
  	],
  	[
  		"e1a1",
  		""
  	],
  	[
  		"e240",
  		""
  	],
  	[
  		"e2a1",
  		""
  	],
  	[
  		"e340",
  		""
  	],
  	[
  		"e3a1",
  		""
  	],
  	[
  		"e440",
  		""
  	],
  	[
  		"e4a1",
  		""
  	],
  	[
  		"e540",
  		""
  	],
  	[
  		"e5a1",
  		""
  	],
  	[
  		"e640",
  		""
  	],
  	[
  		"e6a1",
  		""
  	],
  	[
  		"e740",
  		""
  	],
  	[
  		"e7a1",
  		""
  	],
  	[
  		"e840",
  		""
  	],
  	[
  		"e8a1",
  		""
  	],
  	[
  		"e940",
  		""
  	],
  	[
  		"e9a1",
  		""
  	],
  	[
  		"ea40",
  		""
  	],
  	[
  		"eaa1",
  		""
  	],
  	[
  		"eb40",
  		""
  	],
  	[
  		"eba1",
  		""
  	],
  	[
  		"ec40",
  		""
  	],
  	[
  		"eca1",
  		""
  	],
  	[
  		"ed40",
  		""
  	],
  	[
  		"eda1",
  		""
  	],
  	[
  		"ee40",
  		""
  	],
  	[
  		"eea1",
  		""
  	],
  	[
  		"ef40",
  		""
  	],
  	[
  		"efa1",
  		""
  	],
  	[
  		"f040",
  		""
  	],
  	[
  		"f0a1",
  		""
  	],
  	[
  		"f140",
  		""
  	],
  	[
  		"f1a1",
  		""
  	],
  	[
  		"f240",
  		""
  	],
  	[
  		"f2a1",
  		""
  	],
  	[
  		"f340",
  		""
  	],
  	[
  		"f3a1",
  		""
  	],
  	[
  		"f440",
  		""
  	],
  	[
  		"f4a1",
  		""
  	],
  	[
  		"f540",
  		""
  	],
  	[
  		"f5a1",
  		""
  	],
  	[
  		"f640",
  		""
  	],
  	[
  		"f6a1",
  		""
  	],
  	[
  		"f740",
  		""
  	],
  	[
  		"f7a1",
  		""
  	],
  	[
  		"f840",
  		""
  	],
  	[
  		"f8a1",
  		""
  	],
  	[
  		"f940",
  		""
  	],
  	[
  		"f9a1",
  		""
  	]
  ];

  var require$$7 = [
  	[
  		"8740",
  		""
  	],
  	[
  		"8767",
  		""
  	],
  	[
  		"87a1",
  		""
  	],
  	[
  		"8840",
  		"",
  		4,
  		""
  	],
  	[
  		"88a1",
  		""
  	],
  	[
  		"8940",
  		""
  	],
  	[
  		"8943",
  		""
  	],
  	[
  		"8946",
  		""
  	],
  	[
  		"894c",
  		""
  	],
  	[
  		"89a1",
  		""
  	],
  	[
  		"89ab",
  		""
  	],
  	[
  		"89b0",
  		""
  	],
  	[
  		"89b5",
  		""
  	],
  	[
  		"89c1",
  		""
  	],
  	[
  		"89c5",
  		""
  	],
  	[
  		"8a40",
  		""
  	],
  	[
  		"8a43",
  		""
  	],
  	[
  		"8a64",
  		""
  	],
  	[
  		"8a76",
  		""
  	],
  	[
  		"8aa1",
  		""
  	],
  	[
  		"8aac",
  		""
  	],
  	[
  		"8ab2",
  		""
  	],
  	[
  		"8abb",
  		""
  	],
  	[
  		"8ac9",
  		""
  	],
  	[
  		"8ace",
  		""
  	],
  	[
  		"8adf",
  		""
  	],
  	[
  		"8af6",
  		""
  	],
  	[
  		"8b40",
  		""
  	],
  	[
  		"8b55",
  		""
  	],
  	[
  		"8ba1",
  		""
  	],
  	[
  		"8bde",
  		""
  	],
  	[
  		"8c40",
  		""
  	],
  	[
  		"8ca1",
  		""
  	],
  	[
  		"8ca7",
  		""
  	],
  	[
  		"8cc9",
  		""
  	],
  	[
  		"8cce",
  		""
  	],
  	[
  		"8ce6",
  		""
  	],
  	[
  		"8d40",
  		""
  	],
  	[
  		"8d42",
  		""
  	],
  	[
  		"8da1",
  		""
  	],
  	[
  		"8e40",
  		""
  	],
  	[
  		"8ea1",
  		""
  	],
  	[
  		"8f40",
  		""
  	],
  	[
  		"8fa1",
  		""
  	],
  	[
  		"9040",
  		""
  	],
  	[
  		"90a1",
  		""
  	],
  	[
  		"9140",
  		""
  	],
  	[
  		"91a1",
  		""
  	],
  	[
  		"9240",
  		""
  	],
  	[
  		"92a1",
  		""
  	],
  	[
  		"9340",
  		""
  	],
  	[
  		"93a1",
  		""
  	],
  	[
  		"9440",
  		""
  	],
  	[
  		"94a1",
  		""
  	],
  	[
  		"9540",
  		""
  	],
  	[
  		"95a1",
  		""
  	],
  	[
  		"9640",
  		""
  	],
  	[
  		"96a1",
  		""
  	],
  	[
  		"9740",
  		""
  	],
  	[
  		"97a1",
  		""
  	],
  	[
  		"9840",
  		""
  	],
  	[
  		"98a1",
  		""
  	],
  	[
  		"9940",
  		""
  	],
  	[
  		"99a1",
  		""
  	],
  	[
  		"9a40",
  		""
  	],
  	[
  		"9aa1",
  		""
  	],
  	[
  		"9b40",
  		""
  	],
  	[
  		"9b62",
  		""
  	],
  	[
  		"9ba1",
  		""
  	],
  	[
  		"9c40",
  		""
  	],
  	[
  		"9ca1",
  		""
  	],
  	[
  		"9d40",
  		""
  	],
  	[
  		"9da1",
  		""
  	],
  	[
  		"9e40",
  		""
  	],
  	[
  		"9ea1",
  		""
  	],
  	[
  		"9ead",
  		""
  	],
  	[
  		"9ec5",
  		""
  	],
  	[
  		"9ef5",
  		""
  	],
  	[
  		"9f40",
  		""
  	],
  	[
  		"9f4f",
  		""
  	],
  	[
  		"9fa1",
  		""
  	],
  	[
  		"9fae",
  		""
  	],
  	[
  		"9fb2",
  		""
  	],
  	[
  		"9fc1",
  		""
  	],
  	[
  		"9fc9",
  		""
  	],
  	[
  		"9fdb",
  		""
  	],
  	[
  		"9fe7",
  		""
  	],
  	[
  		"9feb",
  		""
  	],
  	[
  		"9ff0",
  		""
  	],
  	[
  		"a040",
  		""
  	],
  	[
  		"a055",
  		""
  	],
  	[
  		"a058",
  		""
  	],
  	[
  		"a05b",
  		""
  	],
  	[
  		"a063",
  		""
  	],
  	[
  		"a073",
  		""
  	],
  	[
  		"a0a1",
  		""
  	],
  	[
  		"a0a6",
  		""
  	],
  	[
  		"a0ae",
  		""
  	],
  	[
  		"a0b0",
  		""
  	],
  	[
  		"a0d4",
  		""
  	],
  	[
  		"a0e2",
  		""
  	],
  	[
  		"a3c0",
  		"",
  		31,
  		""
  	],
  	[
  		"c6a1",
  		"",
  		9,
  		"",
  		9,
  		"",
  		9,
  		"",
  		23
  	],
  	[
  		"c740",
  		"",
  		58,
  		""
  	],
  	[
  		"c7a1",
  		"",
  		81,
  		"",
  		5,
  		"",
  		4
  	],
  	[
  		"c840",
  		"",
  		26,
  		"",
  		25,
  		""
  	],
  	[
  		"c8a1",
  		""
  	],
  	[
  		"c8cd",
  		""
  	],
  	[
  		"c8f5",
  		""
  	],
  	[
  		"f9fe",
  		""
  	],
  	[
  		"fa40",
  		""
  	],
  	[
  		"faa1",
  		""
  	],
  	[
  		"fb40",
  		""
  	],
  	[
  		"fba1",
  		""
  	],
  	[
  		"fc40",
  		""
  	],
  	[
  		"fca1",
  		""
  	],
  	[
  		"fd40",
  		""
  	],
  	[
  		"fda1",
  		""
  	],
  	[
  		"fe40",
  		""
  	],
  	[
  		"fea1",
  		""
  	]
  ];

  var dbcsData;
  var hasRequiredDbcsData;

  function requireDbcsData () {
  	if (hasRequiredDbcsData) return dbcsData;
  	hasRequiredDbcsData = 1;

  	// Description of supported double byte encodings and aliases.
  	// Tables are not require()-d until they are needed to speed up library load.
  	// require()-s are direct to support Browserify.

  	dbcsData = {
  	    
  	    // == Japanese/ShiftJIS ====================================================
  	    // All japanese encodings are based on JIS X set of standards:
  	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
  	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
  	    //              Has several variations in 1978, 1983, 1990 and 1997.
  	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
  	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
  	    //              2 planes, first is superset of 0208, second - revised 0212.
  	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

  	    // Byte encodings are:
  	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
  	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
  	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
  	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
  	    //               0x00-0x7F       - lower part of 0201
  	    //               0x8E, 0xA1-0xDF - upper part of 0201
  	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
  	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
  	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
  	    //               Used as-is in ISO2022 family.
  	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
  	    //                0201-1976 Roman, 0208-1978, 0208-1983.
  	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
  	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
  	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
  	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
  	    //
  	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
  	    //
  	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

  	    'shiftjis': {
  	        type: '_dbcs',
  	        table: function() { return require$$0 },
  	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
  	        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
  	    },
  	    'csshiftjis': 'shiftjis',
  	    'mskanji': 'shiftjis',
  	    'sjis': 'shiftjis',
  	    'windows31j': 'shiftjis',
  	    'ms31j': 'shiftjis',
  	    'xsjis': 'shiftjis',
  	    'windows932': 'shiftjis',
  	    'ms932': 'shiftjis',
  	    '932': 'shiftjis',
  	    'cp932': 'shiftjis',

  	    'eucjp': {
  	        type: '_dbcs',
  	        table: function() { return require$$1 },
  	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
  	    },

  	    // TODO: KDDI extension to Shift_JIS
  	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
  	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


  	    // == Chinese/GBK ==========================================================
  	    // http://en.wikipedia.org/wiki/GBK
  	    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

  	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
  	    'gb2312': 'cp936',
  	    'gb231280': 'cp936',
  	    'gb23121980': 'cp936',
  	    'csgb2312': 'cp936',
  	    'csiso58gb231280': 'cp936',
  	    'euccn': 'cp936',

  	    // Microsoft's CP936 is a subset and approximation of GBK.
  	    'windows936': 'cp936',
  	    'ms936': 'cp936',
  	    '936': 'cp936',
  	    'cp936': {
  	        type: '_dbcs',
  	        table: function() { return require$$2 },
  	    },

  	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
  	    'gbk': {
  	        type: '_dbcs',
  	        table: function() { return require$$2.concat(require$$3) },
  	    },
  	    'xgbk': 'gbk',
  	    'isoir58': 'gbk',

  	    // GB18030 is an algorithmic extension of GBK.
  	    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
  	    // http://icu-project.org/docs/papers/gb18030.html
  	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
  	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
  	    'gb18030': {
  	        type: '_dbcs',
  	        table: function() { return require$$2.concat(require$$3) },
  	        gb18030: function() { return require$$4$1 },
  	        encodeSkipVals: [0x80],
  	        encodeAdd: {'': 0xA2E3},
  	    },

  	    'chinese': 'gb18030',


  	    // == Korean ===============================================================
  	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
  	    'windows949': 'cp949',
  	    'ms949': 'cp949',
  	    '949': 'cp949',
  	    'cp949': {
  	        type: '_dbcs',
  	        table: function() { return require$$5 },
  	    },

  	    'cseuckr': 'cp949',
  	    'csksc56011987': 'cp949',
  	    'euckr': 'cp949',
  	    'isoir149': 'cp949',
  	    'korean': 'cp949',
  	    'ksc56011987': 'cp949',
  	    'ksc56011989': 'cp949',
  	    'ksc5601': 'cp949',


  	    // == Big5/Taiwan/Hong Kong ================================================
  	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
  	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
  	    // Variations, in roughly number of defined chars:
  	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
  	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
  	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
  	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
  	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
  	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
  	    //    Plus, it has 4 combining sequences.
  	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
  	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
  	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
  	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
  	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
  	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
  	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
  	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
  	    // 
  	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
  	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

  	    'windows950': 'cp950',
  	    'ms950': 'cp950',
  	    '950': 'cp950',
  	    'cp950': {
  	        type: '_dbcs',
  	        table: function() { return require$$6 },
  	    },

  	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
  	    'big5': 'big5hkscs',
  	    'big5hkscs': {
  	        type: '_dbcs',
  	        table: function() { return require$$6.concat(require$$7) },
  	        encodeSkipVals: [
  	            // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
  	            // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
  	            // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
  	            0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe,
  	            0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca,
  	            0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62,
  	            0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef,
  	            0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,

  	            // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
  	            0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce,
  	        ],
  	    },

  	    'cnbig5': 'big5hkscs',
  	    'csbig5': 'big5hkscs',
  	    'xxbig5': 'big5hkscs',
  	};
  	return dbcsData;
  }

  var hasRequiredEncodings;

  function requireEncodings () {
  	if (hasRequiredEncodings) return encodings;
  	hasRequiredEncodings = 1;
  	(function (exports) {

  		// Update this array if you add/rename/remove files in this directory.
  		// We support Browserify by skipping automatic module discovery and requiring modules directly.
  		var modules = [
  		    requireInternal(),
  		    requireUtf32(),
  		    requireUtf16(),
  		    requireUtf7(),
  		    requireSbcsCodec(),
  		    requireSbcsData(),
  		    requireSbcsDataGenerated(),
  		    requireDbcsCodec(),
  		    requireDbcsData(),
  		];

  		// Put all encoding/alias/codec definitions to single object and export it.
  		for (var i = 0; i < modules.length; i++) {
  		    var module = modules[i];
  		    for (var enc in module)
  		        if (Object.prototype.hasOwnProperty.call(module, enc))
  		            exports[enc] = module[enc];
  		} 
  	} (encodings));
  	return encodings;
  }

  var streams;
  var hasRequiredStreams;

  function requireStreams () {
  	if (hasRequiredStreams) return streams;
  	hasRequiredStreams = 1;

  	var Buffer = requireSafer().Buffer;

  	// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
  	// we opt to dependency-inject it instead of creating a hard dependency.
  	streams = function(stream_module) {
  	    var Transform = stream_module.Transform;

  	    // == Encoder stream =======================================================

  	    function IconvLiteEncoderStream(conv, options) {
  	        this.conv = conv;
  	        options = options || {};
  	        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
  	        Transform.call(this, options);
  	    }

  	    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
  	        constructor: { value: IconvLiteEncoderStream }
  	    });

  	    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
  	        if (typeof chunk != 'string')
  	            return done(new Error("Iconv encoding stream needs strings as its input."));
  	        try {
  	            var res = this.conv.write(chunk);
  	            if (res && res.length) this.push(res);
  	            done();
  	        }
  	        catch (e) {
  	            done(e);
  	        }
  	    };

  	    IconvLiteEncoderStream.prototype._flush = function(done) {
  	        try {
  	            var res = this.conv.end();
  	            if (res && res.length) this.push(res);
  	            done();
  	        }
  	        catch (e) {
  	            done(e);
  	        }
  	    };

  	    IconvLiteEncoderStream.prototype.collect = function(cb) {
  	        var chunks = [];
  	        this.on('error', cb);
  	        this.on('data', function(chunk) { chunks.push(chunk); });
  	        this.on('end', function() {
  	            cb(null, Buffer.concat(chunks));
  	        });
  	        return this;
  	    };


  	    // == Decoder stream =======================================================

  	    function IconvLiteDecoderStream(conv, options) {
  	        this.conv = conv;
  	        options = options || {};
  	        options.encoding = this.encoding = 'utf8'; // We output strings.
  	        Transform.call(this, options);
  	    }

  	    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
  	        constructor: { value: IconvLiteDecoderStream }
  	    });

  	    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
  	        if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array))
  	            return done(new Error("Iconv decoding stream needs buffers as its input."));
  	        try {
  	            var res = this.conv.write(chunk);
  	            if (res && res.length) this.push(res, this.encoding);
  	            done();
  	        }
  	        catch (e) {
  	            done(e);
  	        }
  	    };

  	    IconvLiteDecoderStream.prototype._flush = function(done) {
  	        try {
  	            var res = this.conv.end();
  	            if (res && res.length) this.push(res, this.encoding);                
  	            done();
  	        }
  	        catch (e) {
  	            done(e);
  	        }
  	    };

  	    IconvLiteDecoderStream.prototype.collect = function(cb) {
  	        var res = '';
  	        this.on('error', cb);
  	        this.on('data', function(chunk) { res += chunk; });
  	        this.on('end', function() {
  	            cb(null, res);
  	        });
  	        return this;
  	    };

  	    return {
  	        IconvLiteEncoderStream: IconvLiteEncoderStream,
  	        IconvLiteDecoderStream: IconvLiteDecoderStream,
  	    };
  	};
  	return streams;
  }

  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function (v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function (v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function () {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function () {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function (s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function (n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      p.data.copy(ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  Readable.ReadableState = ReadableState;

  var debug$2 = debuglog('stream');
  inherits$1(Readable, EventEmitter$7);

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') {
      return emitter.prependListener(event, fn);
    } else {
      // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount (emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState(options, stream) {

    options = options || {};

    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // when piping, we only care about 'readable' events that happen
    // after read()ing all the bytes and not getting any pushback.
    this.ranOut = false;

    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;

    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;

    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {

    if (!(this instanceof Readable)) return new Readable(options);

    this._readableState = new ReadableState(options, this);

    // legacy
    this.readable = true;

    if (options && typeof options.read === 'function') this._read = options.read;

    EventEmitter$7.call(this);
  }

  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;

    if (!state.objectMode && typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
    }

    return readableAddChunk(this, state, chunk, encoding, false);
  };

  // Unshift should *always* be something directly out of read()
  Readable.prototype.unshift = function (chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, '', true);
  };

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };

  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error('stream.push() after EOF');
        stream.emit('error', e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error('stream.unshift() after end event');
        stream.emit('error', _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }

        if (!addToFront) state.reading = false;

        // Don't add to the buffer if we've decoded to an empty string chunk and
        // we're not in object mode
        if (!skipAdd) {
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

            if (state.needReadable) emitReadable(stream);
          }
        }

        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }

    return needMoreData(state);
  }

  // if it's past the high water mark, we can push in some more.
  // Also, if we have no data yet, we can stand some
  // more bytes.  This is to work around cases where hwm=0,
  // such as the repl.  Also, if the push() triggered a
  // readable event, and the user called read(largeNumber) such that
  // needReadable was set, then we ought to push more, so that another
  // 'readable' event will be triggered.
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }

  // backwards compatibility.
  Readable.prototype.setEncoding = function (enc) {
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };

  // Don't raise the hwm > 8MB
  var MAX_HWM = 0x800000;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }

  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }

  // you can override either this method, or the async _read(n) below.
  Readable.prototype.read = function (n) {
    debug$2('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;

    if (n !== 0) state.emittedReadable = false;

    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug$2('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state);

    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug$2('need readable', doRead);

    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug$2('length less than watermark', doRead);
    }

    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      debug$2('reading or ended', doRead);
    } else if (doRead) {
      debug$2('do read');
      state.reading = true;
      state.sync = true;
      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true;
      // call internal read method
      this._read(state.highWaterMark);
      state.sync = false;
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true;

      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);

    return ret;
  };

  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    return er;
  }

  function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;

    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
  }

  // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug$2('emitReadable', state.flowing);
      state.emittedReadable = true;
      if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
    }
  }

  function emitReadable_(stream) {
    debug$2('emit readable');
    stream.emit('readable');
    flow(stream);
  }

  // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug$2('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length)
        // didn't get any data, stop spinning.
        break;else len = state.length;
    }
    state.readingMore = false;
  }

  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  Readable.prototype._read = function (n) {
    this.emit('error', new Error('not implemented'));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug$2('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

    var doEnd = (!pipeOpts || pipeOpts.end !== false);

    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

    dest.on('unpipe', onunpipe);
    function onunpipe(readable) {
      debug$2('onunpipe');
      if (readable === src) {
        cleanup();
      }
    }

    function onend() {
      debug$2('onend');
      dest.end();
    }

    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);

    var cleanedUp = false;
    function cleanup() {
      debug$2('cleanup');
      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', cleanup);
      src.removeListener('data', ondata);

      cleanedUp = true;

      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on('data', ondata);
    function ondata(chunk) {
      debug$2('ondata');
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug$2('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }

    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      debug$2('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
    }

    // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
      debug$2('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }
    dest.once('finish', onfinish);

    function unpipe() {
      debug$2('unpipe');
      src.unpipe(dest);
    }

    // tell the dest that it's being piped to
    dest.emit('pipe', src);

    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      debug$2('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function () {
      var state = src._readableState;
      debug$2('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners('data').length) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;

    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;

    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;

      if (!dest) dest = state.pipes;

      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this);
      return this;
    }

    // slow case. multiple pipe destinations.

    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit('unpipe', this);
      }return this;
    }

    // try to find the right one.
    var i = indexOf(state.pipes, dest);
    if (i === -1) return this;

    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];

    dest.emit('unpipe', this);

    return this;
  };

  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  Readable.prototype.on = function (ev, fn) {
    var res = EventEmitter$7.prototype.on.call(this, ev, fn);

    if (ev === 'data') {
      // Start flowing on next tick if stream isn't explicitly paused
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }

    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;

  function nReadingNextTick(self) {
    debug$2('readable nexttick read 0');
    self.read(0);
  }

  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
      debug$2('resume');
      state.flowing = true;
      resume$1(this, state);
    }
    return this;
  };

  function resume$1(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    if (!state.reading) {
      debug$2('resume read 0');
      stream.read(0);
    }

    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug$2('call pause flowing=%j', this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug$2('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug$2('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }

  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  Readable.prototype.wrap = function (stream) {
    var state = this._readableState;
    var paused = false;

    var self = this;
    stream.on('end', function () {
      debug$2('wrapped end');
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) self.push(chunk);
      }

      self.push(null);
    });

    stream.on('data', function (chunk) {
      debug$2('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk);

      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = self.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });

    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function (method) {
          return function () {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }

    // proxy certain important events.
    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
    forEach(events, function (ev) {
      stream.on(ev, self.emit.bind(self, ev));
    });

    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    self._read = function (n) {
      debug$2('wrapped _read', n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return self;
  };

  // exposed for testing purposes only.
  Readable._fromList = fromList;

  // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;

    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = fromListPartial(n, state.buffer, state.decoder);
    }

    return ret;
  }

  // Extracts only enough buffered data to satisfy the amount requested.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      // slice is the same for buffers and strings
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      // first chunk is a perfect match
      ret = list.shift();
    } else {
      // result spans more than one buffer
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }

  // Copies a specified amount of characters from the list of buffered data
  // chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  // Copies a specified amount of bytes from the list of buffered data chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;

    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

    if (!state.endEmitted) {
      state.ended = true;
      nextTick(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
    }
  }

  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }

  // A bit simpler than readable streams.
  // Implement an async ._write(chunk, encoding, cb), and it'll handle all
  // the drain event emission and buffering.

  Writable.WritableState = WritableState;
  inherits$1(Writable, EventEmitter$7);

  function nop() {}

  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }

  function WritableState(options, stream) {
    Object.defineProperty(this, 'buffer', {
      get: deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
    options = options || {};

    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;

    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // a flag to see when we're in the middle of a write.
    this.writing = false;

    // when true all writes will be buffered until .uncork() call
    this.corked = 0;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
      onwrite(stream, er);
    };

    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;

    // the amount that is being written when _write is called.
    this.writelen = 0;

    this.bufferedRequest = null;
    this.lastBufferedRequest = null;

    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;

    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;

    // count buffered requests
    this.bufferedRequestCount = 0;

    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  function Writable(options) {

    // Writable ctor is applied to Duplexes, though they're not
    // instanceof Writable, they're instanceof Readable.
    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

    this._writableState = new WritableState(options, this);

    // legacy.
    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;

      if (typeof options.writev === 'function') this._writev = options.writev;
    }

    EventEmitter$7.call(this);
  }

  // Otherwise people can pipe Writable streams, which is just wrong.
  Writable.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
  };

  function writeAfterEnd(stream, cb) {
    var er = new Error('write after end');
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit('error', er);
    nextTick(cb, er);
  }

  // If we get something that is not a buffer, string, null, or undefined,
  // and we're not in objectMode, then that's an error.
  // Otherwise stream chunks are all considered to be of length=1, and the
  // watermarks determine how many objects to keep in the buffer, rather than
  // how many bytes or characters.
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    // Always throw error if a null is written
    // if we are not in object mode then throw
    // if it is not a buffer, string, or undefined.
    if (chunk === null) {
      er = new TypeError('May not write null values to stream');
    } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    if (er) {
      stream.emit('error', er);
      nextTick(cb, er);
      valid = false;
    }
    return valid;
  }

  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

    if (typeof cb !== 'function') cb = nop;

    if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }

    return ret;
  };

  Writable.prototype.cork = function () {
    var state = this._writableState;

    state.corked++;
  };

  Writable.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;

      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
  }

  // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);

    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
    var len = state.objectMode ? 1 : chunk.length;

    state.length += len;

    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) nextTick(cb, er);else cb(er);

    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;

    onwriteStateUpdate(state);

    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state);

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        /*<replacement>*/
          nextTick(afterWrite, stream, state, finished, cb);
        /*</replacement>*/
      } else {
          afterWrite(stream, state, finished, cb);
        }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }

  // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  }

  // if there's something in the buffer waiting, then process it
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;

      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }

      doWrite(stream, state, true, state.length, buffer, '', holder.finish);

      // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;

        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('not implemented'));
  };

  Writable.prototype._writev = null;

  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }

    // ignore unnecessary end() calls.
    if (!state.ending && !state.finished) endWritable(this, state, cb);
  };

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit('finish');
      } else {
        prefinish(stream, state);
      }
    }
    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) nextTick(cb);else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
  }

  // It seems a linked list but it is not
  // there will be only 2 of these for each stream
  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function (err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }

  inherits$1(Duplex, Readable);

  var keys = Object.keys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);

    Readable.call(this, options);
    Writable.call(this, options);

    if (options && options.readable === false) this.readable = false;

    if (options && options.writable === false) this.writable = false;

    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

    this.once('end', onend);
  }

  // the no-half-open enforcer
  function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;

    // no more data can be written.
    // But allow more writes to happen in this tick.
    nextTick(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  // a transform stream is a readable/writable stream where you do
  // something with the data.  Sometimes it's called a "filter",
  // but that's not a great name for it, since that implies a thing where
  // some bits pass through, and others are simply ignored.  (That would
  // be a valid example of a transform, of course.)
  //
  // While the output is causally related to the input, it's not a
  // necessarily symmetric or synchronous transformation.  For example,
  // a zlib stream might take multiple plain-text writes(), and then
  // emit a single compressed chunk some time in the future.
  //
  // Here's how this works:
  //
  // The Transform stream has all the aspects of the readable and writable
  // stream classes.  When you write(chunk), that calls _write(chunk,cb)
  // internally, and returns false if there's a lot of pending writes
  // buffered up.  When you call read(), that calls _read(n) until
  // there's enough pending readable data buffered up.
  //
  // In a transform stream, the written data is placed in a buffer.  When
  // _read(n) is called, it transforms the queued up data, calling the
  // buffered _write cb's as it consumes chunks.  If consuming a single
  // written chunk would result in multiple output chunks, then the first
  // outputted bit calls the readcb, and subsequent chunks just go into
  // the read buffer, and will cause it to emit 'readable' if necessary.
  //
  // This way, back-pressure is actually determined by the reading side,
  // since _read has to be called to start processing a new chunk.  However,
  // a pathological inflate type of transform can cause excessive buffering
  // here.  For example, imagine a stream where every byte of input is
  // interpreted as an integer from 0-255, and then results in that many
  // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
  // 1kb of data being output.  In this case, you could write a very small
  // amount of input, and end up with a very large amount of output.  In
  // such a pathological inflating mechanism, there'd be no way to tell
  // the system to stop doing the transform.  A single 4MB write could
  // cause the system to run out of memory.
  //
  // However, even in such a pathological case, only a single written chunk
  // would be consumed, and then the rest would wait (un-transformed) until
  // the results of the previous transformed chunk were consumed.

  inherits$1(Transform, Duplex);

  function TransformState(stream) {
    this.afterTransform = function (er, data) {
      return afterTransform(stream, er, data);
    };

    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }

  function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;

    var cb = ts.writecb;

    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

    ts.writechunk = null;
    ts.writecb = null;

    if (data !== null && data !== undefined) stream.push(data);

    cb(er);

    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);

    Duplex.call(this, options);

    this._transformState = new TransformState(this);

    // when the writable side finishes, then flush out anything remaining.
    var stream = this;

    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;

    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;

      if (typeof options.flush === 'function') this._flush = options.flush;
    }

    this.once('prefinish', function () {
      if (typeof this._flush === 'function') this._flush(function (er) {
        done(stream, er);
      });else done(stream);
    });
  }

  Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };

  // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.
  Transform.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('Not implemented');
  };

  Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };

  // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.
  Transform.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  function done(stream, er) {
    if (er) return stream.emit('error', er);

    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    var ws = stream._writableState;
    var ts = stream._transformState;

    if (ws.length) throw new Error('Calling transform done when ws.length != 0');

    if (ts.transforming) throw new Error('Calling transform done when still transforming');

    return stream.push(null);
  }

  inherits$1(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);

    Transform.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  inherits$1(Stream, EventEmitter$7);
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;

  // Backwards-compat with node 0.4.x
  Stream.Stream = Stream;

  // old-style streams.  Note that the pipe method (the only relevant
  // part of this class) is overridden in the Readable class.

  function Stream() {
    EventEmitter$7.call(this);
  }

  Stream.prototype.pipe = function(dest, options) {
    var source = this;

    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }

    source.on('data', ondata);

    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }

    dest.on('drain', ondrain);

    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }

    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;

      dest.end();
    }


    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;

      if (typeof dest.destroy === 'function') dest.destroy();
    }

    // don't leave dangling pipes when there are errors.
    function onerror(er) {
      cleanup();
      if (EventEmitter$7.listenerCount(this, 'error') === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }

    source.on('error', onerror);
    dest.on('error', onerror);

    // remove all the event listeners that were added.
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);

      source.removeListener('end', onend);
      source.removeListener('close', onclose);

      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);

      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);

      dest.removeListener('close', cleanup);
    }

    source.on('end', cleanup);
    source.on('close', cleanup);

    dest.on('close', cleanup);

    dest.emit('pipe', source);

    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
  };

  var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Duplex: Duplex,
    PassThrough: PassThrough,
    Readable: Readable,
    Stream: Stream,
    Transform: Transform,
    Writable: Writable,
    default: Stream
  });

  var require$$4 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

  var hasRequiredLib$1;

  function requireLib$1 () {
  	if (hasRequiredLib$1) return lib$1.exports;
  	hasRequiredLib$1 = 1;
  	(function (module) {

  		var Buffer = requireSafer().Buffer;

  		var bomHandling = requireBomHandling(),
  		    iconv = module.exports;

  		// All codecs and aliases are kept here, keyed by encoding name/alias.
  		// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
  		iconv.encodings = null;

  		// Characters emitted in case of error.
  		iconv.defaultCharUnicode = '';
  		iconv.defaultCharSingleByte = '?';

  		// Public API.
  		iconv.encode = function encode(str, encoding, options) {
  		    str = "" + (str || ""); // Ensure string.

  		    var encoder = iconv.getEncoder(encoding, options);

  		    var res = encoder.write(str);
  		    var trail = encoder.end();
  		    
  		    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
  		};

  		iconv.decode = function decode(buf, encoding, options) {
  		    if (typeof buf === 'string') {
  		        if (!iconv.skipDecodeWarning) {
  		            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
  		            iconv.skipDecodeWarning = true;
  		        }

  		        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
  		    }

  		    var decoder = iconv.getDecoder(encoding, options);

  		    var res = decoder.write(buf);
  		    var trail = decoder.end();

  		    return trail ? (res + trail) : res;
  		};

  		iconv.encodingExists = function encodingExists(enc) {
  		    try {
  		        iconv.getCodec(enc);
  		        return true;
  		    } catch (e) {
  		        return false;
  		    }
  		};

  		// Legacy aliases to convert functions
  		iconv.toEncoding = iconv.encode;
  		iconv.fromEncoding = iconv.decode;

  		// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
  		iconv._codecDataCache = {};
  		iconv.getCodec = function getCodec(encoding) {
  		    if (!iconv.encodings)
  		        iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.
  		    
  		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
  		    var enc = iconv._canonicalizeEncoding(encoding);

  		    // Traverse iconv.encodings to find actual codec.
  		    var codecOptions = {};
  		    while (true) {
  		        var codec = iconv._codecDataCache[enc];
  		        if (codec)
  		            return codec;

  		        var codecDef = iconv.encodings[enc];

  		        switch (typeof codecDef) {
  		            case "string": // Direct alias to other encoding.
  		                enc = codecDef;
  		                break;

  		            case "object": // Alias with options. Can be layered.
  		                for (var key in codecDef)
  		                    codecOptions[key] = codecDef[key];

  		                if (!codecOptions.encodingName)
  		                    codecOptions.encodingName = enc;
  		                
  		                enc = codecDef.type;
  		                break;

  		            case "function": // Codec itself.
  		                if (!codecOptions.encodingName)
  		                    codecOptions.encodingName = enc;

  		                // The codec function must load all tables and return object with .encoder and .decoder methods.
  		                // It'll be called only once (for each different options object).
  		                codec = new codecDef(codecOptions, iconv);

  		                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
  		                return codec;

  		            default:
  		                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
  		        }
  		    }
  		};

  		iconv._canonicalizeEncoding = function(encoding) {
  		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
  		    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  		};

  		iconv.getEncoder = function getEncoder(encoding, options) {
  		    var codec = iconv.getCodec(encoding),
  		        encoder = new codec.encoder(options, codec);

  		    if (codec.bomAware && options && options.addBOM)
  		        encoder = new bomHandling.PrependBOM(encoder, options);

  		    return encoder;
  		};

  		iconv.getDecoder = function getDecoder(encoding, options) {
  		    var codec = iconv.getCodec(encoding),
  		        decoder = new codec.decoder(options, codec);

  		    if (codec.bomAware && !(options && options.stripBOM === false))
  		        decoder = new bomHandling.StripBOM(decoder, options);

  		    return decoder;
  		};

  		// Streaming API
  		// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
  		// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
  		// If you would like to enable it explicitly, please add the following code to your app:
  		// > iconv.enableStreamingAPI(require('stream'));
  		iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
  		    if (iconv.supportsStreams)
  		        return;

  		    // Dependency-inject stream module to create IconvLite stream classes.
  		    var streams = requireStreams()(stream_module);

  		    // Not public API yet, but expose the stream classes.
  		    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
  		    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

  		    // Streaming API.
  		    iconv.encodeStream = function encodeStream(encoding, options) {
  		        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
  		    };

  		    iconv.decodeStream = function decodeStream(encoding, options) {
  		        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
  		    };

  		    iconv.supportsStreams = true;
  		};

  		// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
  		var stream_module;
  		try {
  		    stream_module = require$$4;
  		} catch (e) {}

  		if (stream_module && stream_module.Transform) {
  		    iconv.enableStreamingAPI(stream_module);

  		} else {
  		    // In rare cases where 'stream' module is not available by default, throw a helpful exception.
  		    iconv.encodeStream = iconv.decodeStream = function() {
  		        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
  		    };
  		}
  	} (lib$1));
  	return lib$1.exports;
  }

  var lib = {};

  var browser$1 = {};

  var hasRequiredBrowser;

  function requireBrowser () {
  	if (hasRequiredBrowser) return browser$1;
  	hasRequiredBrowser = 1;
  	Object.defineProperty(browser$1, "__esModule", { value: true });
  	browser$1.default = () => {
  	    throw new Error('File system is not available');
  	};
  	
  	return browser$1;
  }

  var ascii = {};

  var match = {};

  var hasRequiredMatch;

  function requireMatch () {
  	if (hasRequiredMatch) return match;
  	hasRequiredMatch = 1;
  	Object.defineProperty(match, "__esModule", { value: true });
  	match.default = (ctx, rec, confidence) => ({
  	    confidence,
  	    name: rec.name(ctx),
  	    lang: rec.language ? rec.language() : undefined,
  	});
  	
  	return match;
  }

  var hasRequiredAscii;

  function requireAscii () {
  	if (hasRequiredAscii) return ascii;
  	hasRequiredAscii = 1;
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(ascii, "__esModule", { value: true });
  	const match_1 = __importDefault(requireMatch());
  	class Ascii {
  	    name() {
  	        return 'ASCII';
  	    }
  	    match(det) {
  	        const input = det.rawInput;
  	        for (let i = 0; i < det.rawLen; i++) {
  	            const b = input[i];
  	            if (b < 32 || b > 126) {
  	                return (0, match_1.default)(det, this, 0);
  	            }
  	        }
  	        return (0, match_1.default)(det, this, 100);
  	    }
  	}
  	ascii.default = Ascii;
  	
  	return ascii;
  }

  var utf8 = {};

  var hasRequiredUtf8;

  function requireUtf8 () {
  	if (hasRequiredUtf8) return utf8;
  	hasRequiredUtf8 = 1;
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(utf8, "__esModule", { value: true });
  	const match_1 = __importDefault(requireMatch());
  	class Utf8 {
  	    name() {
  	        return 'UTF-8';
  	    }
  	    match(det) {
  	        let hasBOM = false, numValid = 0, numInvalid = 0, trailBytes = 0, confidence;
  	        const input = det.rawInput;
  	        if (det.rawLen >= 3 &&
  	            (input[0] & 0xff) == 0xef &&
  	            (input[1] & 0xff) == 0xbb &&
  	            (input[2] & 0xff) == 0xbf) {
  	            hasBOM = true;
  	        }
  	        for (let i = 0; i < det.rawLen; i++) {
  	            const b = input[i];
  	            if ((b & 0x80) == 0)
  	                continue;
  	            if ((b & 0x0e0) == 0x0c0) {
  	                trailBytes = 1;
  	            }
  	            else if ((b & 0x0f0) == 0x0e0) {
  	                trailBytes = 2;
  	            }
  	            else if ((b & 0x0f8) == 0xf0) {
  	                trailBytes = 3;
  	            }
  	            else {
  	                numInvalid++;
  	                if (numInvalid > 5)
  	                    break;
  	                trailBytes = 0;
  	            }
  	            for (;;) {
  	                i++;
  	                if (i >= det.rawLen)
  	                    break;
  	                if ((input[i] & 0xc0) != 0x080) {
  	                    numInvalid++;
  	                    break;
  	                }
  	                if (--trailBytes == 0) {
  	                    numValid++;
  	                    break;
  	                }
  	            }
  	        }
  	        confidence = 0;
  	        if (hasBOM && numInvalid == 0)
  	            confidence = 100;
  	        else if (hasBOM && numValid > numInvalid * 10)
  	            confidence = 80;
  	        else if (numValid > 3 && numInvalid == 0)
  	            confidence = 100;
  	        else if (numValid > 0 && numInvalid == 0)
  	            confidence = 80;
  	        else if (numValid == 0 && numInvalid == 0)
  	            confidence = 10;
  	        else if (numValid > numInvalid * 10)
  	            confidence = 25;
  	        else
  	            return null;
  	        return (0, match_1.default)(det, this, confidence);
  	    }
  	}
  	utf8.default = Utf8;
  	
  	return utf8;
  }

  var unicode = {};

  var hasRequiredUnicode;

  function requireUnicode () {
  	if (hasRequiredUnicode) return unicode;
  	hasRequiredUnicode = 1;
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(unicode, "__esModule", { value: true });
  	unicode.UTF_32LE = unicode.UTF_32BE = unicode.UTF_16LE = unicode.UTF_16BE = void 0;
  	const match_1 = __importDefault(requireMatch());
  	class UTF_16BE {
  	    name() {
  	        return 'UTF-16BE';
  	    }
  	    match(det) {
  	        const input = det.rawInput;
  	        if (input.length >= 2 &&
  	            (input[0] & 0xff) == 0xfe &&
  	            (input[1] & 0xff) == 0xff) {
  	            return (0, match_1.default)(det, this, 100);
  	        }
  	        return null;
  	    }
  	}
  	unicode.UTF_16BE = UTF_16BE;
  	class UTF_16LE {
  	    name() {
  	        return 'UTF-16LE';
  	    }
  	    match(det) {
  	        const input = det.rawInput;
  	        if (input.length >= 2 &&
  	            (input[0] & 0xff) == 0xff &&
  	            (input[1] & 0xff) == 0xfe) {
  	            if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {
  	                return null;
  	            }
  	            return (0, match_1.default)(det, this, 100);
  	        }
  	        return null;
  	    }
  	}
  	unicode.UTF_16LE = UTF_16LE;
  	class UTF_32 {
  	    name() {
  	        return 'UTF-32';
  	    }
  	    getChar(_input, _index) {
  	        return -1;
  	    }
  	    match(det) {
  	        let numValid = 0, numInvalid = 0, hasBOM = false, confidence = 0;
  	        const limit = (det.rawLen / 4) * 4;
  	        const input = det.rawInput;
  	        if (limit == 0) {
  	            return null;
  	        }
  	        if (this.getChar(input, 0) == 0x0000feff) {
  	            hasBOM = true;
  	        }
  	        for (let i = 0; i < limit; i += 4) {
  	            const ch = this.getChar(input, i);
  	            if (ch < 0 || ch >= 0x10ffff || (ch >= 0xd800 && ch <= 0xdfff)) {
  	                numInvalid += 1;
  	            }
  	            else {
  	                numValid += 1;
  	            }
  	        }
  	        if (hasBOM && numInvalid == 0) {
  	            confidence = 100;
  	        }
  	        else if (hasBOM && numValid > numInvalid * 10) {
  	            confidence = 80;
  	        }
  	        else if (numValid > 3 && numInvalid == 0) {
  	            confidence = 100;
  	        }
  	        else if (numValid > 0 && numInvalid == 0) {
  	            confidence = 80;
  	        }
  	        else if (numValid > numInvalid * 10) {
  	            confidence = 25;
  	        }
  	        return confidence == 0 ? null : (0, match_1.default)(det, this, confidence);
  	    }
  	}
  	class UTF_32BE extends UTF_32 {
  	    name() {
  	        return 'UTF-32BE';
  	    }
  	    getChar(input, index) {
  	        return (((input[index + 0] & 0xff) << 24) |
  	            ((input[index + 1] & 0xff) << 16) |
  	            ((input[index + 2] & 0xff) << 8) |
  	            (input[index + 3] & 0xff));
  	    }
  	}
  	unicode.UTF_32BE = UTF_32BE;
  	class UTF_32LE extends UTF_32 {
  	    name() {
  	        return 'UTF-32LE';
  	    }
  	    getChar(input, index) {
  	        return (((input[index + 3] & 0xff) << 24) |
  	            ((input[index + 2] & 0xff) << 16) |
  	            ((input[index + 1] & 0xff) << 8) |
  	            (input[index + 0] & 0xff));
  	    }
  	}
  	unicode.UTF_32LE = UTF_32LE;
  	
  	return unicode;
  }

  var mbcs = {};

  var hasRequiredMbcs;

  function requireMbcs () {
  	if (hasRequiredMbcs) return mbcs;
  	hasRequiredMbcs = 1;
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(mbcs, "__esModule", { value: true });
  	mbcs.gb_18030 = mbcs.euc_kr = mbcs.euc_jp = mbcs.big5 = mbcs.sjis = void 0;
  	const match_1 = __importDefault(requireMatch());
  	function binarySearch(arr, searchValue) {
  	    const find = (arr, searchValue, left, right) => {
  	        if (right < left)
  	            return -1;
  	        const mid = Math.floor((left + right) >>> 1);
  	        if (searchValue > arr[mid])
  	            return find(arr, searchValue, mid + 1, right);
  	        if (searchValue < arr[mid])
  	            return find(arr, searchValue, left, mid - 1);
  	        return mid;
  	    };
  	    return find(arr, searchValue, 0, arr.length - 1);
  	}
  	class IteratedChar {
  	    constructor() {
  	        this.charValue = 0;
  	        this.index = 0;
  	        this.nextIndex = 0;
  	        this.error = false;
  	        this.done = false;
  	    }
  	    reset() {
  	        this.charValue = 0;
  	        this.index = -1;
  	        this.nextIndex = 0;
  	        this.error = false;
  	        this.done = false;
  	    }
  	    nextByte(det) {
  	        if (this.nextIndex >= det.rawLen) {
  	            this.done = true;
  	            return -1;
  	        }
  	        const byteValue = det.rawInput[this.nextIndex++] & 0x00ff;
  	        return byteValue;
  	    }
  	}
  	let mbcs$1 = class mbcs {
  	    constructor() {
  	        this.commonChars = [];
  	    }
  	    name() {
  	        return 'mbcs';
  	    }
  	    match(det) {
  	        let doubleByteCharCount = 0, commonCharCount = 0, badCharCount = 0, totalCharCount = 0, confidence = 0;
  	        const iter = new IteratedChar();
  	        detectBlock: {
  	            for (iter.reset(); this.nextChar(iter, det);) {
  	                totalCharCount++;
  	                if (iter.error) {
  	                    badCharCount++;
  	                }
  	                else {
  	                    const cv = iter.charValue & 0xffffffff;
  	                    if (cv > 0xff) {
  	                        doubleByteCharCount++;
  	                        if (this.commonChars != null) {
  	                            if (binarySearch(this.commonChars, cv) >= 0) {
  	                                commonCharCount++;
  	                            }
  	                        }
  	                    }
  	                }
  	                if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {
  	                    break detectBlock;
  	                }
  	            }
  	            if (doubleByteCharCount <= 10 && badCharCount == 0) {
  	                if (doubleByteCharCount == 0 && totalCharCount < 10) {
  	                    confidence = 0;
  	                }
  	                else {
  	                    confidence = 10;
  	                }
  	                break detectBlock;
  	            }
  	            if (doubleByteCharCount < 20 * badCharCount) {
  	                confidence = 0;
  	                break detectBlock;
  	            }
  	            if (this.commonChars == null) {
  	                confidence = 30 + doubleByteCharCount - 20 * badCharCount;
  	                if (confidence > 100) {
  	                    confidence = 100;
  	                }
  	            }
  	            else {
  	                const maxVal = Math.log(doubleByteCharCount / 4);
  	                const scaleFactor = 90.0 / maxVal;
  	                confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
  	                confidence = Math.min(confidence, 100);
  	            }
  	        }
  	        return confidence == 0 ? null : (0, match_1.default)(det, this, confidence);
  	    }
  	    nextChar(_iter, _det) {
  	        return true;
  	    }
  	};
  	class sjis extends mbcs$1 {
  	    constructor() {
  	        super(...arguments);
  	        this.commonChars = [
  	            0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176,
  	            0x82a0, 0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1,
  	            0x82b3, 0x82b5, 0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6,
  	            0x82c8, 0x82c9, 0x82cc, 0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9,
  	            0x82ea, 0x82f0, 0x82f1, 0x8341, 0x8343, 0x834e, 0x834f, 0x8358, 0x835e,
  	            0x8362, 0x8367, 0x8375, 0x8376, 0x8389, 0x838a, 0x838b, 0x838d, 0x8393,
  	            0x8e96, 0x93fa, 0x95aa,
  	        ];
  	    }
  	    name() {
  	        return 'Shift_JIS';
  	    }
  	    language() {
  	        return 'ja';
  	    }
  	    nextChar(iter, det) {
  	        iter.index = iter.nextIndex;
  	        iter.error = false;
  	        const firstByte = (iter.charValue = iter.nextByte(det));
  	        if (firstByte < 0)
  	            return false;
  	        if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))
  	            return true;
  	        const secondByte = iter.nextByte(det);
  	        if (secondByte < 0)
  	            return false;
  	        iter.charValue = (firstByte << 8) | secondByte;
  	        if (!((secondByte >= 0x40 && secondByte <= 0x7f) ||
  	            (secondByte >= 0x80 && secondByte <= 0xff))) {
  	            iter.error = true;
  	        }
  	        return true;
  	    }
  	}
  	mbcs.sjis = sjis;
  	class big5 extends mbcs$1 {
  	    constructor() {
  	        super(...arguments);
  	        this.commonChars = [
  	            0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440,
  	            0xa446, 0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c,
  	            0xa477, 0xa4a3, 0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8,
  	            0xa4fd, 0xa540, 0xa548, 0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661,
  	            0xa662, 0xa668, 0xa670, 0xa6a8, 0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6,
  	            0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da, 0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1,
  	            0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3, 0xaa6b, 0xaaba, 0xaabe,
  	            0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59, 0xaec9, 0xafe0,
  	            0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c, 0xb5a5,
  	            0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,
  	            0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f,
  	        ];
  	    }
  	    name() {
  	        return 'Big5';
  	    }
  	    language() {
  	        return 'zh';
  	    }
  	    nextChar(iter, det) {
  	        iter.index = iter.nextIndex;
  	        iter.error = false;
  	        const firstByte = (iter.charValue = iter.nextByte(det));
  	        if (firstByte < 0)
  	            return false;
  	        if (firstByte <= 0x7f || firstByte == 0xff)
  	            return true;
  	        const secondByte = iter.nextByte(det);
  	        if (secondByte < 0)
  	            return false;
  	        iter.charValue = (iter.charValue << 8) | secondByte;
  	        if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)
  	            iter.error = true;
  	        return true;
  	    }
  	}
  	mbcs.big5 = big5;
  	function eucNextChar(iter, det) {
  	    iter.index = iter.nextIndex;
  	    iter.error = false;
  	    let firstByte = 0;
  	    let secondByte = 0;
  	    let thirdByte = 0;
  	    buildChar: {
  	        firstByte = iter.charValue = iter.nextByte(det);
  	        if (firstByte < 0) {
  	            iter.done = true;
  	            break buildChar;
  	        }
  	        if (firstByte <= 0x8d) {
  	            break buildChar;
  	        }
  	        secondByte = iter.nextByte(det);
  	        iter.charValue = (iter.charValue << 8) | secondByte;
  	        if (firstByte >= 0xa1 && firstByte <= 0xfe) {
  	            if (secondByte < 0xa1) {
  	                iter.error = true;
  	            }
  	            break buildChar;
  	        }
  	        if (firstByte == 0x8e) {
  	            if (secondByte < 0xa1) {
  	                iter.error = true;
  	            }
  	            break buildChar;
  	        }
  	        if (firstByte == 0x8f) {
  	            thirdByte = iter.nextByte(det);
  	            iter.charValue = (iter.charValue << 8) | thirdByte;
  	            if (thirdByte < 0xa1) {
  	                iter.error = true;
  	            }
  	        }
  	    }
  	    return iter.done == false;
  	}
  	class euc_jp extends mbcs$1 {
  	    constructor() {
  	        super(...arguments);
  	        this.commonChars = [
  	            0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7,
  	            0xa4a2, 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af,
  	            0xa4b1, 0xa4b3, 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0,
  	            0xa4c1, 0xa4c3, 0xa4c4, 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb,
  	            0xa4ce, 0xa4cf, 0xa4d0, 0xa4de, 0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8,
  	            0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef, 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3,
  	            0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af, 0xa5b0, 0xa5b3, 0xa5b5,
  	            0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7, 0xa5c8, 0xa5c9,
  	            0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1, 0xa5e5,
  	            0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,
  	            0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc,
  	            0xcdd1,
  	        ];
  	        this.nextChar = eucNextChar;
  	    }
  	    name() {
  	        return 'EUC-JP';
  	    }
  	    language() {
  	        return 'ja';
  	    }
  	}
  	mbcs.euc_jp = euc_jp;
  	class euc_kr extends mbcs$1 {
  	    constructor() {
  	        super(...arguments);
  	        this.commonChars = [
  	            0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa,
  	            0xb0fc, 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2,
  	            0xb4cf, 0xb4d9, 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3,
  	            0xb7af, 0xb7c2, 0xb7ce, 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9,
  	            0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce, 0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1,
  	            0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba, 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0,
  	            0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee, 0xbef8, 0xbefa, 0xbfa1,
  	            0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7, 0xc0af, 0xc0b8,
  	            0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6, 0xc0da,
  	            0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,
  	            0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5,
  	            0xc8ad,
  	        ];
  	        this.nextChar = eucNextChar;
  	    }
  	    name() {
  	        return 'EUC-KR';
  	    }
  	    language() {
  	        return 'ko';
  	    }
  	}
  	mbcs.euc_kr = euc_kr;
  	class gb_18030 extends mbcs$1 {
  	    constructor() {
  	        super(...arguments);
  	        this.commonChars = [
  	            0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1,
  	            0xa3ac, 0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3,
  	            0xb5bd, 0xb5c4, 0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd,
  	            0xb7d6, 0xb7dd, 0xb8b4, 0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa,
  	            0xb9fd, 0xbacd, 0xbba7, 0xbbd6, 0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe,
  	            0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6, 0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb,
  	            0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7, 0xc7f8, 0xc8ab, 0xc8cb,
  	            0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7, 0xcad0, 0xcad6,
  	            0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5, 0xcfb5,
  	            0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,
  	            0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2,
  	            0xd6d0,
  	        ];
  	    }
  	    name() {
  	        return 'GB18030';
  	    }
  	    language() {
  	        return 'zh';
  	    }
  	    nextChar(iter, det) {
  	        iter.index = iter.nextIndex;
  	        iter.error = false;
  	        let firstByte = 0;
  	        let secondByte = 0;
  	        let thirdByte = 0;
  	        let fourthByte = 0;
  	        buildChar: {
  	            firstByte = iter.charValue = iter.nextByte(det);
  	            if (firstByte < 0) {
  	                iter.done = true;
  	                break buildChar;
  	            }
  	            if (firstByte <= 0x80) {
  	                break buildChar;
  	            }
  	            secondByte = iter.nextByte(det);
  	            iter.charValue = (iter.charValue << 8) | secondByte;
  	            if (firstByte >= 0x81 && firstByte <= 0xfe) {
  	                if ((secondByte >= 0x40 && secondByte <= 0x7e) ||
  	                    (secondByte >= 80 && secondByte <= 0xfe)) {
  	                    break buildChar;
  	                }
  	                if (secondByte >= 0x30 && secondByte <= 0x39) {
  	                    thirdByte = iter.nextByte(det);
  	                    if (thirdByte >= 0x81 && thirdByte <= 0xfe) {
  	                        fourthByte = iter.nextByte(det);
  	                        if (fourthByte >= 0x30 && fourthByte <= 0x39) {
  	                            iter.charValue =
  	                                (iter.charValue << 16) | (thirdByte << 8) | fourthByte;
  	                            break buildChar;
  	                        }
  	                    }
  	                }
  	                iter.error = true;
  	                break buildChar;
  	            }
  	        }
  	        return iter.done == false;
  	    }
  	}
  	mbcs.gb_18030 = gb_18030;
  	
  	return mbcs;
  }

  var sbcs = {};

  var hasRequiredSbcs;

  function requireSbcs () {
  	if (hasRequiredSbcs) return sbcs;
  	hasRequiredSbcs = 1;
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(sbcs, "__esModule", { value: true });
  	sbcs.KOI8_R = sbcs.windows_1256 = sbcs.windows_1251 = sbcs.ISO_8859_9 = sbcs.ISO_8859_8 = sbcs.ISO_8859_7 = sbcs.ISO_8859_6 = sbcs.ISO_8859_5 = sbcs.ISO_8859_2 = sbcs.ISO_8859_1 = void 0;
  	const match_1 = __importDefault(requireMatch());
  	const N_GRAM_MASK = 0xffffff;
  	class NGramParser {
  	    constructor(theNgramList, theByteMap) {
  	        this.byteIndex = 0;
  	        this.ngram = 0;
  	        this.ngramCount = 0;
  	        this.hitCount = 0;
  	        this.spaceChar = 0x20;
  	        this.ngramList = theNgramList;
  	        this.byteMap = theByteMap;
  	    }
  	    search(table, value) {
  	        let index = 0;
  	        if (table[index + 32] <= value)
  	            index += 32;
  	        if (table[index + 16] <= value)
  	            index += 16;
  	        if (table[index + 8] <= value)
  	            index += 8;
  	        if (table[index + 4] <= value)
  	            index += 4;
  	        if (table[index + 2] <= value)
  	            index += 2;
  	        if (table[index + 1] <= value)
  	            index += 1;
  	        if (table[index] > value)
  	            index -= 1;
  	        if (index < 0 || table[index] != value)
  	            return -1;
  	        return index;
  	    }
  	    lookup(thisNgram) {
  	        this.ngramCount += 1;
  	        if (this.search(this.ngramList, thisNgram) >= 0) {
  	            this.hitCount += 1;
  	        }
  	    }
  	    addByte(b) {
  	        this.ngram = ((this.ngram << 8) + (b & 0xff)) & N_GRAM_MASK;
  	        this.lookup(this.ngram);
  	    }
  	    nextByte(det) {
  	        if (this.byteIndex >= det.inputLen)
  	            return -1;
  	        return det.inputBytes[this.byteIndex++] & 0xff;
  	    }
  	    parse(det, spaceCh) {
  	        let b, ignoreSpace = false;
  	        this.spaceChar = spaceCh;
  	        while ((b = this.nextByte(det)) >= 0) {
  	            const mb = this.byteMap[b];
  	            if (mb != 0) {
  	                if (!(mb == this.spaceChar && ignoreSpace)) {
  	                    this.addByte(mb);
  	                }
  	                ignoreSpace = mb == this.spaceChar;
  	            }
  	        }
  	        this.addByte(this.spaceChar);
  	        const rawPercent = this.hitCount / this.ngramCount;
  	        if (rawPercent > 0.33)
  	            return 98;
  	        return Math.floor(rawPercent * 300.0);
  	    }
  	}
  	class NGramsPlusLang {
  	    constructor(la, ng) {
  	        this.fLang = la;
  	        this.fNGrams = ng;
  	    }
  	}
  	const isFlatNgrams = (val) => Array.isArray(val) && isFinite(val[0]);
  	let sbcs$1 = class sbcs {
  	    constructor() {
  	        this.spaceChar = 0x20;
  	        this.nGramLang = undefined;
  	    }
  	    ngrams() {
  	        return [];
  	    }
  	    byteMap() {
  	        return [];
  	    }
  	    name(_input) {
  	        return 'sbcs';
  	    }
  	    language() {
  	        return this.nGramLang;
  	    }
  	    match(det) {
  	        this.nGramLang = undefined;
  	        const ngrams = this.ngrams();
  	        if (isFlatNgrams(ngrams)) {
  	            const parser = new NGramParser(ngrams, this.byteMap());
  	            const confidence = parser.parse(det, this.spaceChar);
  	            return confidence <= 0 ? null : (0, match_1.default)(det, this, confidence);
  	        }
  	        let bestConfidence = -1;
  	        for (let i = ngrams.length - 1; i >= 0; i--) {
  	            const ngl = ngrams[i];
  	            const parser = new NGramParser(ngl.fNGrams, this.byteMap());
  	            const confidence = parser.parse(det, this.spaceChar);
  	            if (confidence > bestConfidence) {
  	                bestConfidence = confidence;
  	                this.nGramLang = ngl.fLang;
  	            }
  	        }
  	        return bestConfidence <= 0 ? null : (0, match_1.default)(det, this, bestConfidence);
  	    }
  	};
  	class ISO_8859_1 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0xaa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0xba, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
  	            0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x20,
  	            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x20, 0xf8, 0xf9, 0xfa, 0xfb,
  	            0xfc, 0xfd, 0xfe, 0xff,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            new NGramsPlusLang('da', [
  	                0x206166, 0x206174, 0x206465, 0x20656e, 0x206572, 0x20666f, 0x206861,
  	                0x206920, 0x206d65, 0x206f67, 0x2070e5, 0x207369, 0x207374, 0x207469,
  	                0x207669, 0x616620, 0x616e20, 0x616e64, 0x617220, 0x617420, 0x646520,
  	                0x64656e, 0x646572, 0x646574, 0x652073, 0x656420, 0x656465, 0x656e20,
  	                0x656e64, 0x657220, 0x657265, 0x657320, 0x657420, 0x666f72, 0x676520,
  	                0x67656e, 0x676572, 0x696765, 0x696c20, 0x696e67, 0x6b6520, 0x6b6b65,
  	                0x6c6572, 0x6c6967, 0x6c6c65, 0x6d6564, 0x6e6465, 0x6e6520, 0x6e6720,
  	                0x6e6765, 0x6f6720, 0x6f6d20, 0x6f7220, 0x70e520, 0x722064, 0x722065,
  	                0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696c,
  	                0x766572,
  	            ]),
  	            new NGramsPlusLang('de', [
  	                0x20616e, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569,
  	                0x206765, 0x206861, 0x20696e, 0x206d69, 0x207363, 0x207365, 0x20756e,
  	                0x207665, 0x20766f, 0x207765, 0x207a75, 0x626572, 0x636820, 0x636865,
  	                0x636874, 0x646173, 0x64656e, 0x646572, 0x646965, 0x652064, 0x652073,
  	                0x65696e, 0x656974, 0x656e20, 0x657220, 0x657320, 0x67656e, 0x68656e,
  	                0x687420, 0x696368, 0x696520, 0x696e20, 0x696e65, 0x697420, 0x6c6963,
  	                0x6c6c65, 0x6e2061, 0x6e2064, 0x6e2073, 0x6e6420, 0x6e6465, 0x6e6520,
  	                0x6e6720, 0x6e6765, 0x6e7465, 0x722064, 0x726465, 0x726569, 0x736368,
  	                0x737465, 0x742064, 0x746520, 0x74656e, 0x746572, 0x756e64, 0x756e67,
  	                0x766572,
  	            ]),
  	            new NGramsPlusLang('en', [
  	                0x206120, 0x20616e, 0x206265, 0x20636f, 0x20666f, 0x206861, 0x206865,
  	                0x20696e, 0x206d61, 0x206f66, 0x207072, 0x207265, 0x207361, 0x207374,
  	                0x207468, 0x20746f, 0x207768, 0x616964, 0x616c20, 0x616e20, 0x616e64,
  	                0x617320, 0x617420, 0x617465, 0x617469, 0x642061, 0x642074, 0x652061,
  	                0x652073, 0x652074, 0x656420, 0x656e74, 0x657220, 0x657320, 0x666f72,
  	                0x686174, 0x686520, 0x686572, 0x696420, 0x696e20, 0x696e67, 0x696f6e,
  	                0x697320, 0x6e2061, 0x6e2074, 0x6e6420, 0x6e6720, 0x6e7420, 0x6f6620,
  	                0x6f6e20, 0x6f7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169,
  	                0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696f, 0x746f20,
  	                0x747320,
  	            ]),
  	            new NGramsPlusLang('es', [
  	                0x206120, 0x206361, 0x20636f, 0x206465, 0x20656c, 0x20656e, 0x206573,
  	                0x20696e, 0x206c61, 0x206c6f, 0x207061, 0x20706f, 0x207072, 0x207175,
  	                0x207265, 0x207365, 0x20756e, 0x207920, 0x612063, 0x612064, 0x612065,
  	                0x61206c, 0x612070, 0x616369, 0x61646f, 0x616c20, 0x617220, 0x617320,
  	                0x6369f3, 0x636f6e, 0x646520, 0x64656c, 0x646f20, 0x652064, 0x652065,
  	                0x65206c, 0x656c20, 0x656e20, 0x656e74, 0x657320, 0x657374, 0x69656e,
  	                0x69f36e, 0x6c6120, 0x6c6f73, 0x6e2065, 0x6e7465, 0x6f2064, 0x6f2065,
  	                0x6f6e20, 0x6f7220, 0x6f7320, 0x706172, 0x717565, 0x726120, 0x726573,
  	                0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746f20, 0x756520,
  	                0xf36e20,
  	            ]),
  	            new NGramsPlusLang('fr', [
  	                0x206175, 0x20636f, 0x206461, 0x206465, 0x206475, 0x20656e, 0x206574,
  	                0x206c61, 0x206c65, 0x207061, 0x20706f, 0x207072, 0x207175, 0x207365,
  	                0x20736f, 0x20756e, 0x20e020, 0x616e74, 0x617469, 0x636520, 0x636f6e,
  	                0x646520, 0x646573, 0x647520, 0x652061, 0x652063, 0x652064, 0x652065,
  	                0x65206c, 0x652070, 0x652073, 0x656e20, 0x656e74, 0x657220, 0x657320,
  	                0x657420, 0x657572, 0x696f6e, 0x697320, 0x697420, 0x6c6120, 0x6c6520,
  	                0x6c6573, 0x6d656e, 0x6e2064, 0x6e6520, 0x6e7320, 0x6e7420, 0x6f6e20,
  	                0x6f6e74, 0x6f7572, 0x717565, 0x72206c, 0x726520, 0x732061, 0x732064,
  	                0x732065, 0x73206c, 0x732070, 0x742064, 0x746520, 0x74696f, 0x756520,
  	                0x757220,
  	            ]),
  	            new NGramsPlusLang('it', [
  	                0x20616c, 0x206368, 0x20636f, 0x206465, 0x206469, 0x206520, 0x20696c,
  	                0x20696e, 0x206c61, 0x207065, 0x207072, 0x20756e, 0x612063, 0x612064,
  	                0x612070, 0x612073, 0x61746f, 0x636865, 0x636f6e, 0x64656c, 0x646920,
  	                0x652061, 0x652063, 0x652064, 0x652069, 0x65206c, 0x652070, 0x652073,
  	                0x656c20, 0x656c6c, 0x656e74, 0x657220, 0x686520, 0x692061, 0x692063,
  	                0x692064, 0x692073, 0x696120, 0x696c20, 0x696e20, 0x696f6e, 0x6c6120,
  	                0x6c6520, 0x6c6920, 0x6c6c61, 0x6e6520, 0x6e6920, 0x6e6f20, 0x6e7465,
  	                0x6f2061, 0x6f2064, 0x6f2069, 0x6f2073, 0x6f6e20, 0x6f6e65, 0x706572,
  	                0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746f20,
  	                0x7a696f,
  	            ]),
  	            new NGramsPlusLang('nl', [
  	                0x20616c, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656e,
  	                0x206765, 0x206865, 0x20696e, 0x206d61, 0x206d65, 0x206f70, 0x207465,
  	                0x207661, 0x207665, 0x20766f, 0x207765, 0x207a69, 0x61616e, 0x616172,
  	                0x616e20, 0x616e64, 0x617220, 0x617420, 0x636874, 0x646520, 0x64656e,
  	                0x646572, 0x652062, 0x652076, 0x65656e, 0x656572, 0x656e20, 0x657220,
  	                0x657273, 0x657420, 0x67656e, 0x686574, 0x696520, 0x696e20, 0x696e67,
  	                0x697320, 0x6e2062, 0x6e2064, 0x6e2065, 0x6e2068, 0x6e206f, 0x6e2076,
  	                0x6e6465, 0x6e6720, 0x6f6e64, 0x6f6f72, 0x6f7020, 0x6f7220, 0x736368,
  	                0x737465, 0x742064, 0x746520, 0x74656e, 0x746572, 0x76616e, 0x766572,
  	                0x766f6f,
  	            ]),
  	            new NGramsPlusLang('no', [
  	                0x206174, 0x206176, 0x206465, 0x20656e, 0x206572, 0x20666f, 0x206861,
  	                0x206920, 0x206d65, 0x206f67, 0x2070e5, 0x207365, 0x20736b, 0x20736f,
  	                0x207374, 0x207469, 0x207669, 0x20e520, 0x616e64, 0x617220, 0x617420,
  	                0x646520, 0x64656e, 0x646574, 0x652073, 0x656420, 0x656e20, 0x656e65,
  	                0x657220, 0x657265, 0x657420, 0x657474, 0x666f72, 0x67656e, 0x696b6b,
  	                0x696c20, 0x696e67, 0x6b6520, 0x6b6b65, 0x6c6520, 0x6c6c65, 0x6d6564,
  	                0x6d656e, 0x6e2073, 0x6e6520, 0x6e6720, 0x6e6765, 0x6e6e65, 0x6f6720,
  	                0x6f6d20, 0x6f7220, 0x70e520, 0x722073, 0x726520, 0x736f6d, 0x737465,
  	                0x742073, 0x746520, 0x74656e, 0x746572, 0x74696c, 0x747420, 0x747465,
  	                0x766572,
  	            ]),
  	            new NGramsPlusLang('pt', [
  	                0x206120, 0x20636f, 0x206461, 0x206465, 0x20646f, 0x206520, 0x206573,
  	                0x206d61, 0x206e6f, 0x206f20, 0x207061, 0x20706f, 0x207072, 0x207175,
  	                0x207265, 0x207365, 0x20756d, 0x612061, 0x612063, 0x612064, 0x612070,
  	                0x616465, 0x61646f, 0x616c20, 0x617220, 0x617261, 0x617320, 0x636f6d,
  	                0x636f6e, 0x646120, 0x646520, 0x646f20, 0x646f73, 0x652061, 0x652064,
  	                0x656d20, 0x656e74, 0x657320, 0x657374, 0x696120, 0x696361, 0x6d656e,
  	                0x6e7465, 0x6e746f, 0x6f2061, 0x6f2063, 0x6f2064, 0x6f2065, 0x6f2070,
  	                0x6f7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064,
  	                0x732065, 0x732070, 0x737461, 0x746520, 0x746f20, 0x756520, 0xe36f20,
  	                0xe7e36f,
  	            ]),
  	            new NGramsPlusLang('sv', [
  	                0x206174, 0x206176, 0x206465, 0x20656e, 0x2066f6, 0x206861, 0x206920,
  	                0x20696e, 0x206b6f, 0x206d65, 0x206f63, 0x2070e5, 0x20736b, 0x20736f,
  	                0x207374, 0x207469, 0x207661, 0x207669, 0x20e472, 0x616465, 0x616e20,
  	                0x616e64, 0x617220, 0x617474, 0x636820, 0x646520, 0x64656e, 0x646572,
  	                0x646574, 0x656420, 0x656e20, 0x657220, 0x657420, 0x66f672, 0x67656e,
  	                0x696c6c, 0x696e67, 0x6b6120, 0x6c6c20, 0x6d6564, 0x6e2073, 0x6e6120,
  	                0x6e6465, 0x6e6720, 0x6e6765, 0x6e696e, 0x6f6368, 0x6f6d20, 0x6f6e20,
  	                0x70e520, 0x722061, 0x722073, 0x726120, 0x736b61, 0x736f6d, 0x742073,
  	                0x746120, 0x746520, 0x746572, 0x74696c, 0x747420, 0x766172, 0xe47220,
  	                0xf67220,
  	            ]),
  	        ];
  	    }
  	    name(input) {
  	        return input && input.c1Bytes ? 'windows-1252' : 'ISO-8859-1';
  	    }
  	}
  	sbcs.ISO_8859_1 = ISO_8859_1;
  	class ISO_8859_2 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0xb1, 0x20, 0xb3, 0x20, 0xb5, 0xb6, 0x20,
  	            0x20, 0xb9, 0xba, 0xbb, 0xbc, 0x20, 0xbe, 0xbf, 0x20, 0xb1, 0x20, 0xb3,
  	            0x20, 0xb5, 0xb6, 0xb7, 0x20, 0xb9, 0xba, 0xbb, 0xbc, 0x20, 0xbe, 0xbf,
  	            0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
  	            0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x20,
  	            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x20, 0xf8, 0xf9, 0xfa, 0xfb,
  	            0xfc, 0xfd, 0xfe, 0x20,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            new NGramsPlusLang('cs', [
  	                0x206120, 0x206279, 0x20646f, 0x206a65, 0x206e61, 0x206e65, 0x206f20,
  	                0x206f64, 0x20706f, 0x207072, 0x2070f8, 0x20726f, 0x207365, 0x20736f,
  	                0x207374, 0x20746f, 0x207620, 0x207679, 0x207a61, 0x612070, 0x636520,
  	                0x636820, 0x652070, 0x652073, 0x652076, 0x656d20, 0x656eed, 0x686f20,
  	                0x686f64, 0x697374, 0x6a6520, 0x6b7465, 0x6c6520, 0x6c6920, 0x6e6120,
  	                0x6ee920, 0x6eec20, 0x6eed20, 0x6f2070, 0x6f646e, 0x6f6a69, 0x6f7374,
  	                0x6f7520, 0x6f7661, 0x706f64, 0x706f6a, 0x70726f, 0x70f865, 0x736520,
  	                0x736f75, 0x737461, 0x737469, 0x73746e, 0x746572, 0x746eed, 0x746f20,
  	                0x752070, 0xbe6520, 0xe16eed, 0xe9686f, 0xed2070, 0xed2073, 0xed6d20,
  	                0xf86564,
  	            ]),
  	            new NGramsPlusLang('hu', [
  	                0x206120, 0x20617a, 0x206265, 0x206567, 0x20656c, 0x206665, 0x206861,
  	                0x20686f, 0x206973, 0x206b65, 0x206b69, 0x206bf6, 0x206c65, 0x206d61,
  	                0x206d65, 0x206d69, 0x206e65, 0x20737a, 0x207465, 0x20e973, 0x612061,
  	                0x61206b, 0x61206d, 0x612073, 0x616b20, 0x616e20, 0x617a20, 0x62616e,
  	                0x62656e, 0x656779, 0x656b20, 0x656c20, 0x656c65, 0x656d20, 0x656e20,
  	                0x657265, 0x657420, 0x657465, 0x657474, 0x677920, 0x686f67, 0x696e74,
  	                0x697320, 0x6b2061, 0x6bf67a, 0x6d6567, 0x6d696e, 0x6e2061, 0x6e616b,
  	                0x6e656b, 0x6e656d, 0x6e7420, 0x6f6779, 0x732061, 0x737a65, 0x737a74,
  	                0x737ae1, 0x73e967, 0x742061, 0x747420, 0x74e173, 0x7a6572, 0xe16e20,
  	                0xe97320,
  	            ]),
  	            new NGramsPlusLang('pl', [
  	                0x20637a, 0x20646f, 0x206920, 0x206a65, 0x206b6f, 0x206d61, 0x206d69,
  	                0x206e61, 0x206e69, 0x206f64, 0x20706f, 0x207072, 0x207369, 0x207720,
  	                0x207769, 0x207779, 0x207a20, 0x207a61, 0x612070, 0x612077, 0x616e69,
  	                0x636820, 0x637a65, 0x637a79, 0x646f20, 0x647a69, 0x652070, 0x652073,
  	                0x652077, 0x65207a, 0x65676f, 0x656a20, 0x656d20, 0x656e69, 0x676f20,
  	                0x696120, 0x696520, 0x69656a, 0x6b6120, 0x6b6920, 0x6b6965, 0x6d6965,
  	                0x6e6120, 0x6e6961, 0x6e6965, 0x6f2070, 0x6f7761, 0x6f7769, 0x706f6c,
  	                0x707261, 0x70726f, 0x70727a, 0x727a65, 0x727a79, 0x7369ea, 0x736b69,
  	                0x737461, 0x776965, 0x796368, 0x796d20, 0x7a6520, 0x7a6965, 0x7a7920,
  	                0xf37720,
  	            ]),
  	            new NGramsPlusLang('ro', [
  	                0x206120, 0x206163, 0x206361, 0x206365, 0x20636f, 0x206375, 0x206465,
  	                0x206469, 0x206c61, 0x206d61, 0x207065, 0x207072, 0x207365, 0x2073e3,
  	                0x20756e, 0x20ba69, 0x20ee6e, 0x612063, 0x612064, 0x617265, 0x617420,
  	                0x617465, 0x617520, 0x636172, 0x636f6e, 0x637520, 0x63e320, 0x646520,
  	                0x652061, 0x652063, 0x652064, 0x652070, 0x652073, 0x656120, 0x656920,
  	                0x656c65, 0x656e74, 0x657374, 0x692061, 0x692063, 0x692064, 0x692070,
  	                0x696520, 0x696920, 0x696e20, 0x6c6120, 0x6c6520, 0x6c6f72, 0x6c7569,
  	                0x6e6520, 0x6e7472, 0x6f7220, 0x70656e, 0x726520, 0x726561, 0x727520,
  	                0x73e320, 0x746520, 0x747275, 0x74e320, 0x756920, 0x756c20, 0xba6920,
  	                0xee6e20,
  	            ]),
  	        ];
  	    }
  	    name(det) {
  	        return det && det.c1Bytes ? 'windows-1250' : 'ISO-8859-2';
  	    }
  	}
  	sbcs.ISO_8859_2 = ISO_8859_2;
  	class ISO_8859_5 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
  	            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0x20, 0xfe, 0xff, 0xd0, 0xd1, 0xd2, 0xd3,
  	            0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
  	            0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
  	            0xec, 0xed, 0xee, 0xef, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
  	            0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0x20, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,
  	            0xfc, 0x20, 0xfe, 0xff,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x20d220, 0x20d2de, 0x20d4de, 0x20d7d0, 0x20d820, 0x20dad0, 0x20dade,
  	            0x20ddd0, 0x20ddd5, 0x20ded1, 0x20dfde, 0x20dfe0, 0x20e0d0, 0x20e1de,
  	            0x20e1e2, 0x20e2de, 0x20e7e2, 0x20ede2, 0xd0ddd8, 0xd0e2ec, 0xd3de20,
  	            0xd5dbec, 0xd5ddd8, 0xd5e1e2, 0xd5e220, 0xd820df, 0xd8d520, 0xd8d820,
  	            0xd8ef20, 0xdbd5dd, 0xdbd820, 0xdbecdd, 0xddd020, 0xddd520, 0xddd8d5,
  	            0xddd8ef, 0xddde20, 0xddded2, 0xde20d2, 0xde20df, 0xde20e1, 0xded220,
  	            0xded2d0, 0xded3de, 0xded920, 0xdedbec, 0xdedc20, 0xdee1e2, 0xdfdedb,
  	            0xdfe0d5, 0xdfe0d8, 0xdfe0de, 0xe0d0d2, 0xe0d5d4, 0xe1e2d0, 0xe1e2d2,
  	            0xe1e2d8, 0xe1ef20, 0xe2d5db, 0xe2de20, 0xe2dee0, 0xe2ec20, 0xe7e2de,
  	            0xebe520,
  	        ];
  	    }
  	    name() {
  	        return 'ISO-8859-5';
  	    }
  	    language() {
  	        return 'ru';
  	    }
  	}
  	sbcs.ISO_8859_5 = ISO_8859_5;
  	class ISO_8859_6 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,
  	            0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
  	            0xd8, 0xd9, 0xda, 0x20, 0x20, 0x20, 0x20, 0x20, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x20c7e4, 0x20c7e6, 0x20c8c7, 0x20d9e4, 0x20e1ea, 0x20e4e4, 0x20e5e6,
  	            0x20e8c7, 0xc720c7, 0xc7c120, 0xc7ca20, 0xc7d120, 0xc7e420, 0xc7e4c3,
  	            0xc7e4c7, 0xc7e4c8, 0xc7e4ca, 0xc7e4cc, 0xc7e4cd, 0xc7e4cf, 0xc7e4d3,
  	            0xc7e4d9, 0xc7e4e2, 0xc7e4e5, 0xc7e4e8, 0xc7e4ea, 0xc7e520, 0xc7e620,
  	            0xc7e6ca, 0xc820c7, 0xc920c7, 0xc920e1, 0xc920e4, 0xc920e5, 0xc920e8,
  	            0xca20c7, 0xcf20c7, 0xcfc920, 0xd120c7, 0xd1c920, 0xd320c7, 0xd920c7,
  	            0xd9e4e9, 0xe1ea20, 0xe420c7, 0xe4c920, 0xe4e920, 0xe4ea20, 0xe520c7,
  	            0xe5c720, 0xe5c920, 0xe5e620, 0xe620c7, 0xe720c7, 0xe7c720, 0xe8c7e4,
  	            0xe8e620, 0xe920c7, 0xea20c7, 0xea20e5, 0xea20e8, 0xeac920, 0xead120,
  	            0xeae620,
  	        ];
  	    }
  	    name() {
  	        return 'ISO-8859-6';
  	    }
  	    language() {
  	        return 'ar';
  	    }
  	}
  	sbcs.ISO_8859_6 = ISO_8859_6;
  	class ISO_8859_7 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0xa1, 0xa2, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0xdc, 0x20, 0xdd, 0xde, 0xdf, 0x20, 0xfc, 0x20, 0xfd, 0xfe,
  	            0xc0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
  	            0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0x20, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
  	            0xf8, 0xf9, 0xfa, 0xfb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,
  	            0xfc, 0xfd, 0xfe, 0x20,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x20e1ed, 0x20e1f0, 0x20e3e9, 0x20e4e9, 0x20e5f0, 0x20e720, 0x20eae1,
  	            0x20ece5, 0x20ede1, 0x20ef20, 0x20f0e1, 0x20f0ef, 0x20f0f1, 0x20f3f4,
  	            0x20f3f5, 0x20f4e7, 0x20f4ef, 0xdfe120, 0xe120e1, 0xe120f4, 0xe1e920,
  	            0xe1ed20, 0xe1f0fc, 0xe1f220, 0xe3e9e1, 0xe5e920, 0xe5f220, 0xe720f4,
  	            0xe7ed20, 0xe7f220, 0xe920f4, 0xe9e120, 0xe9eade, 0xe9f220, 0xeae1e9,
  	            0xeae1f4, 0xece520, 0xed20e1, 0xed20e5, 0xed20f0, 0xede120, 0xeff220,
  	            0xeff520, 0xf0eff5, 0xf0f1ef, 0xf0fc20, 0xf220e1, 0xf220e5, 0xf220ea,
  	            0xf220f0, 0xf220f4, 0xf3e520, 0xf3e720, 0xf3f4ef, 0xf4e120, 0xf4e1e9,
  	            0xf4e7ed, 0xf4e7f2, 0xf4e9ea, 0xf4ef20, 0xf4eff5, 0xf4f9ed, 0xf9ed20,
  	            0xfeed20,
  	        ];
  	    }
  	    name(det) {
  	        return det && det.c1Bytes ? 'windows-1253' : 'ISO-8859-7';
  	    }
  	    language() {
  	        return 'el';
  	    }
  	}
  	sbcs.ISO_8859_7 = ISO_8859_7;
  	class ISO_8859_8 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0x20,
  	            0x20, 0x20, 0x20, 0x20,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            new NGramsPlusLang('he', [
  	                0x20e0e5, 0x20e0e7, 0x20e0e9, 0x20e0fa, 0x20e1e9, 0x20e1ee, 0x20e4e0,
  	                0x20e4e5, 0x20e4e9, 0x20e4ee, 0x20e4f2, 0x20e4f9, 0x20e4fa, 0x20ece0,
  	                0x20ece4, 0x20eee0, 0x20f2ec, 0x20f9ec, 0xe0fa20, 0xe420e0, 0xe420e1,
  	                0xe420e4, 0xe420ec, 0xe420ee, 0xe420f9, 0xe4e5e0, 0xe5e020, 0xe5ed20,
  	                0xe5ef20, 0xe5f820, 0xe5fa20, 0xe920e4, 0xe9e420, 0xe9e5fa, 0xe9e9ed,
  	                0xe9ed20, 0xe9ef20, 0xe9f820, 0xe9fa20, 0xec20e0, 0xec20e4, 0xece020,
  	                0xece420, 0xed20e0, 0xed20e1, 0xed20e4, 0xed20ec, 0xed20ee, 0xed20f9,
  	                0xeee420, 0xef20e4, 0xf0e420, 0xf0e920, 0xf0e9ed, 0xf2ec20, 0xf820e4,
  	                0xf8e9ed, 0xf9ec20, 0xfa20e0, 0xfa20e1, 0xfa20e4, 0xfa20ec, 0xfa20ee,
  	                0xfa20f9,
  	            ]),
  	            new NGramsPlusLang('he', [
  	                0x20e0e5, 0x20e0ec, 0x20e4e9, 0x20e4ec, 0x20e4ee, 0x20e4f0, 0x20e9f0,
  	                0x20ecf2, 0x20ecf9, 0x20ede5, 0x20ede9, 0x20efe5, 0x20efe9, 0x20f8e5,
  	                0x20f8e9, 0x20fae0, 0x20fae5, 0x20fae9, 0xe020e4, 0xe020ec, 0xe020ed,
  	                0xe020fa, 0xe0e420, 0xe0e5e4, 0xe0ec20, 0xe0ee20, 0xe120e4, 0xe120ed,
  	                0xe120fa, 0xe420e4, 0xe420e9, 0xe420ec, 0xe420ed, 0xe420ef, 0xe420f8,
  	                0xe420fa, 0xe4ec20, 0xe5e020, 0xe5e420, 0xe7e020, 0xe9e020, 0xe9e120,
  	                0xe9e420, 0xec20e4, 0xec20ed, 0xec20fa, 0xecf220, 0xecf920, 0xede9e9,
  	                0xede9f0, 0xede9f8, 0xee20e4, 0xee20ed, 0xee20fa, 0xeee120, 0xeee420,
  	                0xf2e420, 0xf920e4, 0xf920ed, 0xf920fa, 0xf9e420, 0xfae020, 0xfae420,
  	                0xfae5e9,
  	            ]),
  	        ];
  	    }
  	    name(det) {
  	        return det && det.c1Bytes ? 'windows-1255' : 'ISO-8859-8';
  	    }
  	    language() {
  	        return 'he';
  	    }
  	}
  	sbcs.ISO_8859_8 = ISO_8859_8;
  	class ISO_8859_9 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0xaa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0xba, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
  	            0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x20,
  	            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0x69, 0xfe, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0x20, 0xf8, 0xf9, 0xfa, 0xfb,
  	            0xfc, 0xfd, 0xfe, 0xff,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861,
  	            0x20696c, 0x206b61, 0x206b6f, 0x206d61, 0x206f6c, 0x207361, 0x207461,
  	            0x207665, 0x207961, 0x612062, 0x616b20, 0x616c61, 0x616d61, 0x616e20,
  	            0x616efd, 0x617220, 0x617261, 0x6172fd, 0x6173fd, 0x617961, 0x626972,
  	            0x646120, 0x646520, 0x646920, 0x652062, 0x65206b, 0x656469, 0x656e20,
  	            0x657220, 0x657269, 0x657369, 0x696c65, 0x696e20, 0x696e69, 0x697220,
  	            0x6c616e, 0x6c6172, 0x6c6520, 0x6c6572, 0x6e2061, 0x6e2062, 0x6e206b,
  	            0x6e6461, 0x6e6465, 0x6e6520, 0x6e6920, 0x6e696e, 0x6efd20, 0x72696e,
  	            0x72fd6e, 0x766520, 0x796120, 0x796f72, 0xfd6e20, 0xfd6e64, 0xfd6efd,
  	            0xfdf0fd,
  	        ];
  	    }
  	    name(det) {
  	        return det && det.c1Bytes ? 'windows-1254' : 'ISO-8859-9';
  	    }
  	    language() {
  	        return 'tr';
  	    }
  	}
  	sbcs.ISO_8859_9 = ISO_8859_9;
  	class windows_1251 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x90, 0x83, 0x20, 0x83,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x9a, 0x20, 0x9c, 0x9d, 0x9e, 0x9f,
  	            0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x9a, 0x20,
  	            0x9c, 0x9d, 0x9e, 0x9f, 0x20, 0xa2, 0xa2, 0xbc, 0x20, 0xb4, 0x20, 0x20,
  	            0xb8, 0x20, 0xba, 0x20, 0x20, 0x20, 0x20, 0xbf, 0x20, 0x20, 0xb3, 0xb3,
  	            0xb4, 0xb5, 0x20, 0x20, 0xb8, 0x20, 0xba, 0x20, 0xbc, 0xbe, 0xbe, 0xbf,
  	            0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
  	            0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
  	            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,
  	            0xfc, 0xfd, 0xfe, 0xff,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x20e220, 0x20e2ee, 0x20e4ee, 0x20e7e0, 0x20e820, 0x20eae0, 0x20eaee,
  	            0x20ede0, 0x20ede5, 0x20eee1, 0x20efee, 0x20eff0, 0x20f0e0, 0x20f1ee,
  	            0x20f1f2, 0x20f2ee, 0x20f7f2, 0x20fdf2, 0xe0ede8, 0xe0f2fc, 0xe3ee20,
  	            0xe5ebfc, 0xe5ede8, 0xe5f1f2, 0xe5f220, 0xe820ef, 0xe8e520, 0xe8e820,
  	            0xe8ff20, 0xebe5ed, 0xebe820, 0xebfced, 0xede020, 0xede520, 0xede8e5,
  	            0xede8ff, 0xedee20, 0xedeee2, 0xee20e2, 0xee20ef, 0xee20f1, 0xeee220,
  	            0xeee2e0, 0xeee3ee, 0xeee920, 0xeeebfc, 0xeeec20, 0xeef1f2, 0xefeeeb,
  	            0xeff0e5, 0xeff0e8, 0xeff0ee, 0xf0e0e2, 0xf0e5e4, 0xf1f2e0, 0xf1f2e2,
  	            0xf1f2e8, 0xf1ff20, 0xf2e5eb, 0xf2ee20, 0xf2eef0, 0xf2fc20, 0xf7f2ee,
  	            0xfbf520,
  	        ];
  	    }
  	    name() {
  	        return 'windows-1251';
  	    }
  	    language() {
  	        return 'ru';
  	    }
  	}
  	sbcs.windows_1251 = windows_1251;
  	class windows_1256 extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x81, 0x20, 0x83,
  	            0x20, 0x20, 0x20, 0x20, 0x88, 0x20, 0x8a, 0x20, 0x9c, 0x8d, 0x8e, 0x8f,
  	            0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x98, 0x20, 0x9a, 0x20,
  	            0x9c, 0x20, 0x20, 0x9f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0xaa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,
  	            0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0x20,
  	            0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  	            0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
  	            0x20, 0x20, 0x20, 0x20, 0xf4, 0x20, 0x20, 0x20, 0x20, 0xf9, 0x20, 0xfb,
  	            0xfc, 0x20, 0x20, 0xff,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x20c7e1, 0x20c7e4, 0x20c8c7, 0x20dae1, 0x20dded, 0x20e1e1, 0x20e3e4,
  	            0x20e6c7, 0xc720c7, 0xc7c120, 0xc7ca20, 0xc7d120, 0xc7e120, 0xc7e1c3,
  	            0xc7e1c7, 0xc7e1c8, 0xc7e1ca, 0xc7e1cc, 0xc7e1cd, 0xc7e1cf, 0xc7e1d3,
  	            0xc7e1da, 0xc7e1de, 0xc7e1e3, 0xc7e1e6, 0xc7e1ed, 0xc7e320, 0xc7e420,
  	            0xc7e4ca, 0xc820c7, 0xc920c7, 0xc920dd, 0xc920e1, 0xc920e3, 0xc920e6,
  	            0xca20c7, 0xcf20c7, 0xcfc920, 0xd120c7, 0xd1c920, 0xd320c7, 0xda20c7,
  	            0xdae1ec, 0xdded20, 0xe120c7, 0xe1c920, 0xe1ec20, 0xe1ed20, 0xe320c7,
  	            0xe3c720, 0xe3c920, 0xe3e420, 0xe420c7, 0xe520c7, 0xe5c720, 0xe6c7e1,
  	            0xe6e420, 0xec20c7, 0xed20c7, 0xed20e3, 0xed20e6, 0xedc920, 0xedd120,
  	            0xede420,
  	        ];
  	    }
  	    name() {
  	        return 'windows-1256';
  	    }
  	    language() {
  	        return 'ar';
  	    }
  	}
  	sbcs.windows_1256 = windows_1256;
  	class KOI8_R extends sbcs$1 {
  	    byteMap() {
  	        return [
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  	            0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
  	            0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  	            0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  	            0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xa3, 0x20, 0x20, 0x20, 0x20,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xa3,
  	            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  	            0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,
  	            0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
  	            0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xc0, 0xc1, 0xc2, 0xc3,
  	            0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
  	            0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
  	            0xdc, 0xdd, 0xde, 0xdf,
  	        ];
  	    }
  	    ngrams() {
  	        return [
  	            0x20c4cf, 0x20c920, 0x20cbc1, 0x20cbcf, 0x20cec1, 0x20cec5, 0x20cfc2,
  	            0x20d0cf, 0x20d0d2, 0x20d2c1, 0x20d3cf, 0x20d3d4, 0x20d4cf, 0x20d720,
  	            0x20d7cf, 0x20dac1, 0x20dcd4, 0x20ded4, 0xc1cec9, 0xc1d4d8, 0xc5ccd8,
  	            0xc5cec9, 0xc5d3d4, 0xc5d420, 0xc7cf20, 0xc920d0, 0xc9c520, 0xc9c920,
  	            0xc9d120, 0xccc5ce, 0xccc920, 0xccd8ce, 0xcec120, 0xcec520, 0xcec9c5,
  	            0xcec9d1, 0xcecf20, 0xcecfd7, 0xcf20d0, 0xcf20d3, 0xcf20d7, 0xcfc7cf,
  	            0xcfca20, 0xcfccd8, 0xcfcd20, 0xcfd3d4, 0xcfd720, 0xcfd7c1, 0xd0cfcc,
  	            0xd0d2c5, 0xd0d2c9, 0xd0d2cf, 0xd2c1d7, 0xd2c5c4, 0xd3d120, 0xd3d4c1,
  	            0xd3d4c9, 0xd3d4d7, 0xd4c5cc, 0xd4cf20, 0xd4cfd2, 0xd4d820, 0xd9c820,
  	            0xded4cf,
  	        ];
  	    }
  	    name() {
  	        return 'KOI8-R';
  	    }
  	    language() {
  	        return 'ru';
  	    }
  	}
  	sbcs.KOI8_R = KOI8_R;
  	
  	return sbcs;
  }

  var iso2022 = {};

  var hasRequiredIso2022;

  function requireIso2022 () {
  	if (hasRequiredIso2022) return iso2022;
  	hasRequiredIso2022 = 1;
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(iso2022, "__esModule", { value: true });
  	iso2022.ISO_2022_CN = iso2022.ISO_2022_KR = iso2022.ISO_2022_JP = void 0;
  	const match_1 = __importDefault(requireMatch());
  	class ISO_2022 {
  	    constructor() {
  	        this.escapeSequences = [];
  	    }
  	    name() {
  	        return 'ISO_2022';
  	    }
  	    match(det) {
  	        let i, j;
  	        let escN;
  	        let hits = 0;
  	        let misses = 0;
  	        let shifts = 0;
  	        let confidence;
  	        const text = det.inputBytes;
  	        const textLen = det.inputLen;
  	        scanInput: for (i = 0; i < textLen; i++) {
  	            if (text[i] == 0x1b) {
  	                checkEscapes: for (escN = 0; escN < this.escapeSequences.length; escN++) {
  	                    const seq = this.escapeSequences[escN];
  	                    if (textLen - i < seq.length)
  	                        continue checkEscapes;
  	                    for (j = 1; j < seq.length; j++)
  	                        if (seq[j] != text[i + j])
  	                            continue checkEscapes;
  	                    hits++;
  	                    i += seq.length - 1;
  	                    continue scanInput;
  	                }
  	                misses++;
  	            }
  	            if (text[i] == 0x0e || text[i] == 0x0f)
  	                shifts++;
  	        }
  	        if (hits == 0)
  	            return null;
  	        confidence = (100 * hits - 100 * misses) / (hits + misses);
  	        if (hits + shifts < 5)
  	            confidence -= (5 - (hits + shifts)) * 10;
  	        return confidence <= 0 ? null : (0, match_1.default)(det, this, confidence);
  	    }
  	}
  	class ISO_2022_JP extends ISO_2022 {
  	    constructor() {
  	        super(...arguments);
  	        this.escapeSequences = [
  	            [0x1b, 0x24, 0x28, 0x43],
  	            [0x1b, 0x24, 0x28, 0x44],
  	            [0x1b, 0x24, 0x40],
  	            [0x1b, 0x24, 0x41],
  	            [0x1b, 0x24, 0x42],
  	            [0x1b, 0x26, 0x40],
  	            [0x1b, 0x28, 0x42],
  	            [0x1b, 0x28, 0x48],
  	            [0x1b, 0x28, 0x49],
  	            [0x1b, 0x28, 0x4a],
  	            [0x1b, 0x2e, 0x41],
  	            [0x1b, 0x2e, 0x46],
  	        ];
  	    }
  	    name() {
  	        return 'ISO-2022-JP';
  	    }
  	    language() {
  	        return 'ja';
  	    }
  	}
  	iso2022.ISO_2022_JP = ISO_2022_JP;
  	class ISO_2022_KR extends ISO_2022 {
  	    constructor() {
  	        super(...arguments);
  	        this.escapeSequences = [[0x1b, 0x24, 0x29, 0x43]];
  	    }
  	    name() {
  	        return 'ISO-2022-KR';
  	    }
  	    language() {
  	        return 'kr';
  	    }
  	}
  	iso2022.ISO_2022_KR = ISO_2022_KR;
  	class ISO_2022_CN extends ISO_2022 {
  	    constructor() {
  	        super(...arguments);
  	        this.escapeSequences = [
  	            [0x1b, 0x24, 0x29, 0x41],
  	            [0x1b, 0x24, 0x29, 0x47],
  	            [0x1b, 0x24, 0x2a, 0x48],
  	            [0x1b, 0x24, 0x29, 0x45],
  	            [0x1b, 0x24, 0x2b, 0x49],
  	            [0x1b, 0x24, 0x2b, 0x4a],
  	            [0x1b, 0x24, 0x2b, 0x4b],
  	            [0x1b, 0x24, 0x2b, 0x4c],
  	            [0x1b, 0x24, 0x2b, 0x4d],
  	            [0x1b, 0x4e],
  	            [0x1b, 0x4f],
  	        ];
  	    }
  	    name() {
  	        return 'ISO-2022-CN';
  	    }
  	    language() {
  	        return 'zh';
  	    }
  	}
  	iso2022.ISO_2022_CN = ISO_2022_CN;
  	
  	return iso2022;
  }

  var utils = {};

  var hasRequiredUtils;

  function requireUtils () {
  	if (hasRequiredUtils) return utils;
  	hasRequiredUtils = 1;
  	Object.defineProperty(utils, "__esModule", { value: true });
  	utils.isByteArray = void 0;
  	const isByteArray = (input) => {
  	    if (input == null || typeof input != 'object')
  	        return false;
  	    return isFinite(input.length) && input.length >= 0;
  	};
  	utils.isByteArray = isByteArray;
  	
  	return utils;
  }

  var hasRequiredLib;

  function requireLib () {
  	if (hasRequiredLib) return lib;
  	hasRequiredLib = 1;
  	(function (exports) {
  		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    var desc = Object.getOwnPropertyDescriptor(m, k);
  		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
  		      desc = { enumerable: true, get: function() { return m[k]; } };
  		    }
  		    Object.defineProperty(o, k2, desc);
  		}) : (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    o[k2] = m[k];
  		}));
  		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
  		    Object.defineProperty(o, "default", { enumerable: true, value: v });
  		}) : function(o, v) {
  		    o["default"] = v;
  		});
  		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
  		    if (mod && mod.__esModule) return mod;
  		    var result = {};
  		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  		    __setModuleDefault(result, mod);
  		    return result;
  		};
  		var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  		    return (mod && mod.__esModule) ? mod : { "default": mod };
  		};
  		Object.defineProperty(exports, "__esModule", { value: true });
  		exports.detectFileSync = exports.detectFile = exports.analyse = exports.detect = void 0;
  		const node_1 = __importDefault(requireBrowser());
  		const ascii_1 = __importDefault(requireAscii());
  		const utf8_1 = __importDefault(requireUtf8());
  		const unicode = __importStar(requireUnicode());
  		const mbcs = __importStar(requireMbcs());
  		const sbcs = __importStar(requireSbcs());
  		const iso2022 = __importStar(requireIso2022());
  		const utils_1 = requireUtils();
  		const recognisers = [
  		    new utf8_1.default(),
  		    new unicode.UTF_16BE(),
  		    new unicode.UTF_16LE(),
  		    new unicode.UTF_32BE(),
  		    new unicode.UTF_32LE(),
  		    new mbcs.sjis(),
  		    new mbcs.big5(),
  		    new mbcs.euc_jp(),
  		    new mbcs.euc_kr(),
  		    new mbcs.gb_18030(),
  		    new iso2022.ISO_2022_JP(),
  		    new iso2022.ISO_2022_KR(),
  		    new iso2022.ISO_2022_CN(),
  		    new sbcs.ISO_8859_1(),
  		    new sbcs.ISO_8859_2(),
  		    new sbcs.ISO_8859_5(),
  		    new sbcs.ISO_8859_6(),
  		    new sbcs.ISO_8859_7(),
  		    new sbcs.ISO_8859_8(),
  		    new sbcs.ISO_8859_9(),
  		    new sbcs.windows_1251(),
  		    new sbcs.windows_1256(),
  		    new sbcs.KOI8_R(),
  		    new ascii_1.default(),
  		];
  		const detect = (buffer) => {
  		    const matches = (0, exports.analyse)(buffer);
  		    return matches.length > 0 ? matches[0].name : null;
  		};
  		exports.detect = detect;
  		const analyse = (buffer) => {
  		    if (!(0, utils_1.isByteArray)(buffer)) {
  		        throw new Error('Input must be a byte array, e.g. Buffer or Uint8Array');
  		    }
  		    const byteStats = [];
  		    for (let i = 0; i < 256; i++)
  		        byteStats[i] = 0;
  		    for (let i = buffer.length - 1; i >= 0; i--)
  		        byteStats[buffer[i] & 0x00ff]++;
  		    let c1Bytes = false;
  		    for (let i = 0x80; i <= 0x9f; i += 1) {
  		        if (byteStats[i] !== 0) {
  		            c1Bytes = true;
  		            break;
  		        }
  		    }
  		    const context = {
  		        byteStats,
  		        c1Bytes,
  		        rawInput: buffer,
  		        rawLen: buffer.length,
  		        inputBytes: buffer,
  		        inputLen: buffer.length,
  		    };
  		    const matches = recognisers
  		        .map((rec) => {
  		        return rec.match(context);
  		    })
  		        .filter((match) => {
  		        return !!match;
  		    })
  		        .sort((a, b) => {
  		        return b.confidence - a.confidence;
  		    });
  		    return matches;
  		};
  		exports.analyse = analyse;
  		const detectFile = (filepath, opts = {}) => new Promise((resolve, reject) => {
  		    let fd;
  		    const fs = (0, node_1.default)();
  		    const handler = (err, buffer) => {
  		        if (fd) {
  		            fs.closeSync(fd);
  		        }
  		        if (err) {
  		            reject(err);
  		        }
  		        else {
  		            resolve((0, exports.detect)(buffer));
  		        }
  		    };
  		    if (opts && opts.sampleSize) {
  		        fd = fs.openSync(filepath, 'r');
  		        const sample = Buffer.allocUnsafe(opts.sampleSize);
  		        fs.read(fd, sample, 0, opts.sampleSize, opts.offset, (err) => {
  		            handler(err, sample);
  		        });
  		        return;
  		    }
  		    fs.readFile(filepath, handler);
  		});
  		exports.detectFile = detectFile;
  		const detectFileSync = (filepath, opts = {}) => {
  		    const fs = (0, node_1.default)();
  		    if (opts && opts.sampleSize) {
  		        const fd = fs.openSync(filepath, 'r');
  		        const sample = Buffer.allocUnsafe(opts.sampleSize);
  		        fs.readSync(fd, sample, 0, opts.sampleSize, opts.offset);
  		        fs.closeSync(fd);
  		        return (0, exports.detect)(sample);
  		    }
  		    return (0, exports.detect)(fs.readFileSync(filepath));
  		};
  		exports.detectFileSync = detectFileSync;
  		exports.default = {
  		    analyse: exports.analyse,
  		    detect: exports.detect,
  		    detectFileSync: exports.detectFileSync,
  		    detectFile: exports.detectFile,
  		};
  		
  	} (lib));
  	return lib;
  }

  irc$1.Client = Client$3;
  var net  = require$$0$2;
  var tls  = require$$1$3;
  var util$1 = require$$2$1;
  var EventEmitter$5 = require$$1$2;

  var colors = colors$1;
  var parseMessage = parse_message;
  irc$1.colors = colors;
  var CyclingPingTimer = cycling_ping_timer;

  var lineDelimiter = new RegExp(/\r\n|\r|\n/);

  function Client$3(server, clientNick, opt) {
      var self = this;
      self.opt = {
          server: server,
          nick: clientNick,
          userName: 'nodebot',
          realName: 'nodeJS IRC client',
          password: null,
          port: 6667,
          localAddress: null,
          debug: false,
          showErrors: false,
          channels: [],
          autoRejoin: false,
          autoRenick: false,
          autoConnect: true,
          retryCount: null,
          retryDelay: 2000,
          renickCount: null,
          renickDelay: 60000,
          secure: false,
          selfSigned: false,
          certExpired: false,
          floodProtection: false,
          floodProtectionDelay: 1000,
          sasl: false,
          webirc: {
              pass: '',
              ip: '',
              host: ''
          },
          stripColors: false,
          channelPrefixes: '&#',
          messageSplit: 512,
          encoding: null,
          millisecondsOfSilenceBeforePingSent: 15 * 1000,
          millisecondsBeforePingTimeout: 8 * 1000,
          enableStrictParse: false
      };

      // Features supported by the server
      // (Initial values are RFC 1459 defaults. Zeros signify no default or unlimited value.)
      self.supported = {
          channel: {
              idlength: {},
              length: 200,
              limit: [],
              modes: { a: '', b: '', c: '', d: ''},
              types: self.opt.channelPrefixes
          },
          kicklength: 0,
          maxlist: [],
          maxtargets: {},
          modes: 3,
          nicklength: 9,
          topiclength: 0,
          usermodes: ''
      };

      if (typeof opt === 'object') {
          var keys = Object.keys(self.opt);
          keys.forEach(function(k) {
              if (typeof opt[k] !== 'undefined') {
                  self.opt[k] = opt[k];
              }
          });
      }

      // Instead of wrapping every debug call in a guard, provide debug and error methods for the client.
      self.out = {
          showErrors: self.opt.showErrors,
          showDebug: self.opt.debug
      };
      self.out.error = function() {
          if (!this.showDebug && !this.showErrors) return;
          // '\u001b[01;31mERROR: ' + errorObjs + '\u001b[0m'
          var args = Array.prototype.slice.call(arguments);
          args.unshift('\u001b[01;31mERROR:'); args.push('\u001b[0m');
          util$1.log.apply(util$1, args);
      };
      self.out.debug = function() {
          if (!this.showDebug) return;
          util$1.log.apply(util$1, arguments);
      };


      if (self.opt.floodProtection) {
          self.activateFloodProtection();
      }

      self.hostMask = '';

      // TODO - fail if nick or server missing
      // TODO - fail if username has a space in it
      if (self.opt.autoConnect === true) {
          self.connect();
      }

      self.addListener('raw', function(message) {
          var channels = [],
              channel,
              nick,
              from,
              text,
              to;

          switch (message.command) {
              case 'rpl_welcome':
                  // Set nick to whatever the server decided it really is
                  // (normally this is because you chose something too long and the server has shortened it)
                  self.nick = message.args[0];
                  // Note our hostmask to use it in splitting long messages
                  // We don't send our hostmask when issuing PRIVMSGs or NOTICEs, but servers on the other side will include it in messages and will truncate what we send accordingly
                  var welcomeStringWords = message.args[1].split(/\s+/);
                  self.hostMask = welcomeStringWords[welcomeStringWords.length - 1];
                  self._updateMaxLineLength();
                  self.emit('registered', message);
                  self.whois(self.nick, function(args) {
                      self.nick = args.nick;
                      self.hostMask = args.user + '@' + args.host;
                      self._updateMaxLineLength();
                  });
                  break;
              case 'rpl_myinfo':
                  self.supported.usermodes = message.args[3];
                  break;
              case 'rpl_isupport':
                  message.args.forEach(function(arg) {
                      var match;
                      match = arg.match(/([A-Z]+)=(.*)/);
                      if (match) {
                          var param = match[1];
                          var value = match[2];
                          switch (param) {
                              case 'CHANLIMIT':
                                  value.split(',').forEach(function(val) {
                                      val = val.split(':');
                                      self.supported.channel.limit[val[0]] = parseInt(val[1]);
                                  });
                                  break;
                              case 'CHANMODES':
                                  value = value.split(',');
                                  var type = ['a', 'b', 'c', 'd'];
                                  for (var i = 0; i < type.length; i++) {
                                      self.supported.channel.modes[type[i]] += value[i];
                                  }
                                  break;
                              case 'CHANTYPES':
                                  self.supported.channel.types = value;
                                  break;
                              case 'CHANNELLEN':
                                  self.supported.channel.length = parseInt(value);
                                  break;
                              case 'IDCHAN':
                                  value.split(',').forEach(function(val) {
                                      val = val.split(':');
                                      self.supported.channel.idlength[val[0]] = parseInt(val[1]);
                                  });
                                  break;
                              case 'KICKLEN':
                                  self.supported.kicklength = parseInt(value);
                                  break;
                              case 'MAXLIST':
                                  value.split(',').forEach(function(val) {
                                      val = val.split(':');
                                      self.supported.maxlist[val[0]] = parseInt(val[1]);
                                  });
                                  break;
                              case 'NICKLEN':
                                  self.supported.nicklength = parseInt(value);
                                  break;
                              case 'PREFIX':
                                  match = value.match(/\((.*?)\)(.*)/);
                                  if (match) {
                                      match[1] = match[1].split('');
                                      match[2] = match[2].split('');
                                      while (match[1].length) {
                                          self.modeForPrefix[match[2][0]] = match[1][0];
                                          self.supported.channel.modes.b += match[1][0];
                                          self.prefixForMode[match[1].shift()] = match[2].shift();
                                      }
                                  }
                                  break;
                              case 'TARGMAX':
                                  value.split(',').forEach(function(val) {
                                      val = val.split(':');
                                      val[1] = (!val[1]) ? 0 : parseInt(val[1]);
                                      self.supported.maxtargets[val[0]] = val[1];
                                  });
                                  break;
                              case 'TOPICLEN':
                                  self.supported.topiclength = parseInt(value);
                                  break;
                          }
                      }
                  });
                  break;
              case 'rpl_yourhost':
              case 'rpl_created':
              case 'rpl_luserclient':
              case 'rpl_luserop':
              case 'rpl_luserchannels':
              case 'rpl_luserme':
              case 'rpl_localusers':
              case 'rpl_globalusers':
              case 'rpl_statsconn':
              case 'rpl_luserunknown':
              case 'rpl_whoishost':
              case '396':
              case '042':
                  // Random welcome stuff, ignoring
                  break;
              case 'err_nicknameinuse':
                  if (typeof self.opt.nickMod === 'undefined')
                      self.opt.nickMod = 0;
                  if (message.args[1] === self.opt.nick && (self.conn.renickInterval || self.conn.attemptedLastRenick)) {
                      self.out.debug('Attempted to automatically renick to', message.args[1], 'and found it taken');
                      break;
                  }
                  self.opt.nickMod++;
                  self.send('NICK', self.opt.nick + self.opt.nickMod);
                  self.nick = self.opt.nick + self.opt.nickMod;
                  self._updateMaxLineLength();
                  if (self.opt.autoRenick) {
                      var renickTimes = 0;
                      self.cancelAutoRenick();
                      self.conn.renickInterval = setInterval(function() {
                          if (self.nick === self.opt.nick) {
                              self.out.debug('Attempted to automatically renick to', self.nick, 'and found that was the current nick');
                              self.cancelAutoRenick();
                              return;
                          }
                          self.send('NICK', self.opt.nick);
                          renickTimes++;
                          if (self.opt.renickCount !== null && renickTimes >= self.opt.renickCount) {
                              self.out.debug('Maximum autorenick retry count (' + self.opt.renickCount + ') reached');
                              self.cancelAutoRenick();
                              self.conn.attemptedLastRenick = true;
                          }
                      }, self.opt.renickDelay);
                  }
                  break;
              case 'PING':
                  self.send('PONG', message.args[0]);
                  self.emit('ping', message.args[0]);
                  break;
              case 'PONG':
                  self.emit('pong', message.args[0]);
                  break;
              case 'NOTICE':
                  from = message.nick;
                  to = message.args[0];
                  if (!to) {
                      to = null;
                  }
                  text = message.args[1] || '';
                  if (text[0] === '\u0001' && text.lastIndexOf('\u0001') > 0) {
                      self._handleCTCP(from, to, text, 'notice', message);
                      break;
                  }
                  self.emit('notice', from, to, text, message);

                  if (to === self.nick)
                      self.out.debug('GOT NOTICE from ' + (from ? '"' + from + '"' : 'the server') + ': "' + text + '"');
                  break;
              case 'MODE':
                  self.out.debug('MODE: ' + message.args[0] + ' sets mode: ' + message.args[1]);

                  channel = self.chanData(message.args[0]);
                  if (!channel) break;
                  var modeList = message.args[1].split('');
                  var adding = true;
                  var modeArgs = message.args.slice(2);
                  var chanModes = function(mode, param) {
                      var arr = param && Array.isArray(param);
                      if (adding) {
                          if (channel.mode.indexOf(mode) === -1) {
                              channel.mode += mode;
                          }
                          if (typeof param === 'undefined') {
                              channel.modeParams[mode] = [];
                          } else if (arr) {
                              channel.modeParams[mode] = channel.modeParams[mode] ?
                                  channel.modeParams[mode].concat(param) : param;
                          } else {
                              channel.modeParams[mode] = [param];
                          }
                      } else if (mode in channel.modeParams) {
                          if (arr) {
                              channel.modeParams[mode] = channel.modeParams[mode]
                                  .filter(function(v) { return v !== param[0]; });
                          }
                          if (!arr || channel.modeParams[mode].length === 0) {
                              channel.mode = channel.mode.replace(mode, '');
                              delete channel.modeParams[mode];
                          }
                      }
                  };
                  modeList.forEach(function(mode) {
                      if (mode === '+') {
                          adding = true;
                          return;
                      }
                      if (mode === '-') {
                          adding = false;
                          return;
                      }

                      var eventName = (adding ? '+' : '-') + 'mode';
                      var supported = self.supported.channel.modes;
                      var modeArg;
                      if (mode in self.prefixForMode) {
                          modeArg = modeArgs.shift();
                          if (Object.prototype.hasOwnProperty.call(channel.users, modeArg)) {
                              if (adding) {
                                  if (channel.users[modeArg].indexOf(self.prefixForMode[mode]) === -1)
                                      channel.users[modeArg] += self.prefixForMode[mode];
                              } else channel.users[modeArg] = channel.users[modeArg].replace(self.prefixForMode[mode], '');
                          }
                          self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
                      } else if (supported.a.indexOf(mode) !== -1) {
                          modeArg = modeArgs.shift();
                          chanModes(mode, [modeArg]);
                          self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
                      } else if (supported.b.indexOf(mode) !== -1) {
                          modeArg = modeArgs.shift();
                          chanModes(mode, modeArg);
                          self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
                      } else if (supported.c.indexOf(mode) !== -1) {
                          if (adding) modeArg = modeArgs.shift();
                          else modeArg = undefined;
                          chanModes(mode, modeArg);
                          self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
                      } else if (supported.d.indexOf(mode) !== -1) {
                          chanModes(mode);
                          self.emit(eventName, message.args[0], message.nick, mode, undefined, message);
                      }
                  });
                  break;
              case 'NICK':
                  if (message.nick === self.nick) {
                      // client just changed own nick
                      self.nick = message.args[0];
                      self.cancelAutoRenick();
                      self._updateMaxLineLength();
                  }

                  self.out.debug('NICK: ' + message.nick + ' changes nick to ' + message.args[0]);

                  channels = [];

                  // Figure out what channels the user is in, update relevant nicks
                  Object.keys(self.chans).forEach(function(channame) {
                      var chan = self.chans[channame];
                      if (message.nick in chan.users) {
                          chan.users[message.args[0]] = chan.users[message.nick];
                          delete chan.users[message.nick];
                          channels.push(channame);
                      }
                  });

                  // old nick, new nick, channels
                  self.emit('nick', message.nick, message.args[0], channels, message);
                  break;
              case 'rpl_motdstart':
                  self.motd = message.args[1] + '\n';
                  break;
              case 'rpl_motd':
                  self.motd += message.args[1] + '\n';
                  break;
              case 'rpl_endofmotd':
              case 'err_nomotd':
                  self.motd += message.args[1] + '\n';
                  self.emit('motd', self.motd);
                  break;
              case 'rpl_namreply':
                  channel = self.chanData(message.args[2]);
                  var users = message.args[3].trim().split(/ +/);
                  if (channel) {
                      users.forEach(function(user) {
                          var match = user.match(/^(.)(.*)$/);
                          if (match) {
                              if (match[1] in self.modeForPrefix) {
                                  channel.users[match[2]] = match[1];
                              }
                              else {
                                  channel.users[match[1] + match[2]] = '';
                              }
                          }
                      });
                  }
                  break;
              case 'rpl_endofnames':
                  channel = self.chanData(message.args[1]);
                  if (channel) {
                      self.emitChannelEvent('names', message.args[1], channel.users);
                      self.send('MODE', message.args[1]);
                  }
                  break;
              case 'rpl_topic':
                  channel = self.chanData(message.args[1]);
                  if (channel) {
                      channel.topic = message.args[2];
                  }
                  break;
              case 'rpl_away':
                  self._addWhoisData(message.args[1], 'away', message.args[2], true);
                  break;
              case 'rpl_whoisuser':
                  self._addWhoisData(message.args[1], 'user', message.args[2]);
                  self._addWhoisData(message.args[1], 'host', message.args[3]);
                  self._addWhoisData(message.args[1], 'realname', message.args[5]);
                  break;
              case 'rpl_whoisidle':
                  self._addWhoisData(message.args[1], 'idle', message.args[2]);
                  break;
              case 'rpl_whoischannels':
                  // TODO - clean this up?
                  self._addWhoisData(message.args[1], 'channels', message.args[2].trim().split(/\s+/));
                  break;
              case 'rpl_whoisserver':
                  self._addWhoisData(message.args[1], 'server', message.args[2]);
                  self._addWhoisData(message.args[1], 'serverinfo', message.args[3]);
                  break;
              case 'rpl_whoisoperator':
                  self._addWhoisData(message.args[1], 'operator', message.args[2]);
                  break;
              case '330': // rpl_whoisaccount?
                  self._addWhoisData(message.args[1], 'account', message.args[2]);
                  self._addWhoisData(message.args[1], 'accountinfo', message.args[3]);
                  break;
              case 'rpl_endofwhois':
                  self.emit('whois', self._clearWhoisData(message.args[1]));
                  break;
              case 'rpl_whoreply':
                  self._addWhoisData(message.args[5], 'user', message.args[2]);
                  self._addWhoisData(message.args[5], 'host', message.args[3]);
                  self._addWhoisData(message.args[5], 'server', message.args[4]);
                  self._addWhoisData(message.args[5], 'realname', /[0-9]+\s*(.+)/g.exec(message.args[7])[1]);
                  // emit right away because rpl_endofwho doesn't contain nick
                  self.emit('whois', self._clearWhoisData(message.args[5]));
                  break;
              case 'rpl_liststart':
                  self.channellist = [];
                  self.emit('channellist_start');
                  break;
              case 'rpl_list':
                  channel = {
                      name: message.args[1],
                      users: message.args[2],
                      topic: message.args[3]
                  };
                  self.emit('channellist_item', channel);
                  self.channellist.push(channel);
                  break;
              case 'rpl_listend':
                  self.emit('channellist', self.channellist);
                  break;
              case 'rpl_topicwhotime':
                  channel = self.chanData(message.args[1]);
                  if (channel) {
                      channel.topicBy = message.args[2];
                      // channel, topic, nick
                      self.emit('topic', message.args[1], channel.topic, channel.topicBy, message);
                  }
                  break;
              case 'TOPIC':
                  // channel, topic, nick
                  self.emit('topic', message.args[0], message.args[1], message.nick, message);

                  channel = self.chanData(message.args[0]);
                  if (channel) {
                      channel.topic = message.args[1];
                      channel.topicBy = message.nick;
                  }
                  break;
              case 'rpl_channelmodeis':
                  channel = self.chanData(message.args[1]);
                  if (channel) {
                      channel.mode = message.args[2];
                  }
                  break;
              case 'rpl_creationtime':
                  channel = self.chanData(message.args[1]);
                  if (channel) {
                      channel.created = message.args[2];
                  }
                  break;
              case 'JOIN':
                  // channel, who
                  if (self.nick === message.nick) {
                      self.chanData(message.args[0], true);
                  } else {
                      channel = self.chanData(message.args[0]);
                      if (channel && channel.users) {
                          channel.users[message.nick] = '';
                      }
                  }
                  self.emitChannelEvent('join', message.args[0], message.nick, message);
                  break;
              case 'PART':
                  // channel, who, reason
                  self.emitChannelEvent('part', message.args[0], message.nick, message.args[1], message);
                  if (self.nick === message.nick) {
                      channel = self.chanData(message.args[0]);
                      delete self.chans[channel.key];
                  } else {
                      channel = self.chanData(message.args[0]);
                      if (channel && channel.users) {
                          delete channel.users[message.nick];
                      }
                  }
                  break;
              case 'KICK':
                  // channel, who, by, reason
                  self.emitChannelEvent('kick', message.args[0], message.args[1], message.nick, message.args[2], message);

                  if (self.nick === message.args[1]) {
                      channel = self.chanData(message.args[0]);
                      delete self.chans[channel.key];
                  } else {
                      channel = self.chanData(message.args[0]);
                      if (channel && channel.users) {
                          delete channel.users[message.args[1]];
                      }
                  }
                  break;
              case 'KILL':
                  nick = message.args[0];
                  channels = [];
                  Object.keys(self.chans).forEach(function(channame) {
                      var chan = self.chans[channame];
                      if (nick in chan.users) {
                          channels.push(channame);
                          delete chan.users[nick];
                      }
                  });
                  self.emit('kill', nick, message.args[1], channels, message);
                  break;
              case 'PRIVMSG':
                  from = message.nick;
                  to = message.args[0];
                  text = message.args[1] || '';
                  if (text[0] === '\u0001' && text.lastIndexOf('\u0001') > 0) {
                      self._handleCTCP(from, to, text, 'privmsg', message);
                      break;
                  }
                  self.emit('message', from, to, text, message);
                  if (self.supported.channel.types.indexOf(to.charAt(0)) !== -1) {
                      self.emit('message#', from, to, text, message);
                      self.emit('message' + to, from, text, message);
                      if (to !== to.toLowerCase()) {
                          self.emit('message' + to.toLowerCase(), from, text, message);
                      }
                  }
                  if (to.toUpperCase() === self.nick.toUpperCase()) {
                      self.emit('pm', from, text, message);
                      self.out.debug('GOT MESSAGE from "' + from + '": "' + text + '"');
                  }
                  break;
              case 'INVITE':
                  from = message.nick;
                  to = message.args[0];
                  channel = message.args[1];
                  self.emit('invite', channel, from, message);
                  break;
              case 'QUIT':
                  self.out.debug('QUIT: ' + message.prefix + ' ' + message.args.join(' '));
                  if (self.nick === message.nick) {
                      // TODO handle?
                      break;
                  }

                  // handle other people quitting
                  channels = [];

                  // Figure out what channels the user was in
                  Object.keys(self.chans).forEach(function(channame) {
                      var chan = self.chans[channame];
                      if (message.nick in chan.users) {
                          delete chan.users[message.nick];
                          channels.push(channame);
                      }
                  });

                  // who, reason, channels
                  self.emit('quit', message.nick, message.args[0], channels, message);
                  break;

              // for sasl
              case 'CAP':
                  // client identifier name, cap subcommand, params
                  if (message.args[1] === 'NAK') {
                      // capabilities not handled, error
                      self.out.error(message);
                      self.emit('error', message);
                      break;
                  }

                  // currently only handle ACK sasl responses
                  if (message.args[1] !== 'ACK') break;
                  var caps = message.args[2].split(/\s+/);
                  if (caps.indexOf('sasl') < 0) break;

                  self.send('AUTHENTICATE', 'PLAIN');
                  break;
              case 'AUTHENTICATE':
                  if (message.args[0] !== '+') break;
                  // AUTHENTICATE response (params) must be split into 400-byte chunks
                  var authMessage = Buffer.from(
                      self.opt.nick + '\0' +
                      self.opt.userName + '\0' +
                      self.opt.password
                  ).toString('base64');
                  // must output a "+" after a 400-byte string to make clear it's finished
                  for (var i=0; i < (authMessage.length+1) / 400; i++) {
                    var chunk = authMessage.slice(i * 400, (i+1) * 400);
                    if (chunk === '') chunk = '+';
                    self.send('AUTHENTICATE', chunk);
                  }
                  break;
              case 'rpl_loggedin':
                  break;
              case 'rpl_saslsuccess':
                  self.send('CAP', 'END');
                  break;

              case 'err_umodeunknownflag':
                  self.out.error(message);
                  self.emit('error', message);
                  break;

              case 'err_erroneusnickname':
                  self.out.error(message);
                  self.emit('error', message);
                  break;

              // Commands relating to OPER
              case 'err_nooperhost':
                  self.out.error(message);
                  self.emit('error', message);
                  break;
              case 'rpl_youreoper':
                  self.emit('opered');
                  break;

              default:
                  if (message.commandType === 'error') {
                      self.out.error(message);
                      self.emit('error', message);
                  } else {
                      self.out.error('Unhandled message:', message);
                      self.emit('unhandled', message);
                      break;
                  }
          }
      });

      self.addListener('kick', function(channel, nick) {
          if (self.opt.autoRejoin && nick.toLowerCase() === self.nick.toLowerCase())
              self.join(channel);
      });
      self.addListener('motd', function() {
          self.opt.channels.forEach(function(channel) {
              self.join(channel);
          });
      });

      EventEmitter$5.call(this);
  }
  util$1.inherits(Client$3, EventEmitter$5);

  Client$3.prototype.conn = null;
  Client$3.prototype.prefixForMode = {};
  Client$3.prototype.modeForPrefix = {};
  Client$3.prototype.chans = {};
  Client$3.prototype._whoisData = {};

  Client$3.prototype.connectionTimedOut = function(conn) {
      var self = this;
      if (conn !== self.conn) {
          // Only care about a timeout event if it came from the current connection
          return;
      }
      self.end();
  };

  (function() {
      var pingCounter = 1;
      Client$3.prototype.connectionWantsPing = function(conn) {
          var self = this;
          if (conn !== self.conn) {
              // Only care about a wantPing event if it came from the current connection
              return;
          }
          self.send('PING', (pingCounter++).toString());
      };
  }());

  Client$3.prototype.chanData = function(name, create) {
      var key = name.toLowerCase();
      if (create) {
          this.chans[key] = this.chans[key] || {
              key: key,
              serverName: name,
              users: {},
              modeParams: {},
              mode: ''
          };
      }

      return this.chans[key];
  };

  Client$3.prototype._connectionHandler = function() {
      this.out.debug('Socket connection successful');

      // WEBIRC
      if (this.opt.webirc.ip && this.opt.webirc.pass && this.opt.webirc.host) {
          this.send('WEBIRC', this.opt.webirc.pass, this.opt.userName, this.opt.webirc.host, this.opt.webirc.ip);
      }

      // SASL, server password
      if (this.opt.sasl) {
          // see http://ircv3.net/specs/extensions/sasl-3.1.html
          this.send('CAP', 'REQ', 'sasl');
      } else if (this.opt.password) {
          this.send('PASS', this.opt.password);
      }

      // handshake details
      this.out.debug('Sending irc NICK/USER');
      this.send('NICK', this.opt.nick);
      this.nick = this.opt.nick;
      this._updateMaxLineLength();
      this.send('USER', this.opt.userName, 8, '*', this.opt.realName);

      // watch for ping timeout
      this.conn.cyclingPingTimer.start();

      this.emit('connect');
  };

  Client$3.prototype.connect = function(retryCount, callback) {
      if (typeof (retryCount) === 'function') {
          callback = retryCount;
          retryCount = undefined;
      }
      retryCount = retryCount || 0;

      if (typeof (callback) === 'function') {
          this.once('registered', callback);
      }

      // skip connect if already connected
      if (this.conn && !this.conn.requestedDisconnect) {
          this.out.error('Connection already active, not reconnecting  please disconnect first');
          return;
      }

      var self = this;
      self.chans = {};

      // socket opts
      var connectionOpts = {
          host: self.opt.server,
          port: self.opt.port
      };

      // local address to bind to
      if (self.opt.localAddress)
          connectionOpts.localAddress = self.opt.localAddress;

      self.out.debug('Attempting socket connection to IRC server');
      // try to connect to the server
      if (self.opt.secure) {
          connectionOpts.rejectUnauthorized = !self.opt.selfSigned;

          if (typeof self.opt.secure === 'object') {
              // copy "secure" opts to options passed to connect()
              for (var f in self.opt.secure) {
                  connectionOpts[f] = self.opt.secure[f];
              }
          }

          self.conn = tls.connect(connectionOpts, function() {
              // callback called only after successful socket connection
              self.conn.connected = true;
              if (self.conn.authorized ||
                  (self.opt.selfSigned &&
                      (self.conn.authorizationError   === 'DEPTH_ZERO_SELF_SIGNED_CERT' ||
                       self.conn.authorizationError === 'UNABLE_TO_VERIFY_LEAF_SIGNATURE' ||
                       self.conn.authorizationError === 'SELF_SIGNED_CERT_IN_CHAIN')) ||
                  (self.opt.certExpired &&
                   self.conn.authorizationError === 'CERT_HAS_EXPIRED')) {
                  // authorization successful

                  if (!self.opt.encoding) {
                      self.conn.setEncoding('utf-8');
                  }

                  if (self.opt.certExpired &&
                      self.conn.authorizationError === 'CERT_HAS_EXPIRED') {
                      util$1.log('Connecting to server with expired certificate');
                  }

                  self._connectionHandler();
              } else {
                  // authorization failed
                  util$1.log(self.conn.authorizationError);
              }
          });
      } else {
          self.conn = net.createConnection(connectionOpts, self._connectionHandler.bind(self));
      }
      self.conn.requestedDisconnect = false;
      self.conn.setTimeout(0);

      // Each connection gets its own CyclingPingTimer.
      // The connection forwards the timer's 'timeout' and 'wantPing' events to the client object via calling the connectionTimedOut() and connectionWantsPing() functions.
      // Since the client's "current connection" value changes over time because of retry functionality,
      // the client should ignore timeout/wantPing events that come from old connections.
      self.conn.cyclingPingTimer = new CyclingPingTimer(self);
      (function(conn) {
          conn.cyclingPingTimer.on('pingTimeout', function() {
              self.connectionTimedOut(conn);
          });
          conn.cyclingPingTimer.on('wantPing', function() {
              self.connectionWantsPing(conn);
          });
      }(self.conn));

      if (!self.opt.encoding) {
          self.conn.setEncoding('utf8');
      }

      var buffer = Buffer.from('');

      function handleData(chunk) {
          self.conn.cyclingPingTimer.notifyOfActivity();

          if (typeof (chunk) === 'string') {
              buffer += chunk;
          } else {
              buffer = Buffer.concat([buffer, chunk]);
          }

          var lines = self.convertEncoding(buffer).toString().split(lineDelimiter);

          if (lines.pop()) {
              // if buffer doesn't end \r\n, there are more chunks.
              return;
          }
          // else, re-initialize the buffer.
          buffer = Buffer.from('');

          lines.forEach(function(line) {
              if (line.length) {
                  self.out.debug('Received:', line);
                  var message = parseMessage(line, self.opt.stripColors);

                  try {
                      self.emit('raw', message);
                  } catch (err) {
                      if (!self.conn.requestedDisconnect) {
                          self.emit('error', err);
                      }
                  }
              }
          });
      }

      self.conn.addListener('data', handleData);
      self.conn.addListener('end', function() {
          self.out.debug('Connection got "end" event');
      });
      self.conn.addListener('close', function() {
          self.out.debug('Connection got "close" event');

          // don't reconnect if this is an old connection closing
          if (self.conn !== this) {
              self.out.debug('Non-latest connection is being discarded');
              return;
          }

          // skip if this connection is supposed to close
          if (self.conn && self.conn.requestedDisconnect)
              return;

          self.out.debug('Disconnected: reconnecting');
          self.conn.cyclingPingTimer.stop();
          self.cancelAutoRenick();
          self.conn = null;

          // limit to retryCount reconnections
          if (self.opt.retryCount !== null && retryCount >= self.opt.retryCount) {
              self.out.debug('Maximum retry count (' + self.opt.retryCount + ') reached. Aborting');
              self.emit('abort', self.opt.retryCount);
              return;
          }

          // actually reconnect
          self.out.debug('Waiting ' + self.opt.retryDelay + 'ms before retrying');
          self.retryTimeout = setTimeout(function() {
              self.connect(retryCount + 1);
          }, self.opt.retryDelay);
      });

      self.conn.addListener('error', function(exception) {
          self.emit('netError', exception);
          self.out.debug('Network error: ' + exception);
      });
  };

  Client$3.prototype.end = function() {
      if (this.conn) {
          this.conn.cyclingPingTimer.stop();
          this.cancelAutoRenick();
          this.conn.destroy();
      }
  };

  Client$3.prototype.disconnect = function(message, callback) {
      if (typeof (message) === 'function') {
          callback = message;
          message = undefined;
      }
      message = message || 'node-irc says goodbye';
      var self = this;

      self.out.debug('Disconnecting from IRC server');

      // Skip if already disconnected
      if (!self.conn || self.conn.destroyed) {
          if (self.retryTimeout) {
              clearTimeout(self.retryTimeout);
              self.retryTimeout = null;
              self.out.error('Connection already broken, skipping disconnect (and clearing up automatic retry)');
          } else {
              self.out.error('Connection already broken, skipping disconnect');
          }
          return;
      }

      if (self.conn.requestedDisconnect) {
          self.out.error('Connection already disconnecting, skipping disconnect');
          return;
      }

      // send quit message
      if (self.conn.readyState === 'open') {
          var sendFunction;
          if (self.floodProtectionEnabled) {
              sendFunction = self._sendImmediate;
              self._clearCmdQueue();
          } else {
              sendFunction = self.send;
          }
          sendFunction.call(self, 'QUIT', message);
      }

      // flag connection as disconnecting
      self.conn.requestedDisconnect = true;

      // disconnect
      if (typeof (callback) === 'function') {
          self.conn.once('end', callback);
      }
      self.conn.end();
      self.conn.cyclingPingTimer.stop();
      self.cancelAutoRenick();
  };

  Client$3.prototype.send = function() {
      var args = Array.prototype.slice.call(arguments);
      // e.g. NICK, nickname

      // if the last arg contains a space, starts with a colon, or is empty, prepend a colon
      if (args[args.length - 1].match(/\s/) || args[args.length - 1].match(/^:/) || args[args.length - 1] === '') {
          args[args.length - 1] = ':' + args[args.length - 1];
      }

      if (this.conn && !this.conn.requestedDisconnect) {
          this.out.debug('SEND:', args.join(' '));
          this.conn.write(args.join(' ') + '\r\n');
      } else {
          this.out.debug('(Disconnected) SEND:', args.join(' '));
      }
  };

  Client$3.prototype.activateFloodProtection = function(interval) {
      var safeInterval = interval || this.opt.floodProtectionDelay,
          self = this;

      self.floodProtectionEnabled = true;
      self.cmdQueue = [];
      self._origSend = self.send;

      // Wrapper for the original send function. Queue the messages.
      self.send = function() {
          self.cmdQueue.push(arguments);
      };

      self._sendImmediate = function() {
          self._origSend.apply(self, arguments);
      };

      self._clearCmdQueue = function() {
          self.cmdQueue = [];
      };

      self.dequeue = function() {
          var args = self.cmdQueue.shift();
          if (args) {
              self._origSend.apply(self, args);
          }
      };

      // Slowly unpack the queue without flooding.
      self.floodProtectionInterval = setInterval(self.dequeue, safeInterval);
      self.dequeue();
  };

  Client$3.prototype.deactivateFloodProtection = function() {
      if (!this.floodProtectionEnabled) return;

      clearInterval(this.floodProtectionInterval);
      this.floodProtectionInterval = null;

      var count = this.cmdQueue.length;
      for (var i=0; i < count; i++) {
        this.dequeue();
      }

      this.send = this._origSend;
      this._origSend = null;
      this._sendImmediate = null;
      this._clearCmdQueue = null;
      this.dequeue = null;

      this.floodProtectionEnabled = false;
  };

  Client$3.prototype.cancelAutoRenick = function() {
      if (!this.conn) return;
      var oldInterval = this.conn.renickInterval;
      clearInterval(this.conn.renickInterval);
      this.conn.renickInterval = null;
      return oldInterval;
  };

  Client$3.prototype.join = function(channelList, callback) {
      var self = this;
      var parts = channelList.split(' ');
      var channels = parts[0];
      var keys;
      if (parts[1]) keys = parts[1].split(',');
      channels = channels.split(',');
      channels.forEach(function(channelName, index) {
          self.once('join' + channelName.toLowerCase(), function() {
              // Append to opts.channel on successful join, so it rejoins on reconnect.
              var chanString = channelName;
              if (keys && keys[index]) chanString += ' ' + keys[index];
              var channelIndex = self._findChannelFromStrings(channelName);
              if (channelIndex === -1) {
                  self.opt.channels.push(chanString);
              }

              if (typeof callback === 'function') {
                  return callback.apply(this, arguments);
              }
          });
      });
      self.send.apply(this, ['JOIN'].concat(channelList.split(' ')));
  };

  Client$3.prototype.part = function(channelList, message, callback) {
      if (typeof (message) === 'function') {
          callback = message;
          message = undefined;
      }
      var self = this;
      var channels = channelList.split(',');
      channels.forEach(function(channelName) {
        if (typeof callback === 'function') {
            self.once('part' + channelName.toLowerCase(), callback);
        }

        // remove this channel from this.opt.channels so we won't rejoin upon reconnect
        var channelIndex = self._findChannelFromStrings(channelName);
        if (channelIndex !== -1) {
            self.opt.channels.splice(channelIndex, 1);
        }
      });

      if (message) {
          this.send('PART', channelList, message);
      } else {
          this.send('PART', channelList);
      }
  };

  Client$3.prototype.action = function(target, text) {
      var self = this;
      var maxLength = Math.min(this.maxLineLength - target.length, this.opt.messageSplit) - '\u0001ACTION \u0001'.length;
      if (typeof text !== 'undefined') {
          text.toString().split(/\r?\n/).filter(function(line) {
              return line.length > 0;
          }).forEach(function(line) {
              var linesToSend = self._splitLongLines(line, maxLength, []);
              linesToSend.forEach(function(split) {
                  var toSend = '\u0001ACTION ' + split + '\u0001';
                  self.send('PRIVMSG', target, toSend);
                  self.emit('selfMessage', target, toSend);
              });
          });
      }
  };

  // finds the string in opt.channels representing channelName (if present)
  Client$3.prototype._findChannelFromStrings = function(channelName) {
      channelName = channelName.toLowerCase();
      var index = this.opt.channels.findIndex(function(listString) {
        var name = listString.split(' ')[0]; // ignore the key in the string
        name = name.toLowerCase(); // check case-insensitively
        return channelName === name;
      });
      return index;
  };

  Client$3.prototype._splitLongLines = function(words, maxLength, destination) {
      maxLength = maxLength || 450; // If maxLength hasn't been initialized yet, prefer an arbitrarily low line length over crashing.
      // If no words left, return the accumulated array of splits
      if (words.length === 0) {
          return destination;
      }
      // If the remaining words fit under the byte limit (by utf-8, for Unicode support), push to the accumulator and return
      if (Buffer.byteLength(words, 'utf8') <= maxLength) {
          destination.push(words);
          return destination;
      }

      // else, attempt to write maxLength bytes of message, truncate accordingly
      var truncatingBuffer = Buffer.alloc(maxLength + 1);
      var writtenLength = truncatingBuffer.write(words, 'utf8');
      var truncatedStr = truncatingBuffer.toString('utf8', 0, writtenLength);
      // and then check for a word boundary to try to keep words together
      var len = truncatedStr.length - 1;
      var c = truncatedStr[len];
      var cutPos;
      var wsLength = 1;
      if (c.match(/\s/)) {
          cutPos = len;
      } else {
          var offset = 1;
          while ((len - offset) > 0) {
              c = truncatedStr[len - offset];
              if (c.match(/\s/)) {
                  cutPos = len - offset;
                  break;
              }
              offset++;
          }
          if (len - offset <= 0) {
              cutPos = len;
              wsLength = 0;
          }
      }
      // and push the found region to the accumulator, remove from words, split rest of message
      var part = truncatedStr.substring(0, cutPos);
      destination.push(part);
      return this._splitLongLines(words.substring(cutPos + wsLength, words.length), maxLength, destination);
  };

  Client$3.prototype.say = function(target, text) {
      this._speak('PRIVMSG', target, text);
  };

  Client$3.prototype.notice = function(target, text) {
      this._speak('NOTICE', target, text);
  };

  Client$3.prototype.emitChannelEvent = function(eventName, channel) {
      var args = Array.prototype.slice.call(arguments, 2);
      this.emit.apply(this, [eventName, channel].concat(args));
      this.emit.apply(this, [eventName + channel].concat(args));
      if (channel !== channel.toLowerCase()) {
        this.emit.apply(this, [eventName + channel.toLowerCase()].concat(args));
      }
  };

  Client$3.prototype._speak = function(kind, target, text) {
      var self = this;
      var maxLength = Math.min(this.maxLineLength - target.length, this.opt.messageSplit);
      if (typeof text !== 'undefined') {
          text.toString().split(/\r?\n/).filter(function(line) {
              return line.length > 0;
          }).forEach(function(line) {
              var linesToSend = self._splitLongLines(line, maxLength, []);
              linesToSend.forEach(function(toSend) {
                  self.send(kind, target, toSend);
                  if (kind === 'PRIVMSG') {
                      self.emit('selfMessage', target, toSend);
                  }
              });
          });
      }
  };

  Client$3.prototype.whois = function(nick, callback) {
      if (typeof callback === 'function') {
          var callbackWrapper = function(info) {
              if (info.nick.toLowerCase() === nick.toLowerCase()) {
                  this.removeListener('whois', callbackWrapper);
                  return callback.apply(this, arguments);
              }
          };
          this.addListener('whois', callbackWrapper);
      }
      this.send('WHOIS', nick);
  };

  Client$3.prototype.list = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('LIST');
      this.send.apply(this, args);
  };

  Client$3.prototype._addWhoisData = function(nick, key, value, onlyIfExists) {
      if (onlyIfExists && !this._whoisData[nick]) return;
      this._whoisData[nick] = this._whoisData[nick] || {nick: nick};
      this._whoisData[nick][key] = value;
  };

  Client$3.prototype._clearWhoisData = function(nick) {
      // Ensure that at least the nick exists before trying to return
      this._addWhoisData(nick, 'nick', nick);
      var data = this._whoisData[nick];
      delete this._whoisData[nick];
      return data;
  };

  Client$3.prototype._handleCTCP = function(from, to, text, type, message) {
      text = text.slice(1);
      text = text.slice(0, text.indexOf('\u0001'));
      var parts = text.split(' ');
      this.emit('ctcp', from, to, text, type, message);
      this.emit('ctcp-' + type, from, to, text, message);
      if (type === 'privmsg' && text === 'VERSION')
          this.emit('ctcp-version', from, to, message);
      if (parts[0] === 'ACTION' && parts.length > 1)
          this.emit('action', from, to, parts.slice(1).join(' '), message);
      if (parts[0] === 'PING' && type === 'privmsg' && parts.length > 1)
          this.ctcp(from, 'notice', text);
  };

  Client$3.prototype.ctcp = function(to, type, text) {
      return this[type === 'privmsg' ? 'say' : 'notice'](to, '\u0001' + text + '\u0001');
  };

  function convertEncodingHelper(str, encoding, errorHandler) {
      var out = str;
      var charset;
      try {
          var iconv = requireLib$1();
          var charsetDetector = requireLib();

          charset = charsetDetector.detect(str);
          var decoded = iconv.decode(str, charset);
          out = Buffer.from(iconv.encode(decoded, encoding));
      } catch (err) {
          if (!errorHandler) throw err;
          errorHandler(err, charset);
      }
      return out;
  }

  Client$3.prototype.convertEncoding = function(str) {
      var self = this, out = str;

      if (self.opt.encoding) {
          out = convertEncodingHelper(str, self.opt.encoding, function(err, charset) {
              if (self.out) self.out.error(err, { str: str, charset: charset });
          });
      }

      return out;
  };

  function canConvertEncoding() {
      // hardcoded "schn" in ISO-8859-1 and UTF-8
      var sampleText = Buffer.from([0x73, 0x63, 0x68, 0xf6, 0x6e]);
      var expectedText = Buffer.from([0x73, 0x63, 0x68, 0xc3, 0xb6, 0x6e]);
      var error;
      var text = convertEncodingHelper(sampleText, 'utf-8', function(e) { error = e; });
      if (error || text.toString() !== expectedText.toString()) {
          return false;
      }
      return true;
  }
  irc$1.canConvertEncoding = canConvertEncoding;
  Client$3.prototype.canConvertEncoding = canConvertEncoding;

  // blatantly stolen from irssi's splitlong.pl. Thanks, Bjoern Krombholz!
  Client$3.prototype._updateMaxLineLength = function() {
      // 497 = 510 - (":" + "!" + " PRIVMSG " + " :").length;
      // target is determined in _speak() and subtracted there
      this.maxLineLength = 497 - this.nick.length - this.hostMask.length;
  };

  var isAscii$1 = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = isAscii;

  	var _assertString = _interopRequireDefault(assertStringExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	/* eslint-disable no-control-regex */
  	var ascii = /^[\x00-\x7F]+$/;
  	/* eslint-enable no-control-regex */

  	function isAscii(str) {
  	  (0, _assertString.default)(str);
  	  return ascii.test(str);
  	}

  	module.exports = exports.default;
  	module.exports.default = exports.default; 
  } (isAscii$1, isAscii$1.exports));

  var isAsciiExports = isAscii$1.exports;
  var isAscii = /*@__PURE__*/getDefaultExportFromCjs(isAsciiExports);

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using IRC
   * @module fetcher/irc
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.irc.fn({ nick: 'alice', domain: 'domain.example' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 20000
   */
  const timeout$6 = 20000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.nick - The nick of the targeted account
   * @param {string} data.domain - The domain on which the targeted account is registered
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<Array<string>>} The fetched proofs from an IRC account
   */
  async function fn$4 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$6
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      try {
        isAscii(opts.claims.irc.nick);
      } catch (err) {
        throw new Error(`IRC fetcher was not set up properly (${err.message})`)
      }

      try {
        const client = new irc$1.Client(data.domain, opts.claims.irc.nick, {
          port: 6697,
          secure: true,
          channels: [],
          showErrors: false,
          debug: false
        });
        const reKey = /[a-zA-Z0-9\-_]+\s+:\s((?:openpgp4fpr|aspe):.*)/;
        const reEnd = /End\sof\s.*\staxonomy./;
        const keys = [];

        // @ts-ignore
        client.addListener('registered', (message) => {
          client.send(`PRIVMSG NickServ TAXONOMY ${data.nick}`);
        });
        // @ts-ignore
        client.addListener('notice', (nick, to, text, message) => {
          if (reKey.test(text)) {
            const match = text.match(reKey);
            keys.push(match[1]);
          }
          if (reEnd.test(text)) {
            client.disconnect();
            resolve(keys);
          }
        });
      } catch (error) {
        reject(error);
      }
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var irc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$4,
    timeout: timeout$6
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using Matrix messages
   * @module fetcher/matrix
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.matrix.fn({ eventId: '$abc123def456', roomId: '!dBfQZxCoGVmSTujfiv:matrix.org' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$5 = 5000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.eventId - The identifier of the targeted post
   * @param {string} data.roomId - The identifier of the room containing the targeted post
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object>} The fetched Matrix object
   */
  async function fn$3 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$5
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      try {
        isFQDN(opts.claims.matrix.instance);
        isAscii(opts.claims.matrix.accessToken);
      } catch (err) {
        throw new Error(`Matrix fetcher was not set up properly (${err.message})`)
      }

      const url = `https://${opts.claims.matrix.instance}/_matrix/client/r0/rooms/${data.roomId}/event/${data.eventId}?access_token=${opts.claims.matrix.accessToken}`;
      axios$1.get(url,
        {
          headers: {
            Accept: 'application/json',
            // @ts-ignore
            'User-Agent': `doipjs/${version}`
          }
        })
        .then(res => {
          return res.data
        })
        .then((res) => {
          resolve(res);
        })
        .catch((error) => {
          reject(error);
        });
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var matrix = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$3,
    timeout: timeout$5
  });

  /*
  Copyright 2024 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs from OpenPGP notations
   * @module fetcher/openpgp
   * @example
   * import { fetcher, enums as E } from 'doipjs';
   *
   * const hkpProtocol = E.OpenPgpQueryProtocol.HKP;
   * const hkpUrl = 'https://keys.openpgp.org/vks/v1/by-fingerprint/ABC123DEF456';
   * const hkpData = await fetcher.openpgp.fn({ url: hkpUrl, protocol: hkpProtocol });
   *
   * const wkdProtocol = E.OpenPgpQueryProtocol.WKD;
   * const wkdUrl = 'https://domain.example/.well-known/openpgpkey/hu/kei1q4tipxxu1yj79k9kfukdhfy631xe?l=alice';
   * const wkdData = await fetcher.openpgp.fn({ url: wkdUrl, protocol: wkdProtocol });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$4 = 5000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.url - The URL pointing at targeted content
   * @param {OpenPgpQueryProtocol} data.protocol - The protocol used to access the targeted content
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object>} The fetched notations from an OpenPGP key
   */
  async function fn$2 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$4
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      if (!data.url) {
        reject(new Error('No valid URI provided'));
        return
      }

      switch (data.protocol) {
        case OpenPgpQueryProtocol.HKP:
          axios$1.get(data.url, {
            headers: {
              Accept: 'application/pgp-keys',
              'User-Agent': `doipjs/${version}`
            },
            validateStatus: (status) => status >= 200 && status < 400
          })
            .then(res => res.data)
            .then(async data => await wh({ armoredKey: data }))
            .then(async publicKey => await parsePublicKey(publicKey))
            .then(profile =>
              profile.personas.flatMap(p => { return p.claims.map(c => c._uri) })
            )
            .then(res => {
              resolve({
                notations: {
                  'proof@ariadne.id': res
                }
              });
            })
            .catch(e => {
              reject(e);
            });
          break
        case OpenPgpQueryProtocol.WKD:
          axios$1.get(data.url, {
            headers: {
              Accept: 'application/octet-stream',
              'User-Agent': `doipjs/${version}`
            },
            responseType: 'arraybuffer',
            validateStatus: (status) => status >= 200 && status < 400
          })
            .then(res => res.data)
            .then(async data => await wh({ binaryKey: data }))
            .then(async publicKey => await parsePublicKey(publicKey))
            .then(profile =>
              profile.personas.flatMap(p => { return p.claims.map(c => c._uri) })
            )
            .then(res => {
              resolve({
                notations: {
                  'proof@ariadne.id': res
                }
              });
            })
            .catch(e => {
              reject(e);
            });
          break
        default:
          reject(new Error('Unsupported OpenPGP query protocol'));
          break
      }
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var openpgp = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$2,
    timeout: timeout$4
  });

  /*
  Copyright 2022 Maximilian Siling

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs using Telegram groups
   * @module fetcher/telegram
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.telegram.fn({ user: 'alice', chat: 'alice_identity_proof' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout$3 = 5000;

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.chat - Telegram public group name (slug)
   * @param {string} data.user - Telegram username
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<object|string>} The fetched Telegram object
   */
  async function fn$1 (data, opts) {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout$3
      );
    });

    const apiPromise = (/** @type {string} */ method) => new Promise((resolve, reject) => {
      try {
        isAscii(opts.claims.telegram.token);
      } catch (err) {
        throw new Error(`Telegram fetcher was not set up properly (${err.message})`)
      }

      if (!(data.chat && data.user)) {
        reject(new Error('Both chat name and user name must be provided'));
        return
      }

      const url = `https://api.telegram.org/bot${opts.claims.telegram.token}/${method}?chat_id=@${data.chat}`;
      axios$1.get(url, {
        headers: {
          Accept: 'application/json',
          // @ts-ignore
          'User-Agent': `doipjs/${version}`
        },
        validateStatus: (status) => status === 200
      })
        .then(res => resolve(res.data))
        .catch(e => reject(e));
    });

    const fetchPromise = apiPromise('getChatAdministrators').then(admins => {
      if (!admins.ok) {
        throw new Error('Request to get chat administrators failed')
      }

      return apiPromise('getChat').then(chat => {
        if (!chat.ok) {
          throw new Error('Request to get chat info failed')
        }

        let creator;
        for (const admin of admins.result) {
          if (admin.status === 'creator') {
            creator = admin.user.username;
          }
        }

        if (!chat.result.description) {
          throw new Error('There is no chat description')
        }

        if (creator !== data.user) {
          throw new Error('User doesn\'t match')
        }

        return {
          user: creator,
          text: chat.result.description
        }
      })
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var telegram = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn$1,
    timeout: timeout$3
  });

  var clientCore = {};

  var events$1 = {};

  var TimeoutError_1 = class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  };

  var delay$2 = function delay(ms) {
    let timeout;
    const promise = new Promise((resolve) => {
      timeout = setTimeout(resolve, ms);
    });
    promise.timeout = timeout;
    return promise;
  };

  const TimeoutError$2 = TimeoutError_1;
  const delay$1 = delay$2;

  var timeout$2 = function timeout(promise, ms) {
    const promiseDelay = delay$1(ms);

    function cancelDelay() {
      clearTimeout(promiseDelay.timeout);
    }

    return Promise.race([
      promise.finally(cancelDelay),
      promiseDelay.then(() => {
        throw new TimeoutError$2();
      }),
    ]);
  };

  const TimeoutError$1 = TimeoutError_1;

  var promise$3 = function promise(EE, event, rejectEvent = "error", timeout) {
    return new Promise((resolve, reject) => {
      let timeoutId;

      const cleanup = () => {
        clearTimeout(timeoutId);
        EE.removeListener(event, onEvent);
        EE.removeListener(rejectEvent, onError);
      };

      function onError(reason) {
        reject(reason);
        cleanup();
      }

      function onEvent(value) {
        resolve(value);
        cleanup();
      }

      EE.once(event, onEvent);
      if (rejectEvent) {
        EE.once(rejectEvent, onError);
      }

      if (timeout) {
        timeoutId = setTimeout(() => {
          cleanup();
          reject(new TimeoutError$1());
        }, timeout);
      }
    });
  };

  var Deferred$2 = function Deferred() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  };

  const timeout$1 = timeout$2;
  const delay = delay$2;
  const TimeoutError = TimeoutError_1;
  const promise$2 = promise$3;
  const EventEmitter$4 = require$$1$2;
  const Deferred$1 = Deferred$2;

  events$1.EventEmitter = EventEmitter$4;
  events$1.timeout = timeout$1;
  events$1.delay = delay;
  events$1.TimeoutError = TimeoutError;
  events$1.promise = promise$2;
  events$1.Deferred = Deferred$1;

  var jid$4 = {exports: {}};

  var escaping$2 = {};

  escaping$2.detect = function detect(local) {
    if (!local) {
      return false;
    }

    // Remove all escaped sequences
    const tmp = local
      .replace(/\\20/g, "")
      .replace(/\\22/g, "")
      .replace(/\\26/g, "")
      .replace(/\\27/g, "")
      .replace(/\\2f/g, "")
      .replace(/\\3a/g, "")
      .replace(/\\3c/g, "")
      .replace(/\\3e/g, "")
      .replace(/\\40/g, "")
      .replace(/\\5c/g, "");

    // Detect if we have unescaped sequences
    const search = tmp.search(/[ "&'/:<>@\\]/g);
    if (search === -1) {
      return false;
    }

    return true;
  };

  /**
   * Escape the local part of a JID.
   *
   * @see http://xmpp.org/extensions/xep-0106.html
   * @param String local local part of a jid
   * @return An escaped local part
   */
  escaping$2.escape = function escape(local) {
    if (local === null) {
      return null;
    }

    return local
      .replace(/^\s+|\s+$/g, "")
      .replace(/\\/g, "\\5c")
      .replace(/ /g, "\\20")
      .replace(/"/g, "\\22")
      .replace(/&/g, "\\26")
      .replace(/'/g, "\\27")
      .replace(/\//g, "\\2f")
      .replace(/:/g, "\\3a")
      .replace(/</g, "\\3c")
      .replace(/>/g, "\\3e")
      .replace(/@/g, "\\40");
  };

  /**
   * Unescape a local part of a JID.
   *
   * @see http://xmpp.org/extensions/xep-0106.html
   * @param String local local part of a jid
   * @return unescaped local part
   */
  escaping$2.unescape = function unescape(local) {
    if (local === null) {
      return null;
    }

    return local
      .replace(/\\20/g, " ")
      .replace(/\\22/g, '"')
      .replace(/\\26/g, "&")
      .replace(/\\27/g, "'")
      .replace(/\\2f/g, "/")
      .replace(/\\3a/g, ":")
      .replace(/\\3c/g, "<")
      .replace(/\\3e/g, ">")
      .replace(/\\40/g, "@")
      .replace(/\\5c/g, "\\");
  };

  const escaping$1 = escaping$2;

  /**
   * JID implements
   * - XMPP addresses according to RFC6122
   * - XEP-0106: JID Escaping
   *
   * @see http://tools.ietf.org/html/rfc6122#section-2
   * @see http://xmpp.org/extensions/xep-0106.html
   */
  let JID$4 = class JID {
    constructor(local, domain, resource) {
      if (typeof domain !== "string" || !domain) {
        throw new TypeError(`Invalid domain.`);
      }

      this.setDomain(domain);
      this.setLocal(typeof local === "string" ? local : "");
      this.setResource(typeof resource === "string" ? resource : "");
    }

    [Symbol.toPrimitive](hint) {
      if (hint === "number") {
        return NaN;
      }

      return this.toString();
    }

    toString(unescape) {
      let s = this._domain;
      if (this._local) {
        s = this.getLocal(unescape) + "@" + s;
      }

      if (this._resource) {
        s = s + "/" + this._resource;
      }

      return s;
    }

    /**
     * Convenience method to distinguish users
     * */
    bare() {
      if (this._resource) {
        return new JID(this._local, this._domain, null);
      }

      return this;
    }

    /**
     * Comparison function
     * */
    equals(other) {
      return (
        this._local === other._local &&
        this._domain === other._domain &&
        this._resource === other._resource
      );
    }

    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-localpart
     * */
    setLocal(local, escape) {
      escape = escape || escaping$1.detect(local);

      if (escape) {
        local = escaping$1.escape(local);
      }

      this._local = local && local.toLowerCase();
      return this;
    }

    getLocal(unescape = false) {
      let local = null;

      local = unescape ? escaping$1.unescape(this._local) : this._local;

      return local;
    }

    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-domain
     */
    setDomain(domain) {
      this._domain = domain.toLowerCase();
      return this;
    }

    getDomain() {
      return this._domain;
    }

    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-resourcepart
     */
    setResource(resource) {
      this._resource = resource;
      return this;
    }

    getResource() {
      return this._resource;
    }
  };

  Object.defineProperty(JID$4.prototype, "local", {
    get: JID$4.prototype.getLocal,
    set: JID$4.prototype.setLocal,
  });

  Object.defineProperty(JID$4.prototype, "domain", {
    get: JID$4.prototype.getDomain,
    set: JID$4.prototype.setDomain,
  });

  Object.defineProperty(JID$4.prototype, "resource", {
    get: JID$4.prototype.getResource,
    set: JID$4.prototype.setResource,
  });

  var JID_1 = JID$4;

  const JID$3 = JID_1;

  var parse$3 = function parse(s) {
    let local;
    let resource;

    const resourceStart = s.indexOf("/");
    if (resourceStart !== -1) {
      resource = s.slice(resourceStart + 1);
      s = s.slice(0, resourceStart);
    }

    const atStart = s.indexOf("@");
    if (atStart !== -1) {
      local = s.slice(0, atStart);
      s = s.slice(atStart + 1);
    }

    return new JID$3(local, s, resource);
  };

  const JID$2 = JID_1;
  const escaping = escaping$2;
  const parse$2 = parse$3;

  function jid$3(...args) {
    if (!args[1] && !args[2]) {
      return parse$2(...args);
    }

    return new JID$2(...args);
  }

  jid$4.exports = jid$3.bind();
  jid$4.exports.jid = jid$3;
  jid$4.exports.JID = JID$2;
  jid$4.exports.equal = function equal(a, b) {
    return a.equals(b);
  };

  jid$4.exports.detectEscape = escaping.detect;
  jid$4.exports.escapeLocal = escaping.escape;
  jid$4.exports.unescapeLocal = escaping.unescape;
  jid$4.exports.parse = parse$2;

  var jidExports = jid$4.exports;

  var xml$b = {exports: {}};

  var _escape$3 = {};

  Object.defineProperty(_escape$3, '__esModule', { value: true });

  const escapeXMLTable = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&apos;",
  };

  function escapeXMLReplace(match) {
    return escapeXMLTable[match];
  }

  const unescapeXMLTable = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&apos;": "'",
  };

  function unescapeXMLReplace(match) {
    if (match[1] === "#") {
      const num =
        match[2] === "x"
          ? parseInt(match.slice(3), 16)
          : parseInt(match.slice(2), 10);
      // https://www.w3.org/TR/xml/#NT-Char defines legal XML characters:
      // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
      if (
        num === 0x9 ||
        num === 0xa ||
        num === 0xd ||
        (num >= 0x20 && num <= 0xd7ff) ||
        (num >= 0xe000 && num <= 0xfffd) ||
        (num >= 0x10000 && num <= 0x10ffff)
      ) {
        return String.fromCodePoint(num);
      }
      throw new Error("Illegal XML character 0x" + num.toString(16));
    }
    if (unescapeXMLTable[match]) {
      return unescapeXMLTable[match] || match;
    }
    throw new Error("Illegal XML entity " + match);
  }

  function escapeXML(s) {
    return s.replace(/["&'<>]/g, escapeXMLReplace);
  }

  function unescapeXML(s) {
    let result = "";
    let start = -1;
    let end = -1;
    let previous = 0;
    while (
      (start = s.indexOf("&", previous)) !== -1 &&
      (end = s.indexOf(";", start + 1)) !== -1
    ) {
      result =
        result +
        s.slice(previous, start) +
        unescapeXMLReplace(s.slice(start, end + 1));
      previous = end + 1;
    }

    // shortcut if loop never entered:
    // return the original string without creating new objects
    if (previous === 0) return s;

    // push the remaining characters
    result = result + s.substring(previous);

    return result;
  }

  function escapeXMLText(s) {
    return s.replace(/[&<>]/g, escapeXMLReplace);
  }

  function unescapeXMLText(s) {
    return s.replace(/&(amp|#38|lt|#60|gt|#62);/g, unescapeXMLReplace);
  }

  _escape$3.escapeXML = escapeXML;
  _escape$3.escapeXMLText = escapeXMLText;
  _escape$3.unescapeXML = unescapeXML;
  _escape$3.unescapeXMLText = unescapeXMLText;

  var _escape$2 = _escape$3;

  /**
   * Element
   *
   * Attributes are in the element.attrs object. Children is a list of
   * either other Elements or Strings for text content.
   **/
  let Element$3 = class Element {
    constructor(name, attrs) {
      this.name = name;
      this.parent = null;
      this.children = [];
      this.attrs = {};
      this.setAttrs(attrs);
    }

    /* Accessors */

    /**
     * if (element.is('message', 'jabber:client')) ...
     **/
    is(name, xmlns) {
      return this.getName() === name && (!xmlns || this.getNS() === xmlns);
    }

    /* without prefix */
    getName() {
      const idx = this.name.indexOf(":");
      return idx >= 0 ? this.name.slice(idx + 1) : this.name;
    }

    /**
     * retrieves the namespace of the current element, upwards recursively
     **/
    getNS() {
      const idx = this.name.indexOf(":");
      if (idx >= 0) {
        const prefix = this.name.slice(0, idx);
        return this.findNS(prefix);
      }
      return this.findNS();
    }

    /**
     * find the namespace to the given prefix, upwards recursively
     **/
    findNS(prefix) {
      if (!prefix) {
        /* default namespace */
        if (this.attrs.xmlns) {
          return this.attrs.xmlns;
        } else if (this.parent) {
          return this.parent.findNS();
        }
      } else {
        /* prefixed namespace */
        const attr = "xmlns:" + prefix;
        if (this.attrs[attr]) {
          return this.attrs[attr];
        } else if (this.parent) {
          return this.parent.findNS(prefix);
        }
      }
    }

    /**
     * Recursiverly gets all xmlns defined, in the form of {url:prefix}
     **/
    getXmlns() {
      let namespaces = {};

      if (this.parent) {
        namespaces = this.parent.getXmlns();
      }

      for (const attr in this.attrs) {
        const m = attr.match("xmlns:?(.*)");
        // eslint-disable-next-line  no-prototype-builtins
        if (this.attrs.hasOwnProperty(attr) && m) {
          namespaces[this.attrs[attr]] = m[1];
        }
      }
      return namespaces;
    }

    setAttrs(attrs) {
      if (typeof attrs === "string") {
        this.attrs.xmlns = attrs;
      } else if (attrs) {
        Object.assign(this.attrs, attrs);
      }
    }

    /**
     * xmlns can be null, returns the matching attribute.
     **/
    getAttr(name, xmlns) {
      if (!xmlns) {
        return this.attrs[name];
      }

      const namespaces = this.getXmlns();

      if (!namespaces[xmlns]) {
        return null;
      }

      return this.attrs[[namespaces[xmlns], name].join(":")];
    }

    /**
     * xmlns can be null
     **/
    getChild(name, xmlns) {
      return this.getChildren(name, xmlns)[0];
    }

    /**
     * xmlns can be null
     **/
    getChildren(name, xmlns) {
      const result = [];
      for (const child of this.children) {
        if (
          child.getName &&
          child.getName() === name &&
          (!xmlns || child.getNS() === xmlns)
        ) {
          result.push(child);
        }
      }
      return result;
    }

    /**
     * xmlns and recursive can be null
     **/
    getChildByAttr(attr, val, xmlns, recursive) {
      return this.getChildrenByAttr(attr, val, xmlns, recursive)[0];
    }

    /**
     * xmlns and recursive can be null
     **/
    getChildrenByAttr(attr, val, xmlns, recursive) {
      let result = [];
      for (const child of this.children) {
        if (
          child.attrs &&
          child.attrs[attr] === val &&
          (!xmlns || child.getNS() === xmlns)
        ) {
          result.push(child);
        }
        if (recursive && child.getChildrenByAttr) {
          result.push(child.getChildrenByAttr(attr, val, xmlns, true));
        }
      }
      if (recursive) {
        result = result.flat();
      }
      return result;
    }

    getChildrenByFilter(filter, recursive) {
      let result = [];
      for (const child of this.children) {
        if (filter(child)) {
          result.push(child);
        }
        if (recursive && child.getChildrenByFilter) {
          result.push(child.getChildrenByFilter(filter, true));
        }
      }
      if (recursive) {
        result = result.flat();
      }
      return result;
    }

    getText() {
      let text = "";
      for (const child of this.children) {
        if (typeof child === "string" || typeof child === "number") {
          text += child;
        }
      }
      return text;
    }

    getChildText(name, xmlns) {
      const child = this.getChild(name, xmlns);
      return child ? child.getText() : null;
    }

    /**
     * Return all direct descendents that are Elements.
     * This differs from `getChildren` in that it will exclude text nodes,
     * processing instructions, etc.
     */
    getChildElements() {
      return this.getChildrenByFilter((child) => {
        return child instanceof Element;
      });
    }

    /* Builder */

    /** returns uppermost parent */
    root() {
      if (this.parent) {
        return this.parent.root();
      }
      return this;
    }

    /** just parent or itself */
    up() {
      if (this.parent) {
        return this.parent;
      }
      return this;
    }

    /** create child node and return it */
    c(name, attrs) {
      return this.cnode(new Element(name, attrs));
    }

    cnode(child) {
      this.children.push(child);
      if (typeof child === "object") {
        child.parent = this;
      }
      return child;
    }

    append(...nodes) {
      for (const node of nodes) {
        this.children.push(node);
        if (typeof node === "object") {
          node.parent = this;
        }
      }
    }

    prepend(...nodes) {
      for (const node of nodes) {
        this.children.unshift(node);
        if (typeof node === "object") {
          node.parent = this;
        }
      }
    }

    /** add text node and return element */
    t(text) {
      this.children.push(text);
      return this;
    }

    /* Manipulation */

    /**
     * Either:
     *   el.remove(childEl)
     *   el.remove('author', 'urn:...')
     */
    remove(el, xmlns) {
      const filter =
        typeof el === "string"
          ? (child) => {
              /* 1st parameter is tag name */
              return !(child.is && child.is(el, xmlns));
            }
          : (child) => {
              /* 1st parameter is element */
              return child !== el;
            };

      this.children = this.children.filter(filter);

      return this;
    }

    text(val) {
      if (val && this.children.length === 1) {
        this.children[0] = val;
        return this;
      }
      return this.getText();
    }

    attr(attr, val) {
      if (typeof val !== "undefined" || val === null) {
        if (!this.attrs) {
          this.attrs = {};
        }
        this.attrs[attr] = val;
        return this;
      }
      return this.attrs[attr];
    }

    /* Serialization */

    toString() {
      let s = "";
      this.write((c) => {
        s += c;
      });
      return s;
    }

    _addChildren(writer) {
      writer(">");
      for (const child of this.children) {
        /* Skip null/undefined */
        if (child != null) {
          if (child.write) {
            child.write(writer);
          } else if (typeof child === "string") {
            writer(_escape$2.escapeXMLText(child));
          } else if (child.toString) {
            writer(_escape$2.escapeXMLText(child.toString(10)));
          }
        }
      }
      writer("</");
      writer(this.name);
      writer(">");
    }

    write(writer) {
      writer("<");
      writer(this.name);
      for (const k in this.attrs) {
        const v = this.attrs[k];
        // === null || undefined
        if (v != null) {
          writer(" ");
          writer(k);
          writer('="');
          writer(_escape$2.escapeXML(typeof v === "string" ? v : v.toString(10)));
          writer('"');
        }
      }
      if (this.children.length === 0) {
        writer("/>");
      } else {
        this._addChildren(writer);
      }
    }
  };

  Element$3.prototype.tree = Element$3.prototype.root;

  var Element_1 = Element$3;

  var Element$2 = Element_1;

  function append(el, child) {
    if (Array.isArray(child)) {
      for (const c of child) append(el, c);
      return;
    }

    if (child === "" || child == null || child === true || child === false) {
      return;
    }

    el.cnode(child);
  }

  /**
   * JSX compatible API, use this function as pragma
   * https://facebook.github.io/jsx/
   *
   * @param  {string} name  name of the element
   * @param  {object} attrs object of attribute key/value pairs
   * @return {Element}      Element
   */
  function createElement(name, attrs, ...children) {
    if (typeof attrs === "object" && attrs !== null) {
      // __self and __source are added by babel in development
      // https://github.com/facebook/react/pull/4596
      // https://babeljs.io/docs/en/babel-preset-react#development
      // https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source
      delete attrs.__source;
      delete attrs.__self;

      for (const [key, value] of Object.entries(attrs)) {
        if (value == null) delete attrs[key];
        else attrs[key] = value.toString(10);
      }
    }

    const el = new Element$2(name, attrs);

    for (const child of children) {
      append(el, child);
    }

    return el;
  }

  var createElement_1 = createElement;

  var events = require$$1$2;
  var _escape$1 = _escape$3;

  const STATE_TEXT = 0;
  const STATE_IGNORE_COMMENT = 1;
  const STATE_IGNORE_INSTRUCTION = 2;
  const STATE_TAG_NAME = 3;
  const STATE_TAG = 4;
  const STATE_ATTR_NAME = 5;
  const STATE_ATTR_EQ = 6;
  const STATE_ATTR_QUOT = 7;
  const STATE_ATTR_VALUE = 8;
  const STATE_CDATA = 9;
  const STATE_IGNORE_CDATA = 10;

  class SaxLtx extends events.EventEmitter {
    constructor() {
      super();
      let state = STATE_TEXT;
      let remainder;
      let parseRemainder;
      let tagName;
      let attrs;
      let endTag;
      let selfClosing;
      let attrQuote;
      let attrQuoteChar;
      let recordStart = 0;
      let attrName;

      this._handleTagOpening = function _handleTagOpening(
        endTag,
        tagName,
        attrs
      ) {
        if (!endTag) {
          this.emit("startElement", tagName, attrs);
          if (selfClosing) {
            this.emit("endElement", tagName);
          }
        } else {
          this.emit("endElement", tagName);
        }
      };

      this.write = function write(data) {
        if (typeof data !== "string") {
          data = data.toString();
        }
        let pos = 0;

        /* Anything from previous write()? */
        if (remainder) {
          data = remainder + data;
          pos += !parseRemainder ? remainder.length : 0;
          parseRemainder = false;
          remainder = null;
        }

        function endRecording() {
          if (typeof recordStart === "number") {
            const recorded = data.slice(recordStart, pos);
            recordStart = undefined;
            return recorded;
          }
        }

        for (; pos < data.length; pos++) {
          switch (state) {
            case STATE_TEXT: {
              // if we're looping through text, fast-forward using indexOf to
              // the next '<' character
              const lt = data.indexOf("<", pos);
              if (lt !== -1 && pos !== lt) {
                pos = lt;
              }

              break;
            }
            case STATE_ATTR_VALUE: {
              // if we're looping through an attribute, fast-forward using
              // indexOf to the next end quote character
              const quot = data.indexOf(attrQuoteChar, pos);
              if (quot !== -1) {
                pos = quot;
              }

              break;
            }
            case STATE_IGNORE_COMMENT: {
              // if we're looping through a comment, fast-forward using
              // indexOf to the first end-comment character
              const endcomment = data.indexOf("-->", pos);
              if (endcomment !== -1) {
                pos = endcomment + 2; // target the '>' character
              }

              break;
            }
            case STATE_IGNORE_CDATA: {
              // if we're looping through a CDATA, fast-forward using
              // indexOf to the first end-CDATA character ]]>
              const endCDATA = data.indexOf("]]>", pos);
              if (endCDATA !== -1) {
                pos = endCDATA + 2; // target the '>' character
              }

              break;
            }
            // No default
          }

          const c = data.charCodeAt(pos);
          switch (state) {
            case STATE_TEXT:
              if (c === 60 /* < */) {
                const text = endRecording();
                if (text) {
                  this.emit("text", _escape$1.unescapeXML(text));
                }
                state = STATE_TAG_NAME;
                recordStart = pos + 1;
                attrs = {};
              }
              break;
            case STATE_CDATA:
              if (c === 93 /* ] */) {
                if (data.substr(pos + 1, 2) === "]>") {
                  const cData = endRecording();
                  if (cData) {
                    this.emit("text", cData);
                  }
                  state = STATE_TEXT;
                } else if (data.length < pos + 2) {
                  parseRemainder = true;
                  pos = data.length;
                }
              }
              break;
            case STATE_TAG_NAME:
              if (c === 47 /* / */ && recordStart === pos) {
                recordStart = pos + 1;
                endTag = true;
              } else if (c === 33 /* ! */) {
                if (data.substr(pos + 1, 7) === "[CDATA[") {
                  recordStart = pos + 8;
                  state = STATE_CDATA;
                } else if (
                  data.length < pos + 8 &&
                  "[CDATA[".startsWith(data.slice(pos + 1))
                ) {
                  // We potentially have CDATA, but the chunk is ending; stop here and let the next write() decide
                  parseRemainder = true;
                  pos = data.length;
                } else {
                  recordStart = undefined;
                  state = STATE_IGNORE_COMMENT;
                }
              } else if (c === 63 /* ? */) {
                recordStart = undefined;
                state = STATE_IGNORE_INSTRUCTION;
              } else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
                tagName = endRecording();
                pos--;
                state = STATE_TAG;
              }
              break;
            case STATE_IGNORE_COMMENT:
              if (c === 62 /* > */) {
                const prevFirst = data.charCodeAt(pos - 1);
                const prevSecond = data.charCodeAt(pos - 2);
                if (
                  (prevFirst === 45 /* - */ && prevSecond === 45) /* - */ ||
                  (prevFirst === 93 /* ] */ && prevSecond === 93) /* ] */
                ) {
                  state = STATE_TEXT;
                }
              }
              break;
            case STATE_IGNORE_INSTRUCTION:
              if (c === 62 /* > */) {
                const prev = data.charCodeAt(pos - 1);
                if (prev === 63 /* ? */) {
                  state = STATE_TEXT;
                }
              }
              break;
            case STATE_TAG:
              if (c === 62 /* > */) {
                this._handleTagOpening(endTag, tagName, attrs);
                tagName = undefined;
                attrs = undefined;
                endTag = undefined;
                selfClosing = undefined;
                state = STATE_TEXT;
                recordStart = pos + 1;
              } else if (c === 47 /* / */) {
                selfClosing = true;
              } else if (c > 32) {
                recordStart = pos;
                state = STATE_ATTR_NAME;
              }
              break;
            case STATE_ATTR_NAME:
              if (c <= 32 || c === 61 /* = */) {
                attrName = endRecording();
                pos--;
                state = STATE_ATTR_EQ;
              }
              break;
            case STATE_ATTR_EQ:
              if (c === 61 /* = */) {
                state = STATE_ATTR_QUOT;
              }
              break;
            case STATE_ATTR_QUOT:
              if (c === 34 /* " */ || c === 39 /* ' */) {
                attrQuote = c;
                attrQuoteChar = c === 34 ? '"' : "'";
                state = STATE_ATTR_VALUE;
                recordStart = pos + 1;
              }
              break;
            case STATE_ATTR_VALUE:
              if (c === attrQuote) {
                const value = _escape$1.unescapeXML(endRecording());
                attrs[attrName] = value;
                attrName = undefined;
                state = STATE_TAG;
              }
              break;
          }
        }

        if (typeof recordStart === "number" && recordStart <= data.length) {
          remainder = data.slice(recordStart);
          recordStart = 0;
        }
      };
    }

    end(data) {
      if (data) {
        this.write(data);
      }

      /* Uh, yeah */
      this.write = function write() {};
    }
  }

  var ltx = SaxLtx;

  var XMLError_1 = class XMLError extends Error {
    constructor(...args) {
      super(...args);
      this.name = "XMLError";
    }
  };

  const LtxParser = ltx;
  const Element$1 = Element_1;
  const EventEmitter$3 = require$$1$2;
  const XMLError$1 = XMLError_1;

  let Parser$2 = class Parser extends EventEmitter$3 {
    constructor() {
      super();
      const parser = new LtxParser();
      this.root = null;
      this.cursor = null;

      parser.on("startElement", this.onStartElement.bind(this));
      parser.on("endElement", this.onEndElement.bind(this));
      parser.on("text", this.onText.bind(this));

      this.parser = parser;
    }

    onStartElement(name, attrs) {
      const element = new Element$1(name, attrs);

      const { root, cursor } = this;

      if (!root) {
        this.root = element;
        this.emit("start", element);
      } else if (cursor !== root) {
        cursor.append(element);
      }

      this.cursor = element;
    }

    onEndElement(name) {
      const { root, cursor } = this;
      if (name !== cursor.name) {
        // <foo></bar>
        this.emit("error", new XMLError$1(`${cursor.name} must be closed.`));
        return;
      }

      if (cursor === root) {
        this.emit("end", root);
        return;
      }

      if (!cursor.parent) {
        cursor.parent = root;
        this.emit("element", cursor);
        this.cursor = root;
        return;
      }

      this.cursor = cursor.parent;
    }

    onText(str) {
      const { cursor } = this;
      if (!cursor) {
        this.emit("error", new XMLError$1(`${str} must be a child.`));
        return;
      }

      cursor.t(str);
    }

    write(data) {
      this.parser.write(data);
    }

    end(data) {
      if (data) {
        this.parser.write(data);
      }
    }
  };

  Parser$2.XMLError = XMLError$1;

  var Parser_1 = Parser$2;

  (function (module) {

  	const Element = Element_1;
  	const createElement = createElement_1;
  	const Parser = Parser_1;
  	const {
  	  escapeXML,
  	  unescapeXML,
  	  escapeXMLText,
  	  unescapeXMLText,
  	} = _escape$3;
  	const XMLError = XMLError_1;

  	function xml(...args) {
  	  return createElement(...args);
  	}

  	module.exports = xml;

  	Object.assign(module.exports, {
  	  Element,
  	  createElement,
  	  Parser,
  	  escapeXML,
  	  unescapeXML,
  	  escapeXMLText,
  	  unescapeXMLText,
  	  XMLError,
  	}); 
  } (xml$b));

  var xmlExports = xml$b.exports;

  // https://xmpp.org/rfcs/rfc6120.html#rfc.section.4.9.2

  let XMPPError$3 = class XMPPError extends Error {
    constructor(condition, text, application) {
      super(condition + (text ? ` - ${text}` : ""));
      this.name = "XMPPError";
      this.condition = condition;
      this.text = text;
      this.application = application;
    }

    static fromElement(element) {
      const [condition, second, third] = element.children;
      let text;
      let application;

      if (second) {
        if (second.is("text")) {
          text = second;
        } else if (second) {
          application = second;
        }

        if (third) application = third;
      }

      const error = new this(
        condition.name,
        text ? text.text() : "",
        application,
      );
      error.element = element;
      return error;
    }
  };

  var error = XMPPError$3;

  const XMPPError$2 = error;

  // https://xmpp.org/rfcs/rfc6120.html#streams-error

  let StreamError$1 = class StreamError extends XMPPError$2 {
    constructor(...args) {
      super(...args);
      this.name = "StreamError";
    }
  };

  var StreamError_1 = StreamError$1;

  var util = {exports: {}};

  (function (module) {

  	function parseURI(URI) {
  	  let { port, hostname, protocol } = new URL(URI);
  	  // https://github.com/nodejs/node/issues/12410#issuecomment-294138912
  	  if (hostname === "[::1]") {
  	    hostname = "::1";
  	  }

  	  return { port, hostname, protocol };
  	}

  	function parseHost(host) {
  	  const { port, hostname } = parseURI(`http://${host}`);
  	  return { port, hostname };
  	}

  	function parseService(service) {
  	  return service.includes("://") ? parseURI(service) : parseHost(service);
  	}

  	Object.assign(module.exports, { parseURI, parseHost, parseService }); 
  } (util));

  var utilExports = util.exports;

  const { EventEmitter: EventEmitter$2, promise: promise$1 } = events$1;
  const jid$2 = jidExports;
  const xml$a = xmlExports;
  const StreamError = StreamError_1;
  const { parseHost, parseService } = utilExports;

  const NS_STREAM = "urn:ietf:params:xml:ns:xmpp-streams";
  const NS_JABBER_STREAM = "http://etherx.jabber.org/streams";

  let Connection$2 = class Connection extends EventEmitter$2 {
    constructor(options = {}) {
      super();
      this.jid = null;
      this.timeout = 2000;
      this.options = options;
      this.socketListeners = Object.create(null);
      this.parserListeners = Object.create(null);
      this.status = "offline";
      this.socket = null;
      this.parser = null;
      this.root = null;
    }

    _reset() {
      this.jid = null;
      this.status = "offline";
      this._detachSocket();
      this._detachParser();
    }

    async _streamError(condition, children) {
      try {
        await this.send(
          // prettier-ignore
          xml$a('stream:error', {}, [
            xml$a(condition, {xmlns: NS_STREAM}, children),
          ]),
        );
      } catch {}

      return this._end();
    }

    _onData(data) {
      const str = data.toString("utf8");
      this.emit("input", str);
      this.parser.write(str);
    }

    _onParserError(error) {
      // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-bad-format
      // "This error can be used instead of the more specific XML-related errors,
      // such as <bad-namespace-prefix/>, <invalid-xml/>, <not-well-formed/>, <restricted-xml/>,
      // and <unsupported-encoding/>. However, the more specific errors are RECOMMENDED."
      this._streamError("bad-format");
      this._detachParser();
      this.emit("error", error);
    }

    _attachSocket(socket) {
      this.socket = socket;
      const listeners = this.socketListeners;

      listeners.data = this._onData.bind(this);

      listeners.close = (dirty, event) => {
        this._reset();
        this._status("disconnect", { clean: !dirty, event });
      };

      listeners.connect = () => {
        this._status("connect");
      };

      listeners.error = (error) => {
        this.emit("error", error);
      };

      this.socket.on("close", listeners.close);
      this.socket.on("data", listeners.data);
      this.socket.on("error", listeners.error);
      this.socket.on("connect", listeners.connect);
    }

    _detachSocket() {
      const { socketListeners, socket } = this;
      for (const k of Object.getOwnPropertyNames(socketListeners)) {
        socket.removeListener(k, socketListeners[k]);
        delete socketListeners[k];
      }
      this.socket = null;
      return socket;
    }

    _onElement(element) {
      const isStreamError = element.is("error", NS_JABBER_STREAM);

      if (isStreamError) {
        this._onStreamError(element);
      }

      this.emit("element", element);
      this.emit(this.isStanza(element) ? "stanza" : "nonza", element);

      if (isStreamError) {
        // "Stream Errors Are Unrecoverable"
        // "The entity that receives the stream error then SHALL close the stream"
        this._end();
      }
    }

    // https://xmpp.org/rfcs/rfc6120.html#streams-error
    _onStreamError(element) {
      const error = StreamError.fromElement(element);

      if (error.condition === "see-other-host") {
        return this._onSeeOtherHost(error);
      }

      this.emit("error", error);
    }

    // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-see-other-host
    async _onSeeOtherHost(error) {
      const { protocol } = parseService(this.options.service);

      const host = error.element.getChildText("see-other-host");
      const { port } = parseHost(host);

      let service;
      service = port
        ? `${protocol || "xmpp:"}//${host}`
        : (protocol ? `${protocol}//` : "") + host;

      try {
        await promise$1(this, "disconnect");
        const { domain, lang } = this.options;
        await this.connect(service);
        await this.open({ domain, lang });
      } catch (err) {
        this.emit("error", err);
      }
    }

    _attachParser(parser) {
      this.parser = parser;
      const listeners = this.parserListeners;

      listeners.element = this._onElement.bind(this);
      listeners.error = this._onParserError.bind(this);

      listeners.end = (element) => {
        this._detachParser();
        this._status("close", element);
      };

      listeners.start = (element) => {
        this._status("open", element);
      };

      this.parser.on("error", listeners.error);
      this.parser.on("element", listeners.element);
      this.parser.on("end", listeners.end);
      this.parser.on("start", listeners.start);
    }

    _detachParser() {
      const listeners = this.parserListeners;
      for (const k of Object.getOwnPropertyNames(listeners)) {
        this.parser.removeListener(k, listeners[k]);
        delete listeners[k];
      }
      this.parser = null;
    }

    _jid(id) {
      this.jid = jid$2(id);
      return this.jid;
    }

    _status(status, ...args) {
      this.status = status;
      this.emit("status", status, ...args);
      this.emit(status, ...args);
    }

    async _end() {
      let el;
      try {
        el = await this.close();
      } catch {}

      try {
        await this.disconnect();
      } catch {}

      return el;
    }

    /**
     * Opens the socket then opens the stream
     */
    async start() {
      if (this.status !== "offline") {
        throw new Error("Connection is not offline");
      }

      const { service, domain, lang } = this.options;

      await this.connect(service);

      const promiseOnline = promise$1(this, "online");

      await this.open({ domain, lang });

      return promiseOnline;
    }

    /**
     * Connects the socket
     */
    async connect(service) {
      this._status("connecting", service);
      const socket = new this.Socket();
      this._attachSocket(socket);
      // The 'connect' status is set by the socket 'connect' listener
      socket.connect(this.socketParameters(service));
      return promise$1(socket, "connect");
    }

    /**
     * Disconnects the socket
     * https://xmpp.org/rfcs/rfc6120.html#streams-close
     * https://tools.ietf.org/html/rfc7395#section-3.6
     */
    async disconnect(timeout = this.timeout) {
      if (this.socket) this._status("disconnecting");

      this.socket.end();

      // The 'disconnect' status is set by the socket 'close' listener
      await promise$1(this.socket, "close", "error", timeout);
    }

    /**
     * Opens the stream
     */
    async open(options) {
      this._status("opening");

      if (typeof options === "string") {
        options = { domain: options };
      }

      const { domain, lang, timeout = this.timeout } = options;

      const headerElement = this.headerElement();
      headerElement.attrs.to = domain;
      headerElement.attrs["xml:lang"] = lang;
      this.root = headerElement;

      this._attachParser(new this.Parser());

      await this.write(this.header(headerElement));
      return promise$1(this, "open", "error", timeout);
    }

    /**
     * Closes the stream then closes the socket
     * https://xmpp.org/rfcs/rfc6120.html#streams-close
     * https://tools.ietf.org/html/rfc7395#section-3.6
     */
    async stop() {
      const el = await this._end();
      if (this.status !== "offline") this._status("offline", el);
      return el;
    }

    /**
     * Closes the stream and wait for the server to close it
     * https://xmpp.org/rfcs/rfc6120.html#streams-close
     * https://tools.ietf.org/html/rfc7395#section-3.6
     */
    async close(timeout = this.timeout) {
      const fragment = this.footer(this.footerElement());

      const p = Promise.all([
        promise$1(this.parser, "end", "error", timeout),
        this.write(fragment),
      ]);

      if (this.parser && this.socket) this._status("closing");
      const [el] = await p;
      this.root = null;
      return el;
      // The 'close' status is set by the parser 'end' listener
    }

    /**
     * Restart the stream
     * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation-restart
     */
    async restart() {
      this._detachParser();
      const { domain, lang } = this.options;
      return this.open({ domain, lang });
    }

    async send(element) {
      element.parent = this.root;
      await this.write(element.toString());
      this.emit("send", element);
    }

    sendReceive(element, timeout = this.timeout) {
      return Promise.all([
        this.send(element),
        promise$1(this, "element", "error", timeout),
      ]).then(([, el]) => el);
    }

    write(string) {
      return new Promise((resolve, reject) => {
        // https://xmpp.org/rfcs/rfc6120.html#streams-close
        // "Refrain from sending any further data over its outbound stream to the other entity"
        if (this.status === "closing") {
          reject(new Error("Connection is closing"));
          return;
        }

        this.socket.write(string, (err) => {
          if (err) {
            return reject(err);
          }

          this.emit("output", string);
          resolve();
        });
      });
    }

    isStanza(element) {
      const { name } = element;
      return name === "iq" || name === "message" || name === "presence";
    }

    isNonza(element) {
      return !this.isStanza(element);
    }

    // Override
    header(el) {
      return el.toString();
    }

    // Override
    headerElement() {
      return new xml$a.Element("", {
        version: "1.0",
        xmlns: this.NS,
      });
    }

    // Override
    footer(el) {
      return el.toString();
    }

    // Override
    footerElement() {}

    // Override
    socketParameters() {}
  };

  // Overrirde
  Connection$2.prototype.NS = "";
  Connection$2.prototype.Socket = null;
  Connection$2.prototype.Parser = null;

  var connection = Connection$2;

  const Connection$1 = connection;

  let Client$2 = class Client extends Connection$1 {
    constructor(options) {
      super(options);
      this.transports = [];
    }

    send(element, ...args) {
      return this.Transport.prototype.send.call(this, element, ...args);
    }

    sendMany(...args) {
      return this.Transport.prototype.sendMany.call(this, ...args);
    }

    _findTransport(service) {
      return this.transports.find((Transport) => {
        try {
          return Transport.prototype.socketParameters(service) !== undefined;
        } catch {
          return false;
        }
      });
    }

    connect(service) {
      const Transport = this._findTransport(service);

      if (!Transport) {
        throw new Error("No compatible connection method found.");
      }

      this.Transport = Transport;
      this.Socket = Transport.prototype.Socket;
      this.Parser = Transport.prototype.Parser;

      return super.connect(service);
    }

    socketParameters(...args) {
      return this.Transport.prototype.socketParameters(...args);
    }

    header(...args) {
      return this.Transport.prototype.header(...args);
    }

    headerElement(...args) {
      return this.Transport.prototype.headerElement(...args);
    }

    footer(...args) {
      return this.Transport.prototype.footer(...args);
    }

    footerElement(...args) {
      return this.Transport.prototype.footerElement(...args);
    }
  };

  Client$2.prototype.NS = "jabber:client";

  var Client_1 = Client$2;

  const Client$1 = Client_1;
  const xml$9 = xmlExports;
  const jid$1 = jidExports;

  clientCore.Client = Client$1;
  clientCore.xml = xml$9;
  clientCore.jid = jid$1;

  var getDomain$1 = function getDomain(service) {
    const domain = service.split("://")[1] || service;
    return domain.split(":")[0].split("/")[0];
  };

  const { EventEmitter: EventEmitter$1 } = events$1;

  class Reconnect extends EventEmitter$1 {
    constructor(entity) {
      super();

      this.delay = 1000;
      this.entity = entity;
      this._timeout = null;
    }

    scheduleReconnect() {
      const { entity, delay, _timeout } = this;
      clearTimeout(_timeout);
      this._timeout = setTimeout(async () => {
        if (entity.status !== "disconnect") {
          return;
        }

        try {
          await this.reconnect();
        } catch {
          // Ignoring the rejection is safe because the error is emitted on entity by #start
        }
      }, delay);
    }

    async reconnect() {
      const { entity } = this;
      this.emit("reconnecting");

      const { service, domain, lang } = entity.options;
      await entity.connect(service);
      await entity.open({ domain, lang });

      this.emit("reconnected");
    }

    start() {
      const { entity } = this;
      const listeners = {};
      listeners.disconnect = () => {
        this.scheduleReconnect();
      };

      this.listeners = listeners;
      entity.on("disconnect", listeners.disconnect);
    }

    stop() {
      const { entity, listeners, _timeout } = this;
      entity.removeListener("disconnect", listeners.disconnect);
      clearTimeout(_timeout);
    }
  }

  var reconnect = function reconnect({ entity }) {
    const r = new Reconnect(entity);
    r.start();
    return r;
  };

  const WS = require$$0$3;
  const WebSocket = commonjsGlobal.WebSocket || WS;
  const EventEmitter = require$$1$2;

  const CODE = "ECONNERROR";

  let Socket$1 = class Socket extends EventEmitter {
    constructor() {
      super();
      this.listeners = Object.create(null);
    }

    connect(url) {
      this.url = url;
      this._attachSocket(new WebSocket(url, ["xmpp"]));
    }

    _attachSocket(socket) {
      this.socket = socket;
      const { listeners } = this;
      listeners.open = () => {
        this.emit("connect");
      };

      listeners.message = ({ data }) => this.emit("data", data);
      listeners.error = (event) => {
        const { url } = this;
        // WS
        let { error } = event;
        // DOM
        if (!error) {
          error = new Error(`WebSocket ${CODE} ${url}`);
          error.errno = CODE;
          error.code = CODE;
        }

        error.event = event;
        error.url = url;
        this.emit("error", error);
      };

      listeners.close = (event) => {
        this._detachSocket();
        this.emit("close", !event.wasClean, event);
      };

      this.socket.addEventListener("open", listeners.open);
      this.socket.addEventListener("message", listeners.message);
      this.socket.addEventListener("error", listeners.error);
      this.socket.addEventListener("close", listeners.close);
    }

    _detachSocket() {
      delete this.url;
      const { socket, listeners } = this;
      for (const k of Object.getOwnPropertyNames(listeners)) {
        socket.removeEventListener(k, listeners[k]);
        delete listeners[k];
      }
      delete this.socket;
    }

    end() {
      this.socket.close();
    }

    write(data, fn) {
      if (WebSocket === WS) {
        this.socket.send(data, fn);
      } else {
        this.socket.send(data);
        fn();
      }
    }
  };

  var Socket_1 = Socket$1;

  const { Parser: Parser$1, Element, XMLError } = xmlExports;

  var FramedParser_1 = class FramedParser extends Parser$1 {
    onStartElement(name, attrs) {
      const element = new Element(name, attrs);

      const { cursor } = this;

      if (cursor) {
        cursor.append(element);
      }

      this.cursor = element;
    }

    onEndElement(name) {
      const { cursor } = this;
      if (name !== cursor.name) {
        // <foo></bar>
        this.emit("error", new XMLError(`${cursor.name} must be closed.`));
        return;
      }

      if (cursor.parent) {
        this.cursor = cursor.parent;
        return;
      }

      if (cursor.is("open", "urn:ietf:params:xml:ns:xmpp-framing")) {
        this.emit("start", cursor);
      } else if (cursor.is("close", "urn:ietf:params:xml:ns:xmpp-framing")) {
        this.emit("end", cursor);
      } else {
        this.emit("element", cursor);
      }

      this.cursor = null;
    }
  };

  const Socket = Socket_1;
  const Connection = connection;
  const xml$8 = xmlExports;
  const FramedParser = FramedParser_1;

  const NS_FRAMING = "urn:ietf:params:xml:ns:xmpp-framing";

  /* References
   * WebSocket protocol https://tools.ietf.org/html/rfc6455
   * WebSocket Web API https://html.spec.whatwg.org/multipage/comms.html#network
   * XMPP over WebSocket https://tools.ietf.org/html/rfc7395
   */

  let ConnectionWebSocket$1 = class ConnectionWebSocket extends Connection {
    send(element, ...args) {
      if (!element.attrs.xmlns && super.isStanza(element)) {
        element.attrs.xmlns = "jabber:client";
      }

      return super.send(element, ...args);
    }

    async sendMany(elements) {
      for (const element of elements) {
        await this.send(element);
      }
    }

    // https://tools.ietf.org/html/rfc7395#section-3.6
    footerElement() {
      return new xml$8.Element("close", {
        xmlns: NS_FRAMING,
      });
    }

    // https://tools.ietf.org/html/rfc7395#section-3.4
    headerElement() {
      const el = super.headerElement();
      el.name = "open";
      el.attrs.xmlns = NS_FRAMING;
      return el;
    }

    socketParameters(service) {
      return /^wss?:\/\//.test(service) ? service : undefined;
    }
  };

  ConnectionWebSocket$1.prototype.Socket = Socket;
  ConnectionWebSocket$1.prototype.NS = "jabber:client";
  ConnectionWebSocket$1.prototype.Parser = FramedParser;

  var Connection_1 = ConnectionWebSocket$1;

  const ConnectionWebSocket = Connection_1;

  var websocket = function websocket({ entity }) {
    entity.transports.push(ConnectionWebSocket);
  };

  /**
   * Expose compositor.
   */

  var koaCompose = compose$1;

  /**
   * Compose `middleware` returning
   * a fully valid middleware comprised
   * of all those which are passed.
   *
   * @param {Array} middleware
   * @return {Function}
   * @api public
   */

  function compose$1 (middleware) {
    if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
    for (const fn of middleware) {
      if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
    }

    /**
     * @param {Object} context
     * @return {Promise}
     * @api public
     */

    return function (context, next) {
      // last called middleware #
      let index = -1;
      return dispatch(0)
      function dispatch (i) {
        if (i <= index) return Promise.reject(new Error('next() called multiple times'))
        index = i;
        let fn = middleware[i];
        if (i === middleware.length) fn = next;
        if (!fn) return Promise.resolve()
        try {
          return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
        } catch (err) {
          return Promise.reject(err)
        }
      }
    }
  }

  var Context_1 = class Context {
    constructor(entity, stanza) {
      this.stanza = stanza;
      this.entity = entity;

      const { name, attrs } = stanza;
      const { type, id } = attrs;

      this.name = name;
      this.id = id || "";

      if (name === "message") {
        this.type = type || "normal";
      } else if (name === "presence") {
        this.type = type || "available";
      } else {
        this.type = type || "";
      }

      this.from = null;
      this.to = null;
      this.local = "";
      this.domain = "";
      this.resource = "";
    }
  };

  const Context$1 = Context_1;
  const JID$1 = jidExports;

  var IncomingContext_1 = class IncomingContext extends Context$1 {
    constructor(entity, stanza) {
      super(entity, stanza);

      const { jid, domain } = entity;

      const to = stanza.attrs.to || (jid && jid.toString());
      const from = stanza.attrs.from || domain;

      if (to) this.to = new JID$1(to);

      if (from) {
        this.from = new JID$1(from);
        this.local = this.from.local;
        this.domain = this.from.domain;
        this.resource = this.from.resource;
      }
    }
  };

  const Context = Context_1;
  const JID = jidExports;

  var OutgoingContext_1 = class OutgoingContext extends Context {
    constructor(entity, stanza) {
      super(entity, stanza);

      const { jid, domain } = entity;

      const from = stanza.attrs.from || (jid && jid.toString());
      const to = stanza.attrs.to || domain;

      if (from) this.from = new JID(from);

      if (to) {
        this.to = new JID(to);
        this.local = this.to.local;
        this.domain = this.to.domain;
        this.resource = this.to.resource;
      }
    }
  };

  const compose = koaCompose;

  const IncomingContext = IncomingContext_1;
  const OutgoingContext = OutgoingContext_1;

  function listener(entity, middleware, Context) {
    return (stanza) => {
      const ctx = new Context(entity, stanza);
      return compose(middleware)(ctx);
    };
  }

  function errorHandler(entity) {
    return (ctx, next) => {
      next()
        .then((reply) => reply && entity.send(reply))
        .catch((err) => entity.emit("error", err));
    };
  }

  var middleware = function middleware({ entity }) {
    const incoming = [errorHandler(entity)];
    const outgoing = [];

    const incomingListener = listener(entity, incoming, IncomingContext);
    const outgoingListener = listener(entity, outgoing, OutgoingContext);

    entity.on("element", incomingListener);
    entity.hookOutgoing = outgoingListener;

    return {
      use(fn) {
        incoming.push(fn);
        return fn;
      },
      filter(fn) {
        outgoing.push(fn);
        return fn;
      },
    };
  };

  var route$3 = function route() {
    return async ({ stanza, entity }, next) => {
      if (!stanza.is("features", "http://etherx.jabber.org/streams"))
        return next();

      const prevent = await next();
      if (!prevent && entity.jid) entity._status("online", entity.jid);
    };
  };

  /**
   * References
   * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation Stream Negotiation
   * https://xmpp.org/extensions/xep-0170.html XEP-0170: Recommended Order of Stream Feature Negotiation
   * https://xmpp.org/registrar/stream-features.html XML Stream Features
   */

  const route$2 = route$3;

  var streamFeatures = function streamFeatures({ middleware }) {
    middleware.use(route$2());

    function use(name, xmlns, handler) {
      return middleware.use((ctx, next) => {
        const { stanza } = ctx;
        if (!stanza.is("features", "http://etherx.jabber.org/streams"))
          return next();
        const feature = stanza.getChild(name, xmlns);
        if (!feature) return next();
        return handler(ctx, next, feature);
      });
    }

    return {
      use,
    };
  };

  var id = function id() {
    let i;
    while (!i) {
      i = Math.random().toString(36).slice(2, 12);
    }

    return i;
  };

  /* https://xmpp.org/rfcs/rfc6120.html#stanzas-error */

  const XMPPError$1 = error;

  let StanzaError$1 = class StanzaError extends XMPPError$1 {
    constructor(condition, text, application, type) {
      super(condition, text, application);
      this.type = type;
      this.name = "StanzaError";
    }

    static fromElement(element) {
      const error = super.fromElement(element);
      error.type = element.attrs.type;
      return error;
    }
  };

  var StanzaError_1 = StanzaError$1;

  const xid = id;
  const StanzaError = StanzaError_1;
  const { Deferred } = events$1;
  const timeoutPromise = events$1.timeout;
  const xml$7 = xmlExports;

  function isReply({ name, type }) {
    if (name !== "iq") return false;
    if (type !== "error" && type !== "result") return false;
    return true;
  }

  class IQCaller {
    constructor({ entity, middleware }) {
      this.handlers = new Map();
      this.entity = entity;
      this.middleware = middleware;
    }

    start() {
      this.middleware.use(this._route.bind(this));
    }

    _route({ type, name, id, stanza }, next) {
      if (!isReply({ name, type })) return next();

      const deferred = this.handlers.get(id);

      if (!deferred) {
        return next();
      }

      if (type === "error") {
        deferred.reject(StanzaError.fromElement(stanza.getChild("error")));
      } else {
        deferred.resolve(stanza);
      }

      this.handlers.delete(id);
    }

    async request(stanza, timeout = 30 * 1000) {
      if (!stanza.attrs.id) {
        stanza.attrs.id = xid();
      }

      const deferred = new Deferred();
      this.handlers.set(stanza.attrs.id, deferred);

      try {
        await this.entity.send(stanza);
        await timeoutPromise(deferred.promise, timeout);
      } catch (err) {
        this.handlers.delete(stanza.attrs.id);
        throw err;
      }

      return deferred.promise;
    }

    _childRequest(type, element, to, ...args) {
      const {
        name,
        attrs: { xmlns },
      } = element;
      return this.request(xml$7("iq", { type, to }, element), ...args).then(
        (stanza) => stanza.getChild(name, xmlns),
      );
    }

    async get(...args) {
      return this._childRequest("get", ...args);
    }

    async set(...args) {
      return this._childRequest("set", ...args);
    }
  }

  var caller = function iqCaller(...args) {
    const iqCaller = new IQCaller(...args);
    iqCaller.start();
    return iqCaller;
  };

  /**
   * References
   * https://xmpp.org/rfcs/rfc6120.html#stanzas-semantics-iq
   * https://xmpp.org/rfcs/rfc6120.html#stanzas-error
   */

  const xml$6 = xmlExports;

  const NS_STANZA = "urn:ietf:params:xml:ns:xmpp-stanzas";

  function isQuery({ name, type }) {
    if (name !== "iq") return false;
    if (type === "error" || type === "result") return false;
    return true;
  }

  function isValidQuery({ type }, children, child) {
    if (type !== "get" && type !== "set") return false;
    if (children.length !== 1) return false;
    if (!child) return false;
    return true;
  }

  function buildReply({ stanza }) {
    return xml$6("iq", {
      to: stanza.attrs.from,
      from: stanza.attrs.to,
      id: stanza.attrs.id,
    });
  }

  function buildReplyResult(ctx, child) {
    const reply = buildReply(ctx);
    reply.attrs.type = "result";
    if (child) {
      reply.append(child);
    }

    return reply;
  }

  function buildReplyError(ctx, error, child) {
    const reply = buildReply(ctx);
    reply.attrs.type = "error";
    if (child) {
      reply.append(child);
    }

    reply.append(error);
    return reply;
  }

  function buildError(type, condition) {
    return xml$6("error", { type }, xml$6(condition, NS_STANZA));
  }

  function iqHandler(entity) {
    return async function iqHandler(ctx, next) {
      if (!isQuery(ctx)) return next();

      const { stanza } = ctx;
      const children = stanza.getChildElements();
      const [child] = children;

      if (!isValidQuery(ctx, children, child)) {
        return buildReplyError(ctx, buildError("modify", "bad-request"), child);
      }

      ctx.element = child;

      let reply;
      try {
        reply = await next();
      } catch (err) {
        entity.emit("error", err);
        reply = buildError("cancel", "internal-server-error");
      }

      if (!reply) {
        reply = buildError("cancel", "service-unavailable");
      }

      if (reply instanceof xml$6.Element && reply.is("error")) {
        return buildReplyError(ctx, reply, child);
      }

      return buildReplyResult(
        ctx,
        reply instanceof xml$6.Element ? reply : undefined,
      );
    };
  }

  function route$1(type, ns, name, handler) {
    return (ctx, next) => {
      if ((ctx.type !== type) | !ctx.element || !ctx.element.is(name, ns))
        return next();
      return handler(ctx, next);
    };
  }

  var callee = function iqCallee({ middleware, entity }) {
    middleware.use(iqHandler(entity));

    return {
      get(ns, name, handler) {
        middleware.use(route$1("get", ns, name, handler));
      },
      set(ns, name, handler) {
        middleware.use(route$1("set", ns, name, handler));
      },
    };
  };

  var resolve$2 = {exports: {}};

  var http$1 = {};

  const Parser = Parser_1;

  var parse$1 = function parse(data) {
    const p = new Parser();

    let result = null;
    let error = null;

    p.on("start", (el) => {
      result = el;
    });
    p.on("element", (el) => {
      result.append(el);
    });
    p.on("error", (err) => {
      error = err;
    });

    p.write(data);
    p.end();

    if (error) {
      throw error;
    } else {
      return result;
    }
  };

  var altConnections = {};

  function isSecure(uri) {
    return uri.startsWith("https") || uri.startsWith("wss");
  }

  altConnections.compare = function compare(a, b) {
    let secure;
    if (isSecure(a.uri) && !isSecure(b.uri)) {
      secure = -1;
    } else if (!isSecure(a.uri) && isSecure(b.uri)) {
      secure = 1;
    } else {
      secure = 0;
    }

    if (secure !== 0) {
      return secure;
    }

    let method;
    if (a.method === b.method) {
      method = 0;
    } else if (a.method === "websocket") {
      method = -1;
    } else if (b.method === "websocket") {
      method = 1;
    } else if (a.method === "xbosh") {
      method = -1;
    } else if (b.method === "xbosh") {
      method = 1;
    } else if (a.method === "httppoll") {
      method = -1;
    } else if (b.method === "httppoll") {
      method = 1;
    } else {
      method = 0;
    }

    if (method !== 0) {
      return method;
    }

    return 0;
  };

  const fetch$1 = commonjsGlobal.fetch || require$$0$3;
  const parse = parse$1;
  const compareAltConnections = altConnections.compare;

  function resolve$1(domain) {
    return fetch$1(`https://${domain}/.well-known/host-meta`)
      .then((res) => res.text())
      .then((res) => {
        return parse(res)
          .getChildren("Link")
          .filter((link) =>
            [
              "urn:xmpp:alt-connections:websocket",
              "urn:xmpp:alt-connections:httppoll",
              "urn:xmpp:alt-connections:xbosh",
            ].includes(link.attrs.rel),
          )
          .map(({ attrs }) => ({
            rel: attrs.rel,
            href: attrs.href,
            method: attrs.rel.split(":").pop(),
            uri: attrs.href,
          }))
          .sort(compareAltConnections);
      })
      .catch(() => {
        return [];
      });
  }

  http$1.resolve = resolve$1;

  const dns = require$$0$3;
  const http = http$1;

  resolve$2.exports = function resolve(...args) {
    return Promise.all([
      dns.resolve ? dns.resolve(...args) : Promise.resolve([]),
      http.resolve(...args),
    ]).then(([records, endpoints]) => [...records, ...endpoints]);
  };

  if (dns.resolve) {
    resolve$2.exports.dns = dns;
  }

  resolve$2.exports.http = http;

  var resolveExports = resolve$2.exports;

  const resolve = resolveExports;
  const { promise } = events$1;

  async function fetchURIs(domain) {
    const result = await resolve(domain, {
      srv: [
        {
          service: "xmpps-client",
          protocol: "tcp",
        },
        {
          service: "xmpp-client",
          protocol: "tcp",
        },
      ],
    });

    return [
      // Remove duplicates
      ...new Set(result.map((record) => record.uri)),
    ];
  }

  function filterSupportedURIs(entity, uris) {
    return uris.filter((uri) => entity._findTransport(uri));
  }

  async function fallbackConnect(entity, uris) {
    if (uris.length === 0) {
      throw new Error("Couldn't connect");
    }

    const uri = uris.shift();
    const Transport = entity._findTransport(uri);

    if (!Transport) {
      return fallbackConnect(entity, uris);
    }

    entity._status("connecting", uri);
    const params = Transport.prototype.socketParameters(uri);
    const socket = new Transport.prototype.Socket();

    try {
      socket.connect(params);
      await promise(socket, "connect");
    } catch {
      return fallbackConnect(entity, uris);
    }

    entity._attachSocket(socket);
    socket.emit("connect");
    entity.Transport = Transport;
    entity.Socket = Transport.prototype.Socket;
    entity.Parser = Transport.prototype.Parser;
  }

  var resolve_1 = function resolve({ entity }) {
    const _connect = entity.connect;
    entity.connect = async function connect(service) {
      if (!service || /:\/\//.test(service)) {
        return _connect.call(this, service);
      }

      const uris = filterSupportedURIs(entity, await fetchURIs(service));

      if (uris.length === 0) {
        throw new Error("No compatible transport found.");
      }

      try {
        await fallbackConnect(entity, uris);
      } catch (err) {
        entity._reset();
        entity._status("disconnect");
        throw err;
      }
    };
  };

  var browser = {};

  browser.encode = function encode(string) {
    return commonjsGlobal.btoa(string);
  };

  browser.decode = function decode(string) {
    return commonjsGlobal.atob(string);
  };

  const XMPPError = error;

  // https://xmpp.org/rfcs/rfc6120.html#sasl-errors

  let SASLError$1 = class SASLError extends XMPPError {
    constructor(...args) {
      super(...args);
      this.name = "SASLError";
    }
  };

  var SASLError_1 = SASLError$1;

  var main$2 = {exports: {}};

  var factory = {exports: {}};

  var hasRequiredFactory;

  function requireFactory () {
  	if (hasRequiredFactory) return factory.exports;
  	hasRequiredFactory = 1;
  	(function (module, exports) {
  		(function(root, factory) {
  		  {
  		    // CommonJS
  		    factory(exports, module);
  		  }
  		}(commonjsGlobal, function(exports, module) {
  		  
  		  /**
  		   * `Factory` constructor.
  		   *
  		   * @api public
  		   */
  		  function Factory() {
  		    this._mechs = [];
  		  }
  		  
  		  /**
  		   * Utilize the given `mech` with optional `name`, overridding the mechanism's
  		   * default name.
  		   *
  		   * Examples:
  		   *
  		   *     factory.use(FooMechanism);
  		   *
  		   *     factory.use('XFOO', FooMechanism);
  		   *
  		   * @param {String|Mechanism} name
  		   * @param {Mechanism} mech
  		   * @return {Factory} for chaining
  		   * @api public
  		   */
  		  Factory.prototype.use = function(name, mech) {
  		    if (!mech) {
  		      mech = name;
  		      name = mech.prototype.name;
  		    }
  		    this._mechs.push({ name: name, mech: mech });
  		    return this;
  		  };
  		  
  		  /**
  		   * Create a new mechanism from supported list of `mechs`.
  		   *
  		   * If no mechanisms are supported, returns `null`.
  		   *
  		   * Examples:
  		   *
  		   *     var mech = factory.create(['FOO', 'BAR']);
  		   *
  		   * @param {Array} mechs
  		   * @return {Mechanism}
  		   * @api public
  		   */
  		  Factory.prototype.create = function(mechs) {
  		    for (var i = 0, len = this._mechs.length; i < len; i++) {
  		      for (var j = 0, jlen = mechs.length; j < jlen; j++) {
  		        var entry = this._mechs[i];
  		        if (entry.name == mechs[j]) {
  		          return new entry.mech();
  		        }
  		      }
  		    }
  		    return null;
  		  };

  		  module.exports = Factory;
  		  
  		})); 
  	} (factory, factory.exports));
  	return factory.exports;
  }

  (function (module, exports) {
  	(function(root, factory) {
  	  {
  	    // CommonJS
  	    factory(exports,
  	            module,
  	            requireFactory());
  	  }
  	}(commonjsGlobal, function(exports, module, Factory) {
  	  
  	  exports = module.exports = Factory;
  	  exports.Factory = Factory;
  	  
  	})); 
  } (main$2, main$2.exports));

  var mainExports$2 = main$2.exports;

  const { encode, decode } = browser;
  const SASLError = SASLError_1;
  const xml$5 = xmlExports;
  const SASLFactory = mainExports$2;

  // https://xmpp.org/rfcs/rfc6120.html#sasl

  const NS$3 = "urn:ietf:params:xml:ns:xmpp-sasl";

  function getMechanismNames(features) {
    return features.getChild("mechanisms", NS$3).children.map((el) => el.text());
  }

  async function authenticate(SASL, entity, mechname, credentials) {
    const mech = SASL.create([mechname]);
    if (!mech) {
      throw new Error("No compatible mechanism");
    }

    const { domain } = entity.options;
    const creds = {
      username: null,
      password: null,
      server: domain,
      host: domain,
      realm: domain,
      serviceType: "xmpp",
      serviceName: domain,
      ...credentials,
    };

    return new Promise((resolve, reject) => {
      const handler = (element) => {
        if (element.attrs.xmlns !== NS$3) {
          return;
        }

        if (element.name === "challenge") {
          mech.challenge(decode(element.text()));
          const resp = mech.response(creds);
          entity.send(
            xml$5(
              "response",
              { xmlns: NS$3, mechanism: mech.name },
              typeof resp === "string" ? encode(resp) : "",
            ),
          );
          return;
        }

        if (element.name === "failure") {
          reject(SASLError.fromElement(element));
        } else if (element.name === "success") {
          resolve();
        }

        entity.removeListener("nonza", handler);
      };

      entity.on("nonza", handler);

      if (mech.clientFirst) {
        entity.send(
          xml$5(
            "auth",
            { xmlns: NS$3, mechanism: mech.name },
            encode(mech.response(creds)),
          ),
        );
      }
    });
  }

  var sasl = function sasl({ streamFeatures }, credentials) {
    const SASL = new SASLFactory();

    streamFeatures.use("mechanisms", NS$3, async ({ stanza, entity }) => {
      const offered = getMechanismNames(stanza);
      const supported = SASL._mechs.map(({ name }) => name);
      // eslint-disable-next-line unicorn/prefer-array-find
      const intersection = supported.filter((mech) => {
        return offered.includes(mech);
      });
      // eslint-disable-next-line prefer-destructuring
      let mech = intersection[0];

      if (typeof credentials === "function") {
        await credentials(
          (creds) => authenticate(SASL, entity, mech, creds),
          mech,
        );
      } else {
        if (!credentials.username && !credentials.password) {
          mech = "ANONYMOUS";
        }

        await authenticate(SASL, entity, mech, credentials);
      }

      await entity.restart();
    });

    return {
      use(...args) {
        return SASL.use(...args);
      },
    };
  };

  const xml$4 = xmlExports;

  /*
   * References
   * https://xmpp.org/rfcs/rfc6120.html#bind
   */

  const NS$2 = "urn:ietf:params:xml:ns:xmpp-bind";

  function makeBindElement(resource) {
    return xml$4("bind", { xmlns: NS$2 }, resource && xml$4("resource", {}, resource));
  }

  async function bind(entity, iqCaller, resource) {
    const result = await iqCaller.set(makeBindElement(resource));
    const jid = result.getChildText("jid");
    entity._jid(jid);
    return jid;
  }

  function route({ iqCaller }, resource) {
    return async ({ entity }, next) => {
      await (typeof resource === "function"
        ? resource((resource) => bind(entity, iqCaller, resource))
        : bind(entity, iqCaller, resource));

      next();
    };
  }

  var resourceBinding = function resourceBinding(
    { streamFeatures, iqCaller },
    resource,
  ) {
    streamFeatures.use("bind", NS$2, route({ iqCaller }, resource));
  };

  const xml$3 = xmlExports;

  // https://tools.ietf.org/html/draft-cridland-xmpp-session-01

  const NS$1 = "urn:ietf:params:xml:ns:xmpp-session";

  var sessionEstablishment = function sessionEstablishment({ iqCaller, streamFeatures }) {
    streamFeatures.use("session", NS$1, async (context, next, feature) => {
      if (feature.getChild("optional")) return next();
      await iqCaller.set(xml$3("session", NS$1));
      return next();
    });
  };

  const xml$2 = xmlExports;

  // https://xmpp.org/extensions/xep-0198.html

  const NS = "urn:xmpp:sm:3";

  async function enable(entity, resume, max) {
    entity.send(
      xml$2("enable", { xmlns: NS, max, resume: resume ? "true" : undefined }),
    );

    return new Promise((resolve, reject) => {
      function listener(nonza) {
        if (nonza.is("enabled", NS)) {
          resolve(nonza);
        } else if (nonza.is("failed", NS)) {
          reject(nonza);
        } else {
          return;
        }

        entity.removeListener("nonza", listener);
      }

      entity.on("nonza", listener);
    });
  }

  async function resume(entity, h, previd) {
    const response = await entity.sendReceive(
      xml$2("resume", { xmlns: NS, h, previd }),
    );

    if (!response.is("resumed", NS)) {
      throw response;
    }

    return response;
  }

  var streamManagement = function streamManagement({
    streamFeatures,
    entity,
    middleware,
  }) {
    let address = null;

    const sm = {
      allowResume: true,
      preferredMaximum: null,
      enabled: false,
      id: "",
      outbound: 0,
      inbound: 0,
      max: null,
    };

    entity.on("online", (jid) => {
      address = jid;
      sm.outbound = 0;
      sm.inbound = 0;
    });

    entity.on("offline", () => {
      sm.outbound = 0;
      sm.inbound = 0;
      sm.enabled = false;
      sm.id = "";
    });

    middleware.use((context, next) => {
      const { stanza } = context;
      if (["presence", "message", "iq"].includes(stanza.name)) {
        sm.inbound += 1;
      } else if (stanza.is("r", NS)) {
        // > When an <r/> element ("request") is received, the recipient MUST acknowledge it by sending an <a/> element to the sender containing a value of 'h' that is equal to the number of stanzas handled by the recipient of the <r/> element.
        entity.send(xml$2("a", { xmlns: NS, h: sm.inbound })).catch(() => {});
      } else if (stanza.is("a", NS)) {
        // > When a party receives an <a/> element, it SHOULD keep a record of the 'h' value returned as the sequence number of the last handled outbound stanza for the current stream (and discard the previous value).
        sm.outbound = stanza.attrs.h;
      }

      return next();
    });

    // https://xmpp.org/extensions/xep-0198.html#enable
    // For client-to-server connections, the client MUST NOT attempt to enable stream management until after it has completed Resource Binding unless it is resuming a previous session

    streamFeatures.use("sm", NS, async (context, next) => {
      // Resuming
      if (sm.id) {
        try {
          await resume(entity, sm.inbound, sm.id);
          sm.enabled = true;
          entity.jid = address;
          entity.status = "online";
          return true;
          // If resumption fails, continue with session establishment
          // eslint-disable-next-line no-unused-vars
        } catch {
          sm.id = "";
          sm.enabled = false;
          sm.outbound = 0;
        }
      }

      // Enabling

      // Resource binding first
      await next();

      const promiseEnable = enable(entity, sm.allowResume, sm.preferredMaximum);

      // > The counter for an entity's own sent stanzas is set to zero and started after sending either <enable/> or <enabled/>.
      sm.outbound = 0;

      try {
        const response = await promiseEnable;
        sm.enabled = true;
        sm.id = response.attrs.id;
        sm.max = response.attrs.max;
        // eslint-disable-next-line no-unused-vars
      } catch {
        sm.enabled = false;
      }

      sm.inbound = 0;
    });

    return sm;
  };

  var main$1 = {exports: {}};

  var mechanism$1 = {exports: {}};

  var hasRequiredMechanism$1;

  function requireMechanism$1 () {
  	if (hasRequiredMechanism$1) return mechanism$1.exports;
  	hasRequiredMechanism$1 = 1;
  	(function (module, exports) {
  		(function(root, factory) {
  		  {
  		    // CommonJS
  		    factory(exports, module);
  		  }
  		}(commonjsGlobal, function(exports, module) {

  		  /**
  		   * ANONYMOUS `Mechanism` constructor.
  		   *
  		   * This class implements the ANONYMOUS SASL mechanism.
  		   *
  		   * The ANONYMOUS SASL mechanism provides support for permitting anonymous
  		   * access to various services
  		   *
  		   * References:
  		   *  - [RFC 4505](http://tools.ietf.org/html/rfc4505)
  		   *
  		   * @api public
  		   */
  		  function Mechanism() {
  		  }
  		  
  		  Mechanism.prototype.name = 'ANONYMOUS';
  		  Mechanism.prototype.clientFirst = true;
  		  
  		  /**
  		   * Encode a response using optional trace information.
  		   *
  		   * Options:
  		   *  - `trace`  trace information (optional)
  		   *
  		   * @param {Object} cred
  		   * @api public
  		   */
  		  Mechanism.prototype.response = function(cred) {
  		    return cred.trace || '';
  		  };
  		  
  		  /**
  		   * Decode a challenge issued by the server.
  		   *
  		   * @param {String} chal
  		   * @api public
  		   */
  		  Mechanism.prototype.challenge = function(chal) {
  		  };

  		  module.exports = Mechanism;
  		  
  		})); 
  	} (mechanism$1, mechanism$1.exports));
  	return mechanism$1.exports;
  }

  (function (module, exports) {
  	(function(root, factory) {
  	  {
  	    // CommonJS
  	    factory(exports,
  	            module,
  	            requireMechanism$1());
  	  }
  	}(commonjsGlobal, function(exports, module, Mechanism) {

  	  exports = module.exports = Mechanism;
  	  exports.Mechanism = Mechanism;
  	  
  	})); 
  } (main$1, main$1.exports));

  var mainExports$1 = main$1.exports;

  /**
   * [XEP-0175: Best Practices for Use of SASL ANONYMOUS](https://xmpp.org/extensions/xep-0175.html)
   * [RFC-4504: Anonymous Simple Authentication and Security Layer (SASL) Mechanism](https://tools.ietf.org/html/rfc4505)
   */

  const mech$1 = mainExports$1;

  var saslAnonymous = function saslAnonymous(sasl) {
    sasl.use(mech$1);
  };

  var main = {exports: {}};

  var mechanism = {exports: {}};

  var hasRequiredMechanism;

  function requireMechanism () {
  	if (hasRequiredMechanism) return mechanism.exports;
  	hasRequiredMechanism = 1;
  	(function (module, exports) {
  		(function(root, factory) {
  		  {
  		    // CommonJS
  		    factory(exports, module);
  		  }
  		}(commonjsGlobal, function(exports, module) {

  		  /**
  		   * PLAIN `Mechanism` constructor.
  		   *
  		   * This class implements the PLAIN SASL mechanism.
  		   *
  		   * The PLAIN SASL mechanism provides support for exchanging a clear-text
  		   * username and password.  This mechanism should not be used without adequate
  		   * security provided by an underlying transport layer. 
  		   *
  		   * References:
  		   *  - [RFC 4616](http://tools.ietf.org/html/rfc4616)
  		   *
  		   * @api public
  		   */
  		  function Mechanism() {
  		  }
  		  
  		  Mechanism.prototype.name = 'PLAIN';
  		  Mechanism.prototype.clientFirst = true;
  		  
  		  /**
  		   * Encode a response using given credential.
  		   *
  		   * Options:
  		   *  - `username`
  		   *  - `password`
  		   *  - `authzid`   authorization identity (optional)
  		   *
  		   * @param {Object} cred
  		   * @api public
  		   */
  		  Mechanism.prototype.response = function(cred) {
  		    var str = '';
  		    str += cred.authzid || '';
  		    str += '\0';
  		    str += cred.username;
  		    str += '\0';
  		    str += cred.password;
  		    return str;
  		  };
  		  
  		  /**
  		   * Decode a challenge issued by the server.
  		   *
  		   * @param {String} chal
  		   * @return {Mechanism} for chaining
  		   * @api public
  		   */
  		  Mechanism.prototype.challenge = function(chal) {
  		    return this;
  		  };

  		  module.exports = Mechanism;
  		  
  		})); 
  	} (mechanism, mechanism.exports));
  	return mechanism.exports;
  }

  (function (module, exports) {
  	(function(root, factory) {
  	  {
  	    // CommonJS
  	    factory(exports,
  	            module,
  	            requireMechanism());
  	  }
  	}(commonjsGlobal, function(exports, module, Mechanism) {

  	  exports = module.exports = Mechanism;
  	  exports.Mechanism = Mechanism;
  	  
  	})); 
  } (main, main.exports));

  var mainExports = main.exports;

  const mech = mainExports;

  var saslPlain = function saslPlain(sasl) {
    sasl.use(mech);
  };

  const { xml: xml$1, jid, Client } = clientCore;
  const getDomain = getDomain$1;

  const _reconnect = reconnect;
  const _websocket = websocket;
  const _middleware = middleware;
  const _streamFeatures = streamFeatures;
  const _iqCaller = caller;
  const _iqCallee = callee;
  const _resolve = resolve_1;

  // Stream features - order matters and define priority
  const _sasl = sasl;
  const _resourceBinding = resourceBinding;
  const _sessionEstablishment = sessionEstablishment;
  const _streamManagement = streamManagement;

  // SASL mechanisms - order matters and define priority
  const anonymous = saslAnonymous;
  const plain = saslPlain;

  function client(options = {}) {
    const { resource, credentials, username, password, ...params } = options;

    const { domain, service } = params;
    if (!domain && service) {
      params.domain = getDomain(service);
    }

    const entity = new Client(params);

    const reconnect = _reconnect({ entity });
    const websocket = _websocket({ entity });

    const middleware = _middleware({ entity });
    const streamFeatures = _streamFeatures({ middleware });
    const iqCaller = _iqCaller({ middleware, entity });
    const iqCallee = _iqCallee({ middleware, entity });
    const resolve = _resolve({ entity });
    // Stream features - order matters and define priority
    const sasl = _sasl({ streamFeatures }, credentials || { username, password });
    const streamManagement = _streamManagement({
      streamFeatures,
      entity,
      middleware,
    });
    const resourceBinding = _resourceBinding(
      { iqCaller, streamFeatures },
      resource,
    );
    const sessionEstablishment = _sessionEstablishment({
      iqCaller,
      streamFeatures,
    });
    // SASL mechanisms - order matters and define priority
    const mechanisms = Object.entries({ plain, anonymous }).map(([k, v]) => ({
      [k]: v(sasl),
    }));

    return Object.assign(entity, {
      entity,
      reconnect,
      websocket,
      middleware,
      streamFeatures,
      iqCaller,
      iqCallee,
      resolve,
      sasl,
      resourceBinding,
      sessionEstablishment,
      streamManagement,
      mechanisms,
    });
  }

  var xml_1 = xml$1;
  var client_1 = client;

  var debug$1 = {exports: {}};

  var _escape = _escape$3;

  function stringify$1(el, indent, level) {
    if (typeof indent === "number") indent = " ".repeat(indent);
    if (!level) level = 1;
    let s = `<${el.name}`;

    for (const k in el.attrs) {
      const v = el.attrs[k];
      // === null || undefined
      if (v != null) {
        s += ` ${k}="${_escape.escapeXML(typeof v === "string" ? v : v.toString(10))}"`;
      }
    }

    if (el.children.length > 0) {
      s += ">";
      for (const child of el.children) {
        if (child == null) continue;
        if (indent) s += "\n" + indent.repeat(level);
        s +=
          typeof child === "string"
            ? _escape.escapeXMLText(child)
            : stringify$1(child, indent, level + 1);
      }
      if (indent) s += "\n" + indent.repeat(level - 1);
      s += `</${el.name}>`;
    } else {
      s += "/>";
    }

    return s;
  }

  var stringify_1 = stringify$1;

  function clone$1(el) {
    if (typeof el !== "object") return el;
    const copy = new el.constructor(el.name, el.attrs);
    for (let i = 0; i < el.children.length; i++) {
      const child = el.children[i];
      copy.cnode(clone$1(child));
    }
    return copy;
  }

  var clone_1 = clone$1;

  /* eslint no-console: 0 */

  const stringify = stringify_1;
  const xml = xmlExports;
  const clone = clone_1;

  const NS_SASL = "urn:ietf:params:xml:ns:xmpp-sasl";
  const NS_COMPONENT = "jabber:component:accept";

  const SENSITIVES = [
    ["handshake", NS_COMPONENT],
    ["auth", NS_SASL],
    ["challenge", NS_SASL],
    ["response", NS_SASL],
    ["success", NS_SASL],
  ];

  function isSensitive(element) {
    if (element.children.length === 0) return false;
    return SENSITIVES.some((sensitive) => {
      return element.is(...sensitive);
    });
  }

  function hideSensitive(element) {
    if (isSensitive(element)) {
      element.children = [];
      element.append(xml("hidden", { xmlns: "xmpp.js" }));
    }

    return element;
  }

  function format(element) {
    return stringify(hideSensitive(clone(element)));
  }

  debug$1.exports = function debug(entity, force) {
    if (browser$1$1.env.XMPP_DEBUG || force === true) {
      entity.on("element", (data) => {
        console.debug(`IN\n${format(data)}`);
      });

      entity.on("send", (data) => {
        console.debug(`OUT\n${format(data)}`);
      });

      entity.on("error", console.error);

      entity.on("status", (status, value) => {
        console.debug("status", status, value ? value.toString() : "");
      });
    }
  };

  debug$1.exports.hideSensitive = hideSensitive;

  var debugExports = debug$1.exports;
  var debug = /*@__PURE__*/getDefaultExportFromCjs(debugExports);

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */
  /**
   * Fetch proofs from XMPP accounts
   * @module fetcher/xmpp
   * @example
   * import { fetcher } from 'doipjs';
   * const data = await fetcher.xmpp.fn({ id: 'alice@domain.example' });
   */


  /**
   * Default timeout after which the fetch is aborted
   * @constant
   * @type {number}
   * @default 5000
   */
  const timeout = 5000;

  let xmpp = null;
  let iqCaller = null;

  /**
   * Start the XMPP client
   * @ignore
   * @function
   * @param {import('../types').XmppClaimVerificationConfig} params - XMPP claim verification config
   * @returns {Promise<object>} The fetched proofs from an XMPP account
   */
  const xmppStart = async (params) => {
    return new Promise((resolve, reject) => {
      const xmpp = client_1({ ...params });
      if (process.env.NODE_ENV !== 'production') {
        debug(xmpp, true);
      }
      const { iqCaller } = xmpp;
      xmpp.start();
      xmpp.on('online', _ => {
        resolve({ xmpp, iqCaller });
      });
      xmpp.on('error', error => {
        reject(error);
      });
    })
  };

  /**
   * Execute a fetch request
   * @function
   * @param {object} data - Data used in the request
   * @param {string} data.id - The identifier of the targeted account
   * @param {number} [data.fetcherTimeout] - Optional timeout for the fetcher
   * @param {import('../types').VerificationConfig} [opts] - Options used to enable the request
   * @returns {Promise<Array<string>>} The fetched proofs from an XMPP account
   */
  async function fn (data, opts) {
    try {
      isFQDN(opts.claims.xmpp.service);
      isAscii(opts.claims.xmpp.username);
      isAscii(opts.claims.xmpp.password);
    } catch (err) {
      throw new Error(`XMPP fetcher was not set up properly (${err.message})`)
    }

    if (!xmpp || xmpp.status !== 'online') {
      const xmppStartRes = await xmppStart(opts.claims.xmpp);
      xmpp = xmppStartRes.xmpp;
      iqCaller = xmppStartRes.iqCaller;
    }

    let timeoutHandle;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(
        () => reject(new Error('Request was timed out')),
        data.fetcherTimeout ? data.fetcherTimeout : timeout
      );
    });

    const fetchPromise = new Promise((resolve, reject) => {
      (async () => {
        let completed = false;
        const proofs = [];

        // Try the ariadne-id pubsub request
        if (!completed) {
          try {
            const response = await iqCaller.request(
              xml_1('iq', { type: 'get', to: data.id }, xml_1('pubsub', 'http://jabber.org/protocol/pubsub', xml_1('items', { node: 'http://ariadne.id/protocol/proof' }))),
              30 * 1000
            );

            // Traverse the XML response
            response.getChild('pubsub').getChildren('items').forEach(items => {
              if (items.attrs.node === 'http://ariadne.id/protocol/proof') {
                items.getChildren('item').forEach(item => {
                  proofs.push(item.getChildText('value'));
                });
              }
            });

            resolve(proofs);
            completed = true;
          } catch (_) {}
        }

        // Try the vcard4 pubsub request [backward compatibility]
        if (!completed) {
          try {
            const response = await iqCaller.request(
              xml_1('iq', { type: 'get', to: data.id }, xml_1('pubsub', 'http://jabber.org/protocol/pubsub', xml_1('items', { node: 'urn:xmpp:vcard4', max_items: '1' }))),
              30 * 1000
            );

            // Traverse the XML response
            response.getChild('pubsub').getChildren('items').forEach(items => {
              if (items.attrs.node === 'urn:xmpp:vcard4') {
                items.getChildren('item').forEach(item => {
                  if (item.attrs.id === 'current') {
                    const itemVcard = item.getChild('vcard', 'urn:ietf:params:xml:ns:vcard-4.0');
                    // Find the vCard URLs
                    itemVcard.getChildren('url').forEach(url => {
                      proofs.push(url.getChildText('uri'));
                    });
                    // Find the vCard notes
                    itemVcard.getChildren('note').forEach(note => {
                      proofs.push(note.getChildText('text'));
                    });
                  }
                });
              }
            });

            resolve(proofs);
            completed = true;
          } catch (_) {}
        }

        // Try the vcard-temp IQ request [backward compatibility]
        if (!completed) {
          try {
            const response = await iqCaller.request(
              xml_1('iq', { type: 'get', to: data.id }, xml_1('vCard', 'vcard-temp')),
              30 * 1000
            );

            // Find the vCard URLs
            response.getChild('vCard', 'vcard-temp').getChildren('URL').forEach(url => {
              proofs.push(url.children[0]);
            });
            // Find the vCard notes
            response.getChild('vCard', 'vcard-temp').getChildren('NOTE').forEach(note => {
              proofs.push(note.children[0]);
            });
            response.getChild('vCard', 'vcard-temp').getChildren('DESC').forEach(note => {
              proofs.push(note.children[0]);
            });

            resolve(proofs);
            completed = true;
          } catch (error) {
            reject(error);
          }
        }

        xmpp.stop();
      })();
    });

    return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
      clearTimeout(timeoutHandle);
    })
  }

  var xmpp$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fn: fn,
    timeout: timeout
  });

  /*
  Copyright 2021 Yarmo Mackenbach

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */

  exports.activitypub = activitypub$1;
  exports.aspe = aspe;
  exports.dns = dns$1;
  exports.graphql = graphql;
  exports.http = http$2;
  exports.irc = irc;
  exports.matrix = matrix;
  exports.openpgp = openpgp;
  exports.telegram = telegram;
  exports.xmpp = xmpp$1;

  return exports;

})({});
